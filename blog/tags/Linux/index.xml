<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Linux on JacobZ</title><link>https://zyxin.xyz/blog/tags/Linux/</link><description>Recent content in Linux on JacobZ</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sat, 20 Nov 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://zyxin.xyz/blog/tags/Linux/index.xml" rel="self" type="application/rss+xml"/><item><title>冬日取暖最佳方式 — 利用闲置的计算资源</title><link>https://zyxin.xyz/blog/2021-11/UtilizeYourComputationPower/</link><pubDate>Sat, 20 Nov 2021 00:00:00 +0000</pubDate><guid>https://zyxin.xyz/blog/2021-11/UtilizeYourComputationPower/</guid><description>&lt;img src="https://zyxin.xyz/blog/2021-11/UtilizeYourComputationPower/primenet-ranking.png" alt="Featured image of post 冬日取暖最佳方式 — 利用闲置的计算资源" />&lt;p>最近突发奇想，想到自己有几台电脑，性能都不错但是经常闲置，包括实验室的服务器也不是每时每刻都在充分利用资源，因此完全可以跑一些别的程序来利用。我最先想到的就是以前做电脑压力测试的Prime95程序，然后一搜发现这里面还是有不少门道的。本文介绍一下如何利用你家电脑闲置的性能,将其贡献给科学事业，并且在冬天的夜晚让它的散热成为一大取暖来源~哈哈哈哈&lt;/p>
&lt;h2 id="gimps">GIMPS&lt;/h2>
&lt;p>我最先测试的程序是Prime95，Prime95是梅森素数搜索计划（Great Internet Mersenne Prime Search, GIMPS）的Windows客户端。这个计划旨在利用互联网的计算资源来寻找梅森素数。形如$2^p-1$（$p$为素数）的数被称为梅森数，如果这个梅森数也是素数那么就被称为梅森素数。梅森素数是目前寻找大素数最高效的目标，人类发现最大的质数前几名都来自于GIMPS发现的梅森素数。&lt;/p>
&lt;p>如果你不想知道很多信息，只想直接开冲，那么你只需要从&lt;a class="link" href="https://www.mersenne.org/download/" target="_blank" rel="noopener"
>GIMPS官网&lt;/a>下载Prime95（Windows）/ mprime（Linux），解压后双击直接开跑就可以了。如果你希望了解这个程序具体在干什么，或者想青史留名找到新的梅森素数，那么请接着往下读这一节~&lt;/p>
&lt;h3 id="primenet">PrimeNet&lt;/h3>
&lt;p>首先需要介绍一下GIMPS的分布式计算网络，名字叫PrimeNet。PrimeNet负责分发计算任务和收集计算结果。由于梅森素数的形式是$2^p-1$，因此PrimeNet中把$p$称为Exponent（指数），验证每个指数对应的梅森数是否为素数是独立的。目前PrimeNet中对于每个指数有如下几种计算任务，括号内为PrimeNet中的缩写：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Trial Factor&lt;/strong> (TF): 暴力遍历素数，测试每个素数是否是当前梅森数的因数。&lt;/li>
&lt;li>&lt;strong>P-1 Test&lt;/strong> (PM1): &lt;a class="link" href="https://en.wikipedia.org/wiki/Pollard%27s_p_%E2%88%92_1_algorithm" target="_blank" rel="noopener"
>Pollard $p-1$&lt;/a>测试法，可以在一定范围内寻找到一个因数$q$，前提是$q-1$是&lt;em>高度复合的&lt;/em>（也被称为&lt;em>smooth&lt;/em>，意思是由很多很多小的质因数合成的合数）&lt;/li>
&lt;li>&lt;strong>P+1 Test&lt;/strong> (PP1): &lt;a class="link" href="https://en.wikipedia.org/wiki/Williams%27s_p_%2B_1_algorithm" target="_blank" rel="noopener"
>Williams $p+1$&lt;/a>测试法，跟P-1测试类似，但是寻找的因数$q$需满足$q+1$高度复合。&lt;/li>
&lt;li>&lt;strong>Lucas-Lehmer Test&lt;/strong> (LL): 一种验证梅森数是否为质数的算法，该算法虽然很简单，但是非常耗时。&lt;/li>
&lt;li>&lt;strong>Double Check&lt;/strong> (D): 由于计算机在运算过程中可能会非常罕见地产生差错（这也是为什么人们需要ECC内存），因此为了确保素性判断正确，PrimeNet会让另外一台计算机重新计算Lucas-Lehmer，但是使用不同的初始参数，以验证计算的正确性。&lt;/li>
&lt;li>&lt;strong>Probable Prime Test&lt;/strong> (PRP): 这个测试是一种Fermat测试，但是使用了一种改进的验证方法。该算法会在测试过程中生成一个无法仿造的&lt;em>证明文件&lt;/em>，这个证明文件可以由另一台计算机很快验证，大大减少了运算量。（但是好像这个算法只能得到Probable Prime，最后的验证应该还是需要使用Lucas-Lehmer）&lt;/li>
&lt;li>&lt;strong>Proof Verification&lt;/strong> (CERT): 即验证PRP生成的证明的任务&lt;/li>
&lt;/ul>
&lt;p>除了这些任务之外，PrimeNet还衍生出了因数分解的任务，即尝试对质数验证失败的梅森数进行完整因数分解，在这个过程中也有可能发现非常大的质数，被称为co-factor。因数分解任务有如下两种：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Elliptic Curve Factorization&lt;/strong> (ECM): 利用椭圆曲线分解法进行因数分解，可以寻找一定范围以内的因数&lt;/li>
&lt;li>&lt;strong>Probable Prime Cofactor Test&lt;/strong> (PRP-CF): 对于梅森数除去找到的因数还剩下的因数进行素性测试，这个剩下的数通常仍然非常大，因为因数分解的方法通常只能找到几十位的因数，再大的因数实在太难计算了。
目前PrimeNet中因数分解的任务只分配给指数为四千万以下的梅森数。另外，以上这些任务只是大类，实际上PrimeNet中的任务划分更细一点，比如TF会分为普通TF和TF-LMH，后者优先选择TF进展比较小的指数进行分解。&lt;/li>
&lt;/ul>
&lt;p>PrimeNet中目前验证一个梅森数的完整流程大概如下：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">TF 2~2^63 -&amp;gt; TF 2^63 ~ 2^64 -&amp;gt; ... -&amp;gt; TF到2^78左右 -&amp;gt; PM1 -&amp;gt; PRP
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>将验证分为这么多步的原因主要还是为了减少计算量，TF和PM1在测试小因数的时候比较快，而Lucas-Lehmer虽然可以直接测试梅森数的素性，但是用TF和PM1粗筛可以大大减少计算量。这里TF计算的上限和PM1测试的范围都是PrimeNet根据找到因数的概率和计算耗时之间权衡之后算出来的。&lt;/p>
&lt;p>在早期PRP证明的算法还没有出现的时候（2020年以前），完整流程实际上是&lt;code>TF -&amp;gt; PM1 -&amp;gt; LL -&amp;gt; DC&lt;/code>，因此目前PrimeNet还有大量积攒的LL测试没有被双重验证果，因此目前发现的梅森素数M74207281、M77232917、M82589933的顺位还没有被确定。&lt;/p>
&lt;p>PrimeNet的整体进展可以在&lt;a class="link" href="https://www.mersenne.org/primenet/" target="_blank" rel="noopener"
>GIMPS官网的任务分配表中&lt;/a>中查看，这个表中展示了每一个范围中指数的状态。&lt;/p>
&lt;blockquote>
&lt;p>最右边的一大列&lt;code>Available&lt;/code>指的是还没有被认领的任务，右边第二列&lt;code>Assigned&lt;/code>指的是已被认领的任务，左边&lt;code>Composite&lt;/code>里面F指的是找到因数的梅森数、DC指的是验证过的LL/PRP测试为合数的梅森数，右边&lt;code>Status Unproven&lt;/code>中LL/PRP这一列指的是LL测试还没有被验证的指数，ERR指的是LL计算中出现错误的，而NO-LL则是完成了P-1测试后还没有经过LL/PRP测试的指数。&lt;/p>
&lt;/blockquote>
&lt;h3 id="客户端">客户端&lt;/h3>
&lt;p>在了解了计算任务的种类之后，接下来就是选择下载合适的客户端了。GIMPS除了官方的Prime95之外还有不少第三方实现的客户端。如果你想用CPU跑的话，直接使用官方的Prime95/mprime客户端即可；如果你的电脑有GPU，那么你可以选择GPU客户端，比较常用的有mfaktc (NVIDIA) / mfakto (AMD) / gpuowl (通用)。我主要使用的是gpuowl，因为它的代码最近仍然有更新，编译方便，并且支持P-1和PRP测试，而mfaktc和mfakto只能进行TF。不过gpuowl在windows上不太好编译。还有一些其他的GPU客户端，具体可以参考&lt;a class="link" href="https://www.mersenneforum.org/showpost.php?p=488289&amp;amp;postcount=1" target="_blank" rel="noopener"
>GIMPS论坛的这个介绍贴&lt;/a>。&lt;/p>
&lt;p>在使用客户端之前，首先可以在GIMPS官网上注册一个账户，这个账户即你在PrimeNet中的账户，在使用客户端的时候把用户名提供给客户端，这样可以让PrimeNet统计你的贡献。PrimeNet的贡献统计以GHz-days（GHD）为单位，每个任务的GHD数值通过一定的公式进行估算的，并不是直接统计你的CPU频率乘上你所花费的时间。据我的经验，如果你想拥有最高的GHD/day，使用CPU和GPU比较划算的都是TF任务。&lt;/p>
&lt;p>另外注册账户之后，你还可以选择一个Team加入，这样你的贡献值同样会被计算到Team中。目前我加入的GIMPSChina团队近年的贡献量排名第三，可喜可贺！&lt;/p>
&lt;p>&lt;img src="https://zyxin.xyz/blog/blog/2021-11/UtilizeYourComputationPower/primenet-ranking.png"
width="1212"
height="191"
loading="lazy"
alt="GIMPSChina排名"
class="gallery-image"
data-flex-grow="634"
data-flex-basis="1522px"
>&lt;/p>
&lt;p>关于客户端的使用上，各个客户端基本都是解压之后即可使用，或者编译后使用。使用Prime95客户端的话程序会自动下载新的计算任务，你只需要设置CPU和内存的占用情况即可。如果你要跑TF/DC/PRP任务，那么只需要设置线程数即可，如果要跑PM1，那么需要设置内存上限至少为1G，并且越高越好。内存的设置在菜单里Resource Limit一栏的Advanced项目里面。而用gpuowl的话需要手动申请任务，在&lt;a class="link" href="https://github.com/preda/gpuowl#usage" target="_blank" rel="noopener"
>Github主页上有说明具体的使用方法&lt;/a>。注意新的PrimeNet账户在一段时间（两三天）内是没法提交手动申请任务的结果的，需要管理员审核后才能提交，原因是之前有人恶意提交错误结果，具体情况参见&lt;a class="link" href="https://www.mersenneforum.org/showthread.php?t=24103&amp;amp;page=14" target="_blank" rel="noopener"
>这个GIMPS论坛的帖子&lt;/a>。&lt;/p>
&lt;h3 id="其他素数寻找项目">其他素数寻找项目&lt;/h3>
&lt;p>GIMPS是最早的互联网寻找素数的项目，后来受GIMPS的影响产生了很多新的项目，例如&lt;a class="link" href="https://srbase.my-firewall.org/sr5/" target="_blank" rel="noopener"
>SRBase&lt;/a>，&lt;a class="link" href="https://www.gpu72.com/" target="_blank" rel="noopener"
>GPU72&lt;/a>以及PrimeGrid。SRBase旨在寻找形如$k*b^n\pm 1$的素数，其中$k$为偶数，$b$为基；GPU72旨在利用GPU扩大梅森数的分解范围（提高到10亿，PrimeNet目前只搜索到1亿）；PrimeGrid则是一系列质数寻找项目的集合。这些项目之间通常会相互分享因数分解的结果。另外，在&lt;a class="link" href="https://primes.utm.edu/" target="_blank" rel="noopener"
>PrimePages&lt;/a>网站上有统计目前已知的各个形式的最大质数，在&lt;a class="link" href="https://www.mersenne.ca/" target="_blank" rel="noopener"
>Mersenne.ca&lt;/a>网站上有更详细的梅森数计算结果统计。&lt;/p>
&lt;h2 id="boinc">BOINC&lt;/h2>
&lt;p>除了GIMPS之外另一个更广为人知的志愿科学计算项目则是伯克利的Berkeley Open Infrastructure for Network Computing (BOINC)。这一项目给科学计算提供了统一的计算分发框架，里面有不少大型合作项目，涵盖数学、物理、天文、生物等多方面。&lt;/p>
&lt;h3 id="使用教程">使用教程&lt;/h3>
&lt;p>参与BOINC的计算就更加简单了，首先你需要安装一个BOINC客户端，在&lt;a class="link" href="https://boinc.berkeley.edu/download.php" target="_blank" rel="noopener"
>官网上可以下载到&lt;/a>。在安装完成之后，只需要在项目列表里面选择自己喜欢的项目即可参加。通常每个项目都有自己的网站，并且你需要在网站上注册账号，以便于该项目追踪你的贡献，这个步骤在你选择想参加的项目之后会提示你进行操作。参加项目之后，BOINC便会开始自动分配你可以参加的项目。&lt;/p>
&lt;p>BOINC客户端同样支持资源占用的限制，并且支持在电脑有操作的时候暂停计算任务，更加便于你利用电脑的空闲时间进行计算了。BOINC相关项目的贡献，除了每个网站自己的统计外，还可以在第三方网站（如&lt;a class="link" href="https://stats.free-dc.org/" target="_blank" rel="noopener"
>Free-DC&lt;/a>和&lt;a class="link" href="https://www.boincstats.com/stats/" target="_blank" rel="noopener"
>BOINCStats&lt;/a>）上查到。&lt;/p>
&lt;h3 id="gridcoin">GridCoin&lt;/h3>
&lt;p>另外BOINC还有一个很吸引人的地方是，有一款加密货币叫&lt;a class="link" href="https://gridcoin.us/" target="_blank" rel="noopener"
>GridCoin&lt;/a>是专门设计用来回报BOINC参与者的。因此如果你参加了GridCoin的计算池，那么你为科学事业贡献的算力实际上也是在挖矿！算力和电力的无用消耗是我不喜欢加密货币，尤其是比特币的最大原因，而设计在BOINC之上的GridCoin则完美解决了这个问题，并且GridCoin基于Proof of Stake，而不是现在比特币和以太坊使用的Proof of Work，更加降低了额外的计算资源消耗。因此如果你愿意参与BOINC的话，可以考虑同时利用GridCoin来回馈自己。&lt;/p>
&lt;p>在使用方法上，如果你是首次参加GridCoin，那么你需要利用GridCoin的计算池来进行挖矿，这个模式被称为Pool Crunching，除了安装BOINC之外你还需要在BOINC客户端中选择GridCoin支持的项目管理器（我选择的是grcpool），这样你的计算贡献会被归到GridCoin计算池的名下，而这个计算池会根据你的贡献分配GridCoin。当你有了GridCoin之后你也可以选择独立进行计算而不依赖于计算池，这个被称为Solo Crunching，这个情况下你的计算贡献也会直接被各个项目统计到。具体的使用方法还请参考&lt;a class="link" href="https://gridcoin.us/" target="_blank" rel="noopener"
>GridCoin官网&lt;/a>&lt;/p>
&lt;hr>
&lt;p>在了解这些的过程中，我还发现了一个聚集了国内志愿计算爱好者的论坛——&lt;a class="link" href="https://equn.com/forum/" target="_blank" rel="noopener"
>中国分布式计算论坛&lt;/a>，这里面有很多BOINC和GIMPS的贡献者，他们会交流项目参与方法、项目更新等。看到有这么多人愿意给科学事业贡献自己的算力我还是感到很开心的，如果感兴趣的话欢迎加入这些科学计算项目~&lt;/p></description></item><item><title>让你的手机变身Linux — Termux设置</title><link>https://zyxin.xyz/blog/2021-11/TermuxSetup/</link><pubDate>Fri, 19 Nov 2021 00:00:00 +0000</pubDate><guid>https://zyxin.xyz/blog/2021-11/TermuxSetup/</guid><description>&lt;p>Termux是一款在Android上运行的终端模拟器，其中内含了一个非常轻量的Linux环境，并且使用apt做包管理器。最新的Termux已经不在Play Store上更新了，安装需要去&lt;a class="link" href="https://github.com/termux/termux-app" target="_blank" rel="noopener"
>Github&lt;/a>或者&lt;a class="link" href="https://termux.com/" target="_blank" rel="noopener"
>官网&lt;/a>。旧版本的Termux在使用apt的时候可能会碰到问题。&lt;/p>
&lt;p>近来因为买了Surface Duo，在手机上稍微折腾了一下Termux，尝试是否能把手机变成Linux级别的生产力工具。结论当然是不可以，一方面性能不够，另一方面Termux上的包还是太少了，不过还是记录一下一些环境设置方法，供之后查阅。&lt;/p>
&lt;p>另外，Termux支持通过&lt;code>proot&lt;/code>包来安装完整的Linux系统，最有名的是&lt;a class="link" href="https://termuxarch.github.io/TermuxArch/" target="_blank" rel="noopener"
>TermuxArch&lt;/a>。在安装完完整系统之后，理论上你的手机就已经变成完整的Linux电脑了！不过由于我并不需要那么多功能，我没有走这一条路线。&lt;/p>
&lt;h2 id="ssh客户端">ssh客户端&lt;/h2>
&lt;p>在手机上使用ssh客户端还是非常实用的，这样可以随时随地监控各个电脑的情况，并且不怎么耗流量。在Termux里面安装ssh非常简单，直接&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">pkg install openssh &lt;span class="c1"># or apt install openssh, pkg=apt in Termux&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>如果你像我一样主要通过SSH Key连接各主机，那么你可能需要安装&lt;a class="link" href="https://github.com/termux/termux-api" target="_blank" rel="noopener"
>Termux:API&lt;/a>以便于从手机中拷入密钥到Termux中，还需要手动开一下ssh-agent服务。建议直接在&lt;code>.bashrc&lt;/code>（可能需要新建）中加入以下内容&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">&lt;span class="nb">eval&lt;/span> &lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="k">$(&lt;/span>ssh-agent -s&lt;span class="k">)&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># ssh-add your_key&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>然后如果你在服务器上有像我一样配置Powerline的话（可参考&lt;a class="link" href="https://zyxin.xyz/blog/2019-07/BeautifyTerminal/" >我之前的美化terminal的博客&lt;/a>），你可以安装&lt;a class="link" href="https://github.com/termux/termux-styling" target="_blank" rel="noopener"
>Termux:Styling&lt;/a>这个app，然后在Termux中就可以选择Nerd Font了，非常不错！&lt;/p>
&lt;h2 id="rust环境配置">Rust环境配置&lt;/h2>
&lt;p>Termux的仓库中直接有提供rust，因此可以直接&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">pkg install rustc-dev
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这个命令会顺带装上Clang编译器。&lt;/p>
&lt;h2 id="python环境配置">Python环境配置&lt;/h2>
&lt;p>我尝试的另一大内容就是在Termux里面搭建基本的Python环境。Termux只提供了Python的包，几乎没有提供其他任何包，因此需要手动安装。你可以直接选择安装&lt;a class="link" href="https://www.anaconda.com/products/individual#linux" target="_blank" rel="noopener"
>Anaconda&lt;/a>，但是目前由于兼容性的问题，Termux中无法运行很多给&lt;code>aarch64&lt;/code>架构编译的文件，这个问题在之后也许会被Termux解决。&lt;/p>
&lt;p>首先是安装python，直接&lt;code>pkg install python&lt;/code>即可。在我这次安装的时候，Python已经直接是3.10的版本了，很不错。然后用&lt;code>get-pip.py&lt;/code>脚本可以安装上&lt;code>pip&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">pkg install wget
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">wget bootstrap.pypa.io/get-pip.py
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">python get-pip.py
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>有了pip之后纯Python的包就可以直接装了，而用到Python扩展的包（如numpy）则需要编译器和对应的依赖项。编译器我在之前装Rust的时候顺便装上了，也可以直接通过&lt;code>pkg&lt;/code>安装Clang（Termux仓库里只有Clang没有GCC）。&lt;/p>
&lt;p>安装Numpy时如果系统里没有BLAS包，安装可以成功完成，但是会有警告，并且性能欠佳。这次我尝试给安装了一下OpenBLAS，过程还挺顺利的，命令如下&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">wget https://github.com/xianyi/OpenBLAS/releases/download/v0.3.18/OpenBLAS-0.3.18.tar.gz &lt;span class="c1"># choose your version&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">tar -xzf OpenBLAS-0.3.18.tar.gz
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">cd&lt;/span> OpenBLAS-0.3.18
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">pkg install perl binutils &lt;span class="c1"># install dependencies&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">make -j4
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">make &lt;span class="nv">PREFIX&lt;/span>&lt;span class="o">=&lt;/span>/data/data/com.termux/files/usr install
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>安装好OpenBLAS之后再&lt;code>pip install numpy&lt;/code>，这时Numpy会自动找到OpenBLAS。在有了Numpy之后，许多依赖于Numpy的包也很容易能装上了（如Cython、Pandas，但是Scipy装不了，因为Scipy需要Lapack和gfortran，这意味着需要把GCC的工具链导进来，这里我就懒得弄了。如果有需要的话一位Github老哥自己搭建了一个&lt;a class="link" href="https://github.com/its-pointless/gcc_termux" target="_blank" rel="noopener"
>apt仓库&lt;/a>，可以从那里安装）&lt;/p>
&lt;p>之后我还尝试了安装Jupyter Notebook和matploblib / plotly&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># install jupyter notebook&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">pkg install libzmq &lt;span class="c1"># dependency for jupyter notebook kernel&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">pip install notebook
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># install pillow, and then matploblib / plotly&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">pkg install libjpeg-turbo libtiff freetype libwebp tcl tk libraqm littlecms zstd
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nv">LDFLAGS&lt;/span>&lt;span class="o">=&lt;/span>-L/system/lib64 pip install pillow
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">pip install matplotlib plotly
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;hr>
&lt;p>值得一提的是就如前文所说，Termux好像无法正常运行通常给aarch64编译的包，有可能是因为没有glibc，或者其他依赖项。因此在Termux中尽量使用官方仓库提供的包，保证没有问题，如果要用其他未提供的包则很有可能需要重新用Clang编译。这也是我尝试安装Anaconda和.Net Core但是都失败了的原因。&lt;/p>
&lt;p>Termux好像还支持X11，因此你可以在手机上运行GUI程序！简直牛逼！不过我也没有需求，所以没有试。要实现这个功能需要安装X11服务器，可选的有XServer XSDL和Termux团队正在开发的&lt;a class="link" href="https://github.com/termux/termux-x11" target="_blank" rel="noopener"
>Termux:X11&lt;/a>。用XServer XSDL运行TermuxArch可以参考&lt;a class="link" href="https://medium.com/codex/how-to-turnyour-android-device-to-a-full-fledged-notebook-39561e115160" target="_blank" rel="noopener"
>这个教程&lt;/a>。&lt;/p>
&lt;p>最后虽然我把需要环境弄得差不多了，甚至成功在手机上运行了Jupyter Notebook并且试着画了几张图，但是最后我其实还是发现，Termux最好的归宿还是SSH客户端，毕竟手机的性能限制摆在那里。不过这些工具（尤其是Python）在有时候想随手做点或者算点什么东西的时候还是非常有用的。仅供参考~&lt;/p></description></item><item><title>折腾 KDE Neon 的配置</title><link>https://zyxin.xyz/blog/2019-07/ConfigureKdeNeon/</link><pubDate>Wed, 31 Jul 2019 00:00:00 +0000</pubDate><guid>https://zyxin.xyz/blog/2019-07/ConfigureKdeNeon/</guid><description>&lt;img src="https://zyxin.xyz/blog/2019-07/ConfigureKdeNeon/neon.png" alt="Featured image of post 折腾 KDE Neon 的配置" />&lt;p>最近我已经将KDE Neon作为主力系统之一了，Plasma桌面真的是太好用了！于是给家里的主机也装上了Neon，这篇文章就记录一下安装配置和美化的过程啦～&lt;/p>
&lt;p>&lt;img src="https://zyxin.xyz/blog/blog/2019-07/ConfigureKdeNeon/neon.png"
width="2560"
height="1080"
loading="lazy"
alt="Plasma桌面折腾结果～"
class="gallery-image"
data-flex-grow="237"
data-flex-basis="568px"
>&lt;/p>
&lt;h2 id="系统安装及boot设置">系统安装及Boot设置&lt;/h2>
&lt;h3 id="双系统安装">双系统安装&lt;/h3>
&lt;p>安装Neon还是非常简单的，直接从官网下载系统镜像，烧进U盘正常安装即可。不过由于我选择的是与Windows双系统安装，因此需要手动分区。这里要纠正一下之前[安装双系统博文中的分区方式](https://zyxin.xyz/blog/2018-09/LinuxDualSystem/。现在的Linux系统实际上只需要给根目录&lt;code>/&lt;/code>分区就可以了，&lt;code>/home&lt;/code>分区以前建议单独分区的原因是为了便于系统的更改，这样在修改系统分区之后（如重装系统）还能保留&lt;code>/home&lt;/code>底下的文件，但其实现在很多系统已经能做到重装并保留&lt;code>/home&lt;/code>分区了，这时对于我这小硬盘的笔记本来说反而导致空间利用不灵活。而交换分区&lt;code>/swap&lt;/code>也是没有必要的，交换分区的存在类似于Windows下的虚拟内存，用硬盘的一部分来虚拟内存，避免内存不足的情况。新Linux可以利用交换文件完成类似功能，因此不必专门给&lt;code>/swap&lt;/code>分区。（不过我猜专门给它分个区可能能提高性能？）。最后最关键的是不要给&lt;code>/boot&lt;/code>分区了,&lt;code>/boot&lt;/code>分区是为了保证boot文件区不被占满，以致无法正常启动。利用EFI方式启动的系统只需要有&lt;code>efi&lt;/code>分区即可，而且多个系统可以利用同一个EFI分区。因此只需告诉安装器使用EFI分区作为启动分区，关于EFI的详细信息请看后文~&lt;/p>
&lt;blockquote>
&lt;p>分区的时候还看到了之前的系统里有标记为&lt;code>msr&lt;/code>的分区，是Windows的预留分区，好像具体没啥用。这里贴&lt;a class="link" href="http://bbs.wuyou.net/forum.php?mod=viewthread&amp;amp;tid=374959" target="_blank" rel="noopener"
>一篇考据文章&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h3 id="refind设置">rEFind设置&lt;/h3>
&lt;p>安装完系统后我还准备安装rEFind来替代默认的bootloader——GRUB(GRUB实在是太丑了&amp;hellip;)。由于Windows10禁掉了启动其他系统的入口，因此之前只能用GRUB。rEFind是一个更加强大的启动器，并且可自定义的部分也多～rEFind是基于UEFI的启动器，相比GRUB能支持更多的功能，甚至可以在启动阶段就加载一些驱动，这就使得rEFind可以有高清的界面哈哈哈～关于UEFI与传统BIOS的区别可以参考&lt;a class="link" href="https://wiki.manjaro.org/index.php?title=Some_basics_of_MBR_v/s_GPT_and_BIOS_v/s_UEFI" target="_blank" rel="noopener"
>Manjaro论坛的这篇帖子&lt;/a>和&lt;a class="link" href="https://www.zhihu.com/question/36313402/answer/66947818" target="_blank" rel="noopener"
>知乎的这篇帖子&lt;/a>。UEFI和BIOS都是主板ROM程序启动后调用的bootloader类型，当bootloader通过UEFI或者BIOS过程加载之后就会启动系统内核。而UEFI相比BIOS可以支持更大的bootloader和并行启动，是现在大部分系统采用的启动方式～&lt;/p>
&lt;p>rEFind在Ubuntu下安装非常方便～直接用&lt;code>apt&lt;/code>安装即可。安装完重启就会发现默认进入的已经是rEFind界面了～不过默认的界面主题非常丑，也有很多多余的启动项，因此还需要稍微设置一下～设置教程网上有很多了，主题在官网和搜索引擎也都可以搜到，这里就不赘述。我的设置文件&lt;a class="link" href="https://github.com/cmpute/dotfiles/blob/master/refind/user.conf" target="_blank" rel="noopener"
>可以在Github找到&lt;/a>～我保留了GRUB的chainload入口，避免rEFind崩了进不去系统，然后另外添加了一个直接启动Linux内核的入口。最后界面效果如下，还是很赏心悦目的～&lt;/p>
&lt;p>{% asset_img refind.jpg rEFInd界面照片 %}&lt;/p>
&lt;p>安装完成以后就接着&lt;a class="link" href="https://zyxin.xyz/blog/2018-09/LinuxDualSystem/" >参考之前的文章&lt;/a>继续设置就可以了。其中最必要的两个操作是把系统时间调成&lt;code>local-rtc&lt;/code>避免与Windows冲突，以及把Plasma环境中鼠标单击的行为从打开改为选择。。。&lt;/p>
&lt;h3 id="输入法安装">输入法安装&lt;/h3>
&lt;p>Neon安装完后默认是没有输入法的，不过反正中文输入法都是要安装&lt;a class="link" href="https://wiki.archlinux.org/index.php/fcitx" target="_blank" rel="noopener"
>fcitx&lt;/a>的，还避免了使用ibus的冲突～fcitx的安装&lt;a class="link" href="https://blog.ctang.me/the-first-story-on-medium-8a132a1b62fe" target="_blank" rel="noopener"
>参考这篇文章&lt;/a>即可，其中&lt;code>fcitx-qt-impanel&lt;/code>这个包可以让fcitx的状态显示在任务栏里～最近好像fcitx在开发新版本(&lt;a class="link" href="https://a-wing.top/linux/2018/08/14/fcitx5.html" target="_blank" rel="noopener"
>fcitx5&lt;/a>)，不过目前还只有Arch linux有包可以直接用，因此也就没折腾了。&lt;/p>
&lt;p>安装完成之后还需要让fcitx框架跟随系统在后台启动，在Ubuntu底下修改的文件是&lt;code>.xprofile&lt;/code>，而KDE桌面环境不会加载&lt;code>.xprofile&lt;/code>，而是加载&lt;code>.xsessionrc&lt;/code>，修改方式参见&lt;a class="link" href="https://wiki.archlinux.org/index.php/fcitx#Set_environment_variables_for_IM_modules" target="_blank" rel="noopener"
>Arch Wiki&lt;/a>，最后好像还需要加&lt;code>fcitx &amp;amp;&lt;/code>来确保启动= =&lt;/p>
&lt;blockquote>
&lt;ul>
&lt;li>折腾这些玩意的过程中发现&lt;a class="link" href="https://wiki.archlinux.org/index.php" target="_blank" rel="noopener"
>Arch Wiki&lt;/a>真是个好东西啊～KDE桌面的大部分问题都可以搜到解答～&lt;/li>
&lt;li>&lt;code>.xinitrc&lt;/code>, &lt;code>.xprofile&lt;/code>，&lt;code>.xsession&lt;/code>这些设置文件我真的是被搞蒙了。。&lt;a class="link" href="https://www.reddit.com/r/linux/comments/1p6orz/bashrc_bash_profile_inputrc_profile_xprofile/" target="_blank" rel="noopener"
>这里有一篇帖子&lt;/a>和&lt;a class="link" href="https://unix.stackexchange.com/questions/281858/difference-between-xinitrc-xsession-and-xsessionrc/281923#281923" target="_blank" rel="noopener"
>一篇回答&lt;/a>梳理了他们的关系，可供参考～&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h3 id="rclone配置">rclone配置&lt;/h3>
&lt;p>另一个必装的好东西是rclone，之前在&lt;a class="link" href="https://zyxin.xyz/blog/2019-04/LinuxRemoteSetup/" >远程桌面设置的文章&lt;/a>中有提到。由于KDE内置的GoogleDrive和OneDrive连接不太好使，还是用rclone来访问网盘吧= =。在设置好rclone之后可以通过自定义服务的方式让rclone在系统启动时自动挂载网盘到指定路径，然后在Dolphin（KDE的文件管理器）里面将这两个位置添加到左侧目录就可以啦～这样就可以直接从文件管理器访问了～具体的配置文件可以参考我的Github。&lt;/p>
&lt;blockquote>
&lt;ul>
&lt;li>如果自定义服务添加到的位置是系统服务位置，那么可能会碰到权限问题，&lt;a class="link" href="https://forum.rclone.org/t/rclone-gdrive-not-mounting-permissions-or-fuse-issue/8067/2" target="_blank" rel="noopener"
>这里有解决方法&lt;/a>&lt;/li>
&lt;li>关于systemd的服务设置可以&lt;a class="link" href="https://wiki.archlinux.org/index.php/Systemd/User" target="_blank" rel="noopener"
>参考Arch Wiki&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="主题设置美化">主题设置美化&lt;/h2>
&lt;h3 id="plasma主题设置">Plasma主题设置&lt;/h3>
&lt;p>KDE Plasma最大的优点就是流畅以及好看！不折腾一下主题真的是对不起这么好的环境了～我大概主要进行了以下修改&lt;/p>
&lt;ul>
&lt;li>风格选择&lt;code>Breeze Dark&lt;/code>， 透明度设置为70%左右&lt;/li>
&lt;li>图标使用&lt;code>Papirus Dark&lt;/code>&lt;/li>
&lt;li>使用透明桌面主题&lt;a class="link" href="https://store.kde.org/p/1170816/" target="_blank" rel="noopener"
>&lt;code>Breeze Transparent Dark&lt;/code>&lt;/a>&lt;/li>
&lt;li>Firefox浏览器去掉titlebar，主题设为Dark&lt;/li>
&lt;li>添加全局菜单添加到底部
&lt;blockquote>
&lt;p>注意默认的Firefox去掉titlebar的话&lt;a class="link" href="https://www.reddit.com/r/kde/comments/bn2klu/firefox_csd_bug_with_kde_global_menu_plasmoid/" target="_blank" rel="noopener"
>对全局菜单的Plasmoid支持有问题&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>fcitx主题选择Dark&lt;/li>
&lt;li>在桌面特效中选择喜欢的窗口动画，调节窗口透明度～&lt;/li>
&lt;/ul>
&lt;p>剩下的换壁纸、配色主题什么的都来一遍就可以了～最后的桌面效果见标题图，还是很顺眼的～&lt;/p>
&lt;h3 id="其他小工具">其他小工具&lt;/h3>
&lt;h4 id="窗口附着缩放">窗口附着缩放&lt;/h4>
&lt;p>这个KWin脚本名叫Sticky Window Snapping，真的是神器！可以让附着在一块的窗口同时进行尺寸调整！这个功能相当于Windows分屏功能的升级版，这酸爽谁用谁知道啊！～下载地址&lt;a class="link" href="https://store.kde.org/p/1112552" target="_blank" rel="noopener"
>见KDE商城&lt;/a>，使用效果在官网有动图可以参考～还&lt;a class="link" href="https://store.kde.org/p/1112554/" target="_blank" rel="noopener"
>有个类似的脚本&lt;/a>可以做到让窗口严格按照网格排列，不过相比之下就显然鸡肋很多了。&lt;/p>
&lt;blockquote>
&lt;p>这些功能的Windows替代品可以&lt;a class="link" href="https://zhuanlan.zhihu.com/p/33722847" target="_blank" rel="noopener"
>参见少数派的文章&lt;/a>，不过貌似没有免费的软件可以做到Tilting&lt;/p>
&lt;/blockquote>
&lt;h4 id="redshift红移">Redshift（红移）&lt;/h4>
&lt;p>红移是Linux底下提供“护眼模式”的软件，有点类似f.lux，这个对我们这个天天盯电脑的还是很有用啦～安装直接&lt;code>apt install redshift plasma-applet-redshift-control&lt;/code>即可，第二个软件是Redshift的Plasma插件，可以在任务栏通过它来调节红移，非常方便～安装完后应该就可以通过Plasma挂件来设置红移了，如果不能自动识别地理位置的话&lt;a class="link" href="https://wiki.archlinux.org/index.php/Redshift#Automatic_location_based_on_GPS" target="_blank" rel="noopener"
>参考Arch Wiki中描述的geoclue工具&lt;/a>&lt;/p>
&lt;blockquote>
&lt;p>其他还有一些KDE下非常好用的软件，也一并列在这里了～以后用多了再专门开个文章～&lt;/p>
&lt;ul>
&lt;li>Kdenlive / Audacity：免费的视频/音频剪辑软件，基本够用了～&lt;/li>
&lt;li>Meld：文件比较器&lt;/li>
&lt;li>Remmina / KRDC：远程桌面的客户端，后者是KDE自家的，感觉比Remmina还是差点&lt;/li>
&lt;li>VLC：视频播放器，可以部分替代PotPlayer&lt;/li>
&lt;li>Peek / Kazam：录屏软件&lt;/li>
&lt;li>Flameshot：截屏软件&lt;/li>
&lt;li>Gimp：图片编辑软件，堪比Photoshop&lt;/li>
&lt;li>Krfb / Xrdp：远程桌面的服务器&lt;/li>
&lt;li>DeaDBeeF：音乐播放器，对cue和utf的支持非常好，可以部分替代fb2k&lt;/li>
&lt;li>KDE Partition Manager：KDE版GParted，功能差不多而且界面美观～&lt;/li>
&lt;li>fzf / ripgrep：模糊搜索工具&lt;/li>
&lt;li>Golden Dict：强大的词典框架&lt;/li>
&lt;li>KGet / aria2：下载器&lt;/li>
&lt;li>youtube-dl：视频下载器（Python）&lt;/li>
&lt;li>&lt;a class="link" href="http://wps-community.org/" target="_blank" rel="noopener"
>WPS&lt;/a> / OnlyOffice：办公套装&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;!-- Reference Software List -->
&lt;!-- https://alim0x.gitbooks.io/awesome-linux-software-zh_cn/content -->
&lt;!-- KDE 全家桶 -->
&lt;!-- Deepin 全家桶 -->
&lt;!-- KDE snap全家桶 --></description></item><item><title>终端（Terminal）美化与扩展</title><link>https://zyxin.xyz/blog/2019-07/BeautifyTerminal/</link><pubDate>Sat, 13 Jul 2019 00:00:00 +0000</pubDate><guid>https://zyxin.xyz/blog/2019-07/BeautifyTerminal/</guid><description>&lt;p>最近由于工作需要，和终端命令行打交道的时间越来越多了，最近便查了一下美化命令行的方法，记录在此以供查阅～另外还推荐一个网站&lt;a class="link" href="https://terminalsare.sexy/" target="_blank" rel="noopener"
>terminalsare.sexy&lt;/a>，提供了很多与terminal美化相关的软件。&lt;/p>
&lt;h2 id="命令提示符prompt美化">命令提示符（Prompt）美化&lt;/h2>
&lt;p>相信不少朋友也见过如下图所示美化过的命令提示符
&lt;img src="https://raw.github.com/b-ryan/powerline-shell/master/bash-powerline-screenshot.png"
loading="lazy"
alt="powerline-shell"
>这个效果的实现方式是通过安装名为&lt;strong>Powerline&lt;/strong>的扩展程序。Powerline是一套可拓展的状态栏提示工具，可以给各种Terminal Emulator和Vim等工具增加状态栏的提示，并且十分好用～&lt;/p>
&lt;p>Powerline有很多版本，有直接通过shell配置脚本实现的，也有通过独立程序进行显示的（如下列所示）。我选择的是原版powerline，安装方便，适用软件多，并且可以自行扩展。&lt;/p>
&lt;ul>
&lt;li>&lt;a class="link" href="https://github.com/powerline/powerline" target="_blank" rel="noopener"
>&lt;strong>powerline&lt;/strong>&lt;/a>: 这应该是最初的也是最全的powerline，基于Python&lt;/li>
&lt;li>&lt;a class="link" href="https://github.com/b-ryan/powerline-shell" target="_blank" rel="noopener"
>&lt;strong>powerline-shell&lt;/strong>&lt;/a>: 这是针对美化shell的版本，同样基于Python，配置比上面的简单&lt;/li>
&lt;li>&lt;a class="link" href="https://github.com/justjanne/powerline-go" target="_blank" rel="noopener"
>&lt;strong>powerline-go&lt;/strong>&lt;/a>: 用go语言写的版本，运行更快&lt;/li>
&lt;li>&lt;a class="link" href="https://github.com/riobard/bash-powerline" target="_blank" rel="noopener"
>&lt;strong>bash-powerline&lt;/strong>&lt;/a>: 用bash编写的用于bash的powerline&lt;/li>
&lt;/ul>
&lt;p>原版powerline的安装非常简单，用&lt;code>pip&lt;/code>安装即可：&lt;code>(sudo) pip install powerline-status&lt;/code>。安装完以后&lt;a class="link" href="https://powerline.readthedocs.io/en/latest/usage.html#plugins" target="_blank" rel="noopener"
>根据官网的教程&lt;/a>更改对应的配置文件即可～我只对bash进行了美化，因为bash是最常用的shell。使用bash的话建议&lt;a class="link" href="https://powerline.readthedocs.io/en/latest/usage/shell-prompts.html#bash-prompt" target="_blank" rel="noopener"
>按照教程里的指示&lt;/a>，在命令行配置文件中开启daemon来提高加载速度。另外一个小技巧是，由于Python2的启动速度比Python3快，因此推荐用Python2来安装powerline。&lt;/p>
&lt;p>安装好powerline后下一步是自定义，这部分内容在powerline的文档里也有描述，不过它的文档写的不太好。。参考powerline安装目录下的配置文件（如果用系统pip安装的话位置是在&lt;code>/usr/local/lib/python2.7/dist-packages/powerline/config_files&lt;/code>下），在用户配置目录下&lt;code>~/.config/powerline&lt;/code>新建对应的配置文件，然后修改相应的条目即可自定义配置了～比较实用的一项修改是&lt;a class="link" href="https://github.com/powerline/powerline/issues/186#issuecomment-247810572" target="_blank" rel="noopener"
>将shell的默认theme改为&lt;code>default_leftonly&lt;/code>&lt;/a>，不增加这个改动的话不会有git状态的显示。。（并不知道是什么原理）&lt;/p>
&lt;p>如果使用原生Ubuntu或者VSCode内置terminal的话还可能会遇到提示符乱码的原因，这是由于powerline使用了非常规的符号，因此需要安装额外的字体。一般会选择安装&lt;a class="link" href="http://nerdfonts.com/" target="_blank" rel="noopener"
>NerdFont&lt;/a>，这是一系列打上符号补丁的字体，其中我个人比较喜欢的字体是&lt;code>DejaVu Mono Nerd&lt;/code>～这些字体还可以在&lt;a class="link" href="https://app.programmingfonts.org/" target="_blank" rel="noopener"
>programmingfonts&lt;/a>在线预览，挑选喜欢的后将Terminal默认字体更改即可。（注：ubuntu下的查看字体列表命令是&lt;code>fc-list&lt;/code>）&lt;/p>
&lt;h2 id="tmux安装及美化">tmux安装及美化&lt;/h2>
&lt;p>tmux是非常著名的Terminal Multiplexer，也就是终端多开程序。很多命令行模拟器其实已经支持多标签页了，如gnome terminal和Konsole，多开的功能其实也已经得到满足了。（顺带一题，ubuntu下新开terminal窗口的默认快捷键是&lt;kbd>Ctrl&lt;/kbd>+&lt;kbd>Alt&lt;/kbd>+T，新开标签页的默认快捷键是&lt;kbd>Ctrl&lt;/kbd>+&lt;kbd>Shift&lt;/kbd>+T。）。但还需要tmux是因为需要tmux的session管理功能，这个对远程访问的时候非常有用。有时希望在服务器远端跑一个训练，开上以后就不想管了，那这时如果使用ssh的话就得一直把远程的session开着，或者运行命令后移到后台，但这时停止程序就蛋疼了。另外如果想远程开几个terminal的话也很麻烦，要开好几个ssh的窗口。有了tmux就简单了，你可以用tmux多开然后一次性detach多个session，之后再attach回来进行管理，tmux支持多个程序显示在同一个terminal里，也就不用开很多个ssh了！总之用上tmux后感觉还是很爽的，只不过tmux有一定的学习成本。&lt;/p>
&lt;p>tmux安装也很简单，ubuntu下的话直接使用&lt;code>apt&lt;/code>安装即可。另外还可以安装&lt;a class="link" href="https://github.com/tmuxinator/tmuxinator" target="_blank" rel="noopener"
>tmuxinator&lt;/a>来简化tmux的一些流程。上面用到的powershell也是支持tmux的，可以美化tmux的状态栏。具体安装方法&lt;a class="link" href="https://powerline.readthedocs.io/en/latest/usage/other.html#tmux-statusline" target="_blank" rel="noopener"
>参见powerline文档&lt;/a>。另外tmux的操作方法可以去搜cheatsheet～这也有&lt;a class="link" href="https://hackernoon.com/a-gentle-introduction-to-tmux-8d784c404340" target="_blank" rel="noopener"
>一篇博文介绍了tmux的基本操作&lt;/a>，可以参考～&lt;/p>
&lt;h2 id="历史记录搜索">历史记录搜索&lt;/h2>
&lt;p>著名的fish有个颇受称赞的功能是历史命令自动补全（见下图），在zsh里面也有对应的插件可以实现这个功能（&lt;a class="link" href="https://github.com/zsh-users/zsh-autosuggestions" target="_blank" rel="noopener"
>zsh-autosuggestions&lt;/a>）。但是bash由于比较辣鸡，无法支持这样的功能，因此只能另寻它法了。。
&lt;img src="https://spin.atomicobject.com/wp-content/uploads/20170512131543/fish-history.gif"
loading="lazy"
alt="fish autosuggestion"
>&lt;/p>
&lt;p>比较有名的方法是使用一个模糊搜索的软件&lt;a class="link" href="https://github.com/junegunn/fzf" target="_blank" rel="noopener"
>&lt;strong>fzf&lt;/strong>&lt;/a>。这个软件提供文件、程序和命令历史的搜索，有点类似于windows下的Listary。如果配置在shell中的话可以在按下快捷键后出现一个搜索框，搜索历史命令。这个虽然没有fish的自动补全好用，但是也非常方便了～安装fzf推荐通过&lt;a class="link" href="https://github.com/junegunn/fzf#using-git" target="_blank" rel="noopener"
>文档中的方法使用git安装&lt;/a>。安装过程中会提示你是否绑定终端快捷键，选择yes后在终端按下&lt;kbd>Ctrl&lt;/kbd>+&lt;kbd>R&lt;/kbd>就可以弹出搜索框了，非常方便～如果直接运行fzf命令的话就会进入完整的搜索界面，可以搜索文件，具体的使用方法还是参考官方文档了～&lt;/p>
&lt;h2 id="powershell美化">Powershell美化&lt;/h2>
&lt;p>由于Powershell不是传统的sh体系，因此目前powerline还没有官方支持powershell。这里先mark几个博客，设置好了再更新上来～&lt;/p>
&lt;blockquote>
&lt;ul>
&lt;li>&lt;a class="link" href="https://github.com/JanDeDobbeleer/oh-my-posh" target="_blank" rel="noopener"
>https://github.com/JanDeDobbeleer/oh-my-posh&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://blog.walterlv.com/post/beautify-powershell-like-zsh.html#%E5%AE%89%E8%A3%85-oh-my-posh" target="_blank" rel="noopener"
>https://blog.walterlv.com/post/beautify-powershell-like-zsh.html#%E5%AE%89%E8%A3%85-oh-my-posh&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://gist.github.com/jchandra74/5b0c94385175c7a8d1cb39bc5157365e" target="_blank" rel="noopener"
>https://gist.github.com/jchandra74/5b0c94385175c7a8d1cb39bc5157365e&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://dev.to/myleftshoe/comment/8b58" target="_blank" rel="noopener"
>https://dev.to/myleftshoe/comment/8b58&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://www.reddit.com/r/archlinux/comments/45lkyj/is_new_always_better_urxvt_vs_xterm_tmux_vs/" target="_blank" rel="noopener"
>https://www.reddit.com/r/archlinux/comments/45lkyj/is_new_always_better_urxvt_vs_xterm_tmux_vs/&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote></description></item><item><title>转投Linux发行版</title><link>https://zyxin.xyz/blog/2019-04/LinuxDistroSelection/</link><pubDate>Fri, 26 Apr 2019 15:22:02 +0000</pubDate><guid>https://zyxin.xyz/blog/2019-04/LinuxDistroSelection/</guid><description>&lt;p>由于最近工作一直在使用ROS，因此也一直在用Ubuntu。之前为了稳定性使用的是Ubuntu 16.04 LTS，而这个版本默认的桌面环境是Unity，实在是不好使，它也颇为人诟病。后来尝试了Ubuntu 18.04 LTS安装ROS Melodic，发现ROS也挺稳定的，因此18.04也用了一段时间，但是最后还是觉得不太爽，于是最终还是决定好好体验一下各种Linux选一个自己顺手的。&lt;/p>
&lt;blockquote>
&lt;p>这篇博客里不会贴系统的截图，因为这些在网上都可以找到，而且桌面的好看与否很大程度上取决于个人的喜好和配置结果。最好的比较方法还是自己装一个系统尝试一下&lt;/p>
&lt;/blockquote>
&lt;p>至于如何尝试linux，我在Windows中使用的是Hyper-V。可以非常方便地安装各种镜像，动态分配资源，最方便的是vhdx硬盘格式可以直接mount到宿主机里。Hyper-V使用一些性能较差的Linux桌面环境时会比较卡，这个时候可以&lt;a class="link" href="https://docs.microsoft.com/en-us/windows-server/remote/remote-desktop-services/rds-remotefx-vgpu" target="_blank" rel="noopener"
>开启RemoteFX GPU（参考官方说明）&lt;/a>。注意在Win10 1809之后，Hyper-V管理器界面不提供RemoteFX的开关了，需要用Powershell命令手动开启。&lt;/p>
&lt;h2 id="linux-distro">Linux Distro&lt;/h2>
&lt;p>所谓的Linux发行版，对应的是一个专有的英文单词distro。个人理解，Linux Distro就是一套Linux Kernel加上外围一些必要的软件包。之前我一直不理解发行版的意思，直到学会了Python使用上Anaconda之后，才知道发行版指的就是核心程序+预装的全家桶，这个全家桶通常包含包管理器（Package manager，简称PM。如Ubuntu的apt、Anaconda的conda）、内置软件（如Linux桌面环境、Anaconda预装的Scipy）以及一套系统逻辑。&lt;/p>
&lt;p>Linux发行版中很重要的一点便是系统的PM，这个管理器还决定了系统的更新逻辑。而不同发行版之间最大的区别，在我看来就是PM（以及软件仓库repository），因此PM的特性与相性最终会决定我是否选择这套发行版。&lt;/p>
&lt;p>常见的桌面Linux发行版有如下这些，我可以大概描述一下他们的特点（以PM为线索）：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>apt&lt;/strong>: Debian、Ubuntu系
&lt;ul>
&lt;li>依赖树严格，能保证软件之间正确的依赖关系&lt;/li>
&lt;li>Debian和Ubuntu的软件库数量庞大，但是确实由于保守的包更新政策，它们的包比较老&lt;/li>
&lt;li>apt的命令行使用非常直观&lt;/li>
&lt;li>在国内，默认的仓库源下载很慢，但是国内有很多开源镜像可以使用&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>pacman&lt;/strong>: Arch
&lt;ul>
&lt;li>滚动更新是Arch最大的特点&lt;/li>
&lt;li>pacman没有严格的依赖树，而是类似于快照的概念，更新软件时整个软件池都会进行变动（个人理解）&lt;/li>
&lt;li>pacman命令行参数是字母表，不便于记忆&lt;/li>
&lt;li>Arch的官方软件仓库中软件较少，但是Arch有庞大的AUR体系，因此能够尝试到很多小软件和新版本，不过也要承担小白鼠的风险&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>yum/dnf&lt;/strong>: Fedora、CentOS、Redhat等
&lt;ul>
&lt;li>使用方法和apt相似&lt;/li>
&lt;li>软件仓库中的数量没有Debian和Arch多&lt;/li>
&lt;li>包管理方便，中规中据，而且下载速度不慢&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>zypper&lt;/strong>: OpenSUSE
&lt;ul>
&lt;li>由于OpenSUSE是真的比较小众，因此我也没有去尝试，就不妄自评论了&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>emerge&lt;/strong>: Gentoo
&lt;ul>
&lt;li>同上，没尝试过
严格来说，上面的这些都是包分发器，而安装软件的是包安装器（dpkg,rpm等），不过前者才是我们最经常打交道的。关于这些PM以及其软件管理哲学的分析，可以&lt;a class="link" href="https://www.zhihu.com/question/40297380" target="_blank" rel="noopener"
>参见这个知乎问题&lt;/a>。而关于这些包管理器的一篇介绍可以&lt;a class="link" href="https://linux.cn/article-9931-1.html" target="_blank" rel="noopener"
>参见这篇博文&lt;/a>。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>Arch Linux的wiki上也有一篇&lt;a class="link" href="https://wiki.archlinux.org/index.php/Arch_compared_to_other_distributions" target="_blank" rel="noopener"
>关于发行版之间的对比&lt;/a>，这里我要吹一下Arch的wiki真的良心，还有中文版！
&lt;a class="link" href="https://distrowatch.com/" target="_blank" rel="noopener"
>DistroWatch&lt;/a>是一个收集了大量Linux distro的网站，可以在上面看一下流行度排名和一些评测
Linux各发行版的演化历史可以参见&lt;a class="link" href="https://commons.wikimedia.org/wiki/File:Linux_Distribution_Timeline.svg" target="_blank" rel="noopener"
>Wiki的历史图&lt;/a>或者&lt;a class="link" href="https://distrowatch.com/dwres.php?resource=family-tree" target="_blank" rel="noopener"
>DistroWatch的图表&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;h2 id="桌面环境">桌面环境&lt;/h2>
&lt;p>桌面环境是最终选择哪一个发行版的决定者。选择Ubuntu、Arch等只能给你决定好大方向，而最后在众多系统中作出选择的标准之一便是桌面环境。常见的桌面环境有Gnome、KDE Plasma、XFCE、LXQt等。现在众多的发行版的主要区别其实也就是PM和桌面环境的区别：&lt;/p>
&lt;ul>
&lt;li>Ubuntu 16.04: Ubuntu + Unity&lt;/li>
&lt;li>Ubuntu 18.04: Ubuntu + Gnome&lt;/li>
&lt;li>KUbuntu: Ubuntu + KDE&lt;/li>
&lt;li>XUbuntu: Ubuntu + XFCE&lt;/li>
&lt;li>MX Linux: Debian + XFCE&lt;/li>
&lt;li>Linux Mint: Ubuntu + Cinammon/Gnome&lt;/li>
&lt;li>Manjaro: Arch + KDE&lt;/li>
&lt;li>Deepin: Debian + Deepin&lt;/li>
&lt;li>&amp;hellip;&lt;/li>
&lt;/ul>
&lt;p>而这些桌面环境的特点，个人感觉如下：&lt;/p>
&lt;ul>
&lt;li>Gnome(w/ gdm): 基于GTK开发，默认界面比较好看，但是灵活程度不够。虽然有Gnome Tweak，但是插件很少&lt;/li>
&lt;li>KDE Plasma(w/ sddm): 基于QT开发，非常灵活，而且Plasma5默认就非常好看！占用资源也比Gnome小。&lt;/li>
&lt;li>Unity(w/ lightdm): 别说了，换吧&lt;/li>
&lt;li>Xfce: 听人说很不错，但是我认为比较丑&lt;/li>
&lt;li>LXQt(w/ sddm): 适合低配环境，也不太好看&lt;/li>
&lt;/ul>
&lt;h2 id="个人选择">个人选择&lt;/h2>
&lt;p>&lt;strong>Arch&lt;/strong>?: 在我了解Linux distro的过程中，在各种论坛、知乎问题上都有人安利Arch linux。Arch虽好，而且可以体验更新的快感，但是我本身没有太多的时间去折腾系统，或者追寻潮流，因此还是更倾向于Debian体系。同时由于我有使用ROS的需求，因此Ubuntu还是我的第一选择。&lt;/p>
&lt;p>&lt;strong>商业主导 or 社区主导&lt;/strong>: 有人说Ubuntu由于是Canonical家的产品，会有商业倾向，服从公司利益。这个情况确实存在，但是就体验上来说和Arch、Fedora等等社区主导的系统并没有太多区别，因此这个并不会是决定我选择的因素。&lt;/p>
&lt;p>&lt;strong>Gnome or KDE&lt;/strong>: 相比于GTK，我更喜欢Qt这套框架。另外KDE也有别人上传的很多插件和桌面（在KDE store上)，非常棒，因此我最后选择的是KDE～&lt;/p>
&lt;p>综上所述，我最后决定使用KDE Neon作为平常使用的发行版，双系统安装Ubuntu 18.04作为开发系统。之后会写一篇博客来介绍KDE的折腾记录～&lt;/p></description></item><item><title>给Linux（Ubuntu 16.04/18.04）配置远程访问环境</title><link>https://zyxin.xyz/blog/2019-04/LinuxRemoteSetup/</link><pubDate>Tue, 02 Apr 2019 20:47:07 +0000</pubDate><guid>https://zyxin.xyz/blog/2019-04/LinuxRemoteSetup/</guid><description>&lt;p>年后给实验室装了一台小服务器，安装了Ubuntu系统，这篇博客记录一下给Ubuntu配置远程访问的设置过程。&lt;/p>
&lt;blockquote>
&lt;p>虽然服务器是一台GPU服务器，但是出于简便考虑没有在服务器上安装虚拟化环境，有需要安装LXD或者Docker的朋友可以参考这几篇博客：&lt;a class="link" href="https://blog.csdn.net/weixin_42749767/article/details/83720831" target="_blank" rel="noopener"
>实验室GPU服务器共享方案&lt;/a>、&lt;a class="link" href="https://feelncut.com/2018/05/03/145.html" target="_blank" rel="noopener"
>搭建多人共用的GPU服务器&lt;/a>、&lt;a class="link" href="https://zhuanlan.zhihu.com/p/25710517" target="_blank" rel="noopener"
>为实验室建立公用GPU服务器&lt;/a>、&lt;a class="link" href="https://shenxiaohai.me/2018/12/03/gpu-server-lab/" target="_blank" rel="noopener"
>搭建实验室公共GPU服务器&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;h2 id="ssh设置">SSH设置&lt;/h2>
&lt;p>远程连接最方便并且最稳定的就是SSH了，安装好SSH之后就基本可以远程操作服务器。SSH的安装非常简单，Ubuntu下通过apt安装即可：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">sudo apt install openssh-server
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>安装完重启后，SSH服务就会自动运行了。客户端方面，Ubuntu默认提供SSH支持，而Windows在1809之后也内置了OpenSSH，在系统附加功能中打开开关后，通过cmd即可调用。如果系统版本较老则可以使用XShell。&lt;/p>
&lt;h3 id="sftp设置---利用rclone">SFTP设置 - 利用rclone&lt;/h3>
&lt;p>上面安装命令会顺带安装上SFTP客户端。SFTP可以看作加密的FTP协议，可以用来远程访问服务器的文件。SFTP现在已经受到广泛的支持，例如Android上的Solid Explorer就内置了SFTP访问功能。&lt;/p>
&lt;p>这里介绍一个可以把远程文件挂载到本地的软件——rclone。安装rclone可以从官网下载二进制文件直接拷贝安装，或者下载打包好的deb文件，也可以使用snap进行安装。安装完成之后使用&lt;code>rclone config&lt;/code>添加SFTP服务器，然后就可以&lt;code>rclone mount&lt;/code>进行挂载。此外还可以使用RcloneBrowser等GUI进行更加直接的操作。&lt;/p>
&lt;blockquote>
&lt;p>Tip: 如果你是在Ubuntu上安装RcloneBrowser的话，可以通过修改&lt;code>/usr/share/applications/rclone-browser.desktop&lt;/code>文件来修改图标。（原来的图标实在太丑了）&lt;/p>
&lt;/blockquote>
&lt;h2 id="远程桌面设置">远程桌面设置&lt;/h2>
&lt;p>远程桌面的设置就比较麻烦了，这里的远程桌面服务选择xrdp，关于xrdp，vnc等等服务的比较网上都有。由于最开始安装的是Gnome Ubuntu16.04，因此遇到了很多坑，最后配完远程桌面时显卡驱动崩了，因此最后换到了Ubuntu18.04。因此如果需要远程桌面的朋友可以考虑升级到Ubuntu18.04。&lt;/p>
&lt;p>为了使用上Gnome桌面，最初参考的是一篇&lt;a class="link" href="https://www.hiroom2.com/2016/05/24/ubuntu-16-04-remote-connect-to-gnome-classic-desktop-with-vnc-xrdp/" target="_blank" rel="noopener"
>在Ubuntu16.04上配置xrdp访问Unity桌面的博客&lt;/a>，最后安装完确实是可以完成访问的，并且如果碰到远程登陆之后提示需要新建color profile的话&lt;a class="link" href="http://c-nergy.be/blog/?p=10372" target="_blank" rel="noopener"
>可以通过这个博客解决&lt;/a>。但最后由于安装完xserver-xorg后显卡驱动崩了，换用了18.04。&lt;/p>
&lt;p>在18.04下安装xrdp就简单多了，xrdp版本较新，也不需要安装tigervnc。具体教程还是&lt;a class="link" href="https://www.hiroom2.com/2016/05/24/ubuntu-16-04-remote-connect-to-gnome-classic-desktop-with-vnc-xrdp/" target="_blank" rel="noopener"
>参考了这篇博客&lt;/a>，大概步骤就是&lt;/p>
&lt;ol>
&lt;li>安装&lt;code>xrdp&lt;/code>和&lt;code>xserver-xorg&lt;/code>。需要先安装的&lt;code>xserver-xorg&lt;/code>的原因参见&lt;a class="link" href="https://c-nergy.be/blog/?p=13390" target="_blank" rel="noopener"
>这篇博客&lt;/a>。
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">apt install xserver-xorg-core xsrever-xorg-input-all
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">apt install xrdp
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>如果你安装了Nvidia驱动的话NV还提供定制版的&lt;code>nvidia-xserver-xorg&lt;/code>，也可以通过apt直接安装。安装NV驱动和安装xrdp最好连续进行，避免安装完其他东西之后回头来发现要重装（亲身教训= =）&lt;/p>
&lt;/blockquote>
&lt;ol start="2">
&lt;li>添加&lt;code>echo [session] &amp;gt; ~/.xsession&lt;/code>到&lt;code>/etc/xrdp/startwm.sh&lt;/code>文件里。这里的&lt;code>[session]&lt;/code>内容需要从&lt;code>/usr/share/xsessions&lt;/code>里的桌面环境文件中拷贝出来，例如如果想远程桌面环境运行Gnome3，那么就把&lt;code>[session]&lt;/code>替换成&lt;code>gnome-session --session=gnome&lt;/code>（这行命令就是从&lt;code>/usr/share/xsessions/gnome.desktop&lt;/code>文件中提取出来的）&lt;/li>
&lt;li>修复一些小问题。例如上文提到的color profile问题可以通过&lt;a class="link" href="http://c-nergy.be/blog/?p=12073" target="_blank" rel="noopener"
>这篇很详细的博客提到的方法进行解决&lt;/a>。&lt;/li>
&lt;/ol>
&lt;p>然后在使用xrdp的时候你可能会碰到一些问题，这里记录一些常见问题的解决方法&lt;/p>
&lt;ul>
&lt;li>远程用户在home路径下会挂在一个叫&lt;code>thinclient_drives&lt;/code>的文件夹: 在&lt;code>/etc/xrdp/sesman.ini&lt;/code>中的&lt;code>Chansrv&lt;/code>部分里将FuseMountName改为别的名字（例如&lt;code>.thinclient_drives&lt;/code>）。这个文件夹的作用是实现远程文件拷贝的功能。&lt;/li>
&lt;/ul>
&lt;h2 id="x11-forwarding">X11 Forwarding&lt;/h2>
&lt;p>X11转发是Linux的一种实现远程图形界面的方法，它基于X11窗口协议，类似于Windows对远程GDI的实现。设置好X11以后便可以在ssh中运行远程带有图形界面的程序了～它相比xrdp更好配置，但是使用范围没有xrdp广，因为它只支持程序级别的图形界面，而不是桌面级别的。其设置方法也很简单，在服务器端的&lt;code>/etc/ssh/sshd_config&lt;/code>中将&lt;code>X11Forwarding&lt;/code>选项设为yes即可。在客户端则取决于平台，在Linux平台由于系统界面就是基于X11的（Wayland除外），因此直接使用&lt;code>ssh -X&lt;/code>命令连接服务器就能支持X11转发，而在Windows上则需要额外安装X11服务器，著名的有Vcxsrv, X410等。这里推荐使用&lt;code>MobaXTerm&lt;/code>，这个SSH客户端自带X11服务器，开箱可用，并且性能不错！&lt;/p>
&lt;h2 id="静态ip">静态IP&lt;/h2>
&lt;p>如果想要稳定地连接服务器，还需要给服务器配置静态IP。由于我是在大学校园内，静态IP需要申请。我们的网管要求关闭SSH的远程root登陆，以及关闭不必要的服务，此外还推荐服务器用户使用rsakey登陆SSH。这些要求有利于保护服务器安全，因此也推荐在有需要的情况下完成这些操作。&lt;/p>
&lt;hr>
&lt;p>以上就是给Ubuntu服务器配置远程桌面的主要步骤，步骤不多但是比较花时间。文中提到的几个博客的网站有提供不少的Linux设置教程，可以供读者参考。&lt;/p>
&lt;blockquote>
&lt;p>其他参考阅读：&lt;/p>
&lt;ul>
&lt;li>&lt;a class="link" href="https://www.cnblogs.com/nrm1/p/10219269.html" target="_blank" rel="noopener"
>含Nvidia驱动的远程环境配置&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="http://www.cnblogs.com/ilanni/p/4587171.html" target="_blank" rel="noopener"
>一些xrdp原理的解释&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote></description></item><item><title>安装Windows与Linux（Ubuntu 16.04）双系统并搭建工作环境</title><link>https://zyxin.xyz/blog/2018-09/LinuxDualSystem/</link><pubDate>Sun, 16 Sep 2018 00:00:00 +0000</pubDate><guid>https://zyxin.xyz/blog/2018-09/LinuxDualSystem/</guid><description>&lt;img src="https://zyxin.xyz/blog/2018-09/LinuxDualSystem/drive_manage.png" alt="Featured image of post 安装Windows与Linux（Ubuntu 16.04）双系统并搭建工作环境" />&lt;p>自己的笔记本已经用了快4年了，硬盘除了不小的问题，存资料不放心、玩游戏不给力，因此准备把这台机子变成一个工作专用的机器。另外由于刚来美帝，实验室没有配电脑，我需要一个Linux系统来干活，因此就琢磨着给自己电脑装个Ubuntu双系统。&lt;/p>
&lt;h2 id="ubuntu双系统的安装">Ubuntu双系统的安装&lt;/h2>
&lt;p>先说一下自己电脑的情况。联想Y430P，系统是从OEM版Win8一路升上来的，去年为了Hyper-V重装了Window 10教育版。也就是说这台电脑从到我手上以来未装过Windows以外的系统，因此装双系统需要有一定的调整。Ubuntu双系统的安装主要参照了&lt;a class="link" href="https://www.libinx.com/2017/five-steps-win10-ubuntu-dual-boot/" target="_blank" rel="noopener"
>另一篇博客&lt;/a>。&lt;/p>
&lt;h3 id="给ubuntu系统腾空间">给Ubuntu系统腾空间&lt;/h3>
&lt;p>由于之前系统所有硬盘位置都被分配好了，因此需要先给另一个系统足够的安装空间。重新分配空间在Windows下能够非常方便地通过磁盘管理进行解决。磁盘管理可在任务栏Windows图标右键菜单中打开。腾空间有几种方式：&lt;/p>
&lt;ol>
&lt;li>插入新的硬盘：如果你舍得花钱或者有闲置盘的话&lt;/li>
&lt;li>删除某一磁盘分区：删除分区不代表数据丢失，只是将磁盘一块区域变成未使用的状态&lt;/li>
&lt;li>压缩已有磁盘分区：在不想移动数据的情况下的选择&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://zyxin.xyz/blog/blog/2018-09/LinuxDualSystem/drive_manage.png"
width="760"
height="245"
loading="lazy"
alt="压缩分区和删除分区"
class="gallery-image"
data-flex-grow="310"
data-flex-basis="744px"
>&lt;/p>
&lt;p>由于我想让Ubuntu和Windows共用之前Windows独占的固态硬盘空间，因此我只能选择压缩分区（Windows装在C盘），并且由于这是Windows系统所在分区，因此还会降低压缩能力。为了最大化压缩出来的空间，首先将系统重启并且关掉所有能关掉的系统进程与服务，其次是关闭掉C盘的硬盘保护。实验证明，关闭掉硬盘保护后能够压缩的空间比关之前多了两倍！硬盘保护的开关在&lt;strong>系统面板-&amp;gt;更改设置-&amp;gt;系统保护&lt;/strong>选项卡中，在压缩完毕分区后可以再把硬盘保护打开。压缩完毕后磁盘中会多出一个“未分配”的区域，这便是之后Ubuntu安装的位置。&lt;/p>
&lt;p>&lt;img src="https://zyxin.xyz/blog/blog/2018-09/LinuxDualSystem/close_drive_protection.png"
width="1224"
height="679"
loading="lazy"
alt="磁盘保护的开关位置"
class="gallery-image"
data-flex-grow="180"
data-flex-basis="432px"
>&lt;/p>
&lt;h3 id="制作启动盘">制作启动盘&lt;/h3>
&lt;p>如果你有现成的启动盘当然就可以跳过这一步了~这个步骤对于经常装机的同学来说肯定是so easy，过程说到底也就是从官网下一个ISO镜像然后刻录进光盘或者U盘。不过这里我倒是想推荐一个制作启动盘的软件——&lt;a class="link" href="https://rufus.akeo.ie/" target="_blank" rel="noopener"
>&lt;strong>Rufus&lt;/strong>&lt;/a>，制作流程十分直接，选择ISO后直接按照默认设置就能烧好一个启动盘~之前一直用的是UltraISO，但是完全就是大材小用，而且还收费，只能使用试用版，令强迫症相当不爽。&lt;/p>
&lt;h3 id="运行安装程序">运行安装程序&lt;/h3>
&lt;p>插入启动盘后重启进Boot Menu，选择从启动盘启动，然后就按照Linux的安装流程走了~需要解释的是在选择分区的那一步，如果没有什么特殊需要的话其实直接选择&amp;quot;Install Ubuntu alongside with Windows Boot Manage&amp;quot;（默认的第一个选项）就可以了，但如果想自己定义分区大小、挂载点和boot设置的话就选最后一条&amp;quot;Something else&amp;quot;，然后分区的设置可以参考&lt;a class="link" href="https://www.libinx.com/2017/five-steps-win10-ubuntu-dual-boot/" target="_blank" rel="noopener"
>之前提到的博文&lt;/a>。&lt;/p>
&lt;blockquote>
&lt;p>需要指出的是，我参考这篇文章最后没有能用Windows Boot Manager来启动Ubuntu，还是只能使用Ubuntu附带的丑陋的GRUB，原因是我的Windows是UEFI安装，这个模式下Windows Boot Manager只能启动Windows系统（可以启动不同版本的）而不能启动Linux。具体解释可以参考&lt;a class="link" href="https://neosmart.net/wiki/easybcd/uefi/" target="_blank" rel="noopener"
>EasyBCD的官网说明&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>安装完毕以后可以将系统的更新源设置在国内的镜像库（如清华）上，可以使更新快一点。具体方法是进入&lt;code>系统设置-&amp;gt;软件和更新-&amp;gt;下载至&lt;/code>之中选择&lt;code>http://mirrors.tuna.tsinghua.edu.cn/ubuntu&lt;/code>。&lt;/p>
&lt;/blockquote>
&lt;h3 id="解决一些系统冲突">解决一些系统冲突&lt;/h3>
&lt;p>在安装完双系统后，如果没有什么意外的话就可以进入Ubuntu啦~但是我在进入后发现有两个问题，一个是时间错位，另一个是另外的系统分区（NTFS格式下的）无法打开。&lt;/p>
&lt;p>时间错位的现象是你在进入Ubuntu后再登录Windows，会发现Windows的时间被更改了，与实际时间错位了几个小时。这是由于Ubuntu与Windows的默认时区表示方式不同，导致Ubuntu会修改主板时间。解决方案可以参考&lt;a class="link" href="https://askubuntu.com/questions/169376/clock-time-is-off-on-dual-boot" target="_blank" rel="noopener"
>AskUbuntu上的问题&lt;/a>，我选择的方法是运行&lt;code>timedatectl set-local-rtc 1&lt;/code>。&lt;/p>
&lt;p>装系统之前的NTFS分区无法打开，并且会提示“Windows is hibernated, refused to mount”。其原因是Windows的快速启动阻止Ubuntu的访问，将Windows的快速启动功能关掉即可。&lt;a class="link" href="https://blog.csdn.net/ysy950803/article/details/52780863" target="_blank" rel="noopener"
>详情可参见CSDN贴&lt;/a>。&lt;/p>
&lt;h3 id="调整grub的设置">调整GRUB的设置&lt;/h3>
&lt;p>我这安装完双系统之后，默认启动的顺序是linux在前，而我想把Windows设为默认启动系统。这里就需要更改GRUB的配置文件，用sudo加vim或者gedit打开&lt;code>/etc/default/grub&lt;/code>, 更改里面的&lt;code>GRUB_DEFAULT&lt;/code>值为Windows在GRUB界面的顺序即可，保存后用&lt;code>sudo update-grub&lt;/code>覆盖已有配置即可完成更改。此外在GRUB设置中还有个&lt;code>GRUB_GFXMODE&lt;/code>选项，如果想更改GRUB界面的分辨率的话可以将其更改为需要的分辨率。GRUB支持的分辨率可以在GRUB界面按&lt;code>c&lt;/code>进入命令行，输入videoinfo命令查看。&lt;/p>
&lt;h2 id="ubuntu工作环境的配置">Ubuntu工作环境的配置&lt;/h2>
&lt;p>安装完系统之后就是一些软件以及环境的配置啦~&lt;/p>
&lt;h3 id="常用程序安装">常用程序安装&lt;/h3>
&lt;p>由于我很少使用Linux，因此在Ubuntu下常用的程序也很少，大概有这些:&lt;/p>
&lt;ul>
&lt;li>Firefox: 虽然Ubuntu自带，但是还是更新一下版本比较好&lt;/li>
&lt;li>Visual Studio Code: 没有Visual Studio，写代码只能用它了&lt;/li>
&lt;li>Anaconda: Python环境，系统自带的Python经常会被各种软件弄乱（如ROS），因此还是装个Anaconda。最好不用sudo安装，放在&lt;code>/home&lt;/code>底下就可以了。
&lt;blockquote>
&lt;p>如果今后在编译Python扩展相关的代码时要用Anaconda的python（如使用Anaconda编译pycaffe），那么在&lt;code>~/.bashrc&lt;/code>末尾加一行&lt;code>export LD_LIBRARY_PATH=$&amp;lt;Anaconda根目录&amp;gt;/lib:${LD_LIBRARY_PATH}&lt;/code>&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>git: 这就不解释了&lt;/li>
&lt;li>GitKraken：一个非常好使的Git GUI&lt;/li>
&lt;li>CMake: 写跨平台代码时会用到&lt;/li>
&lt;li>aria2c: 快一点的下载器&lt;/li>
&lt;li>synaptic: 图形化deb包管理&lt;/li>
&lt;/ul>
&lt;p>这些程序的安装要么用&lt;code>sudo apt install&lt;/code>，要么从官网下载&lt;code>.deb&lt;/code>文件双击安装，非常简单~&lt;/p>
&lt;blockquote>
&lt;p>此外，还可以安装一个&lt;strong>中文输入法&lt;/strong>，&lt;a class="link" href="https://blog.csdn.net/ljheee/article/details/52966048" target="_blank" rel="noopener"
>使用ibus的话&lt;/a>会比较好看（&lt;a class="link" href="https://askubuntu.com/questions/1030418/how-to-change-text-entry-in-ubuntu-18-04" target="_blank" rel="noopener"
>Gnome中设置输入法参见这里&lt;/a>）。如果想安装GooglePinyin或者搜狗拼音的安装包，也可以在系统设置中添加中文语言支持，然后将输入法换成fcitx即可。&lt;/p>
&lt;/blockquote>
&lt;h3 id="ubuntu美化">Ubuntu美化&lt;/h3>
&lt;p>如果你忍受不了ubuntu默认的界面风格的话可以对Ubuntu进行美化。具体而言，效果明显的改进就是换主题和图标啦~&lt;/p>
&lt;ol>
&lt;li>安装Gnome桌面，具体命令代码如下：&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">sudo add-apt-repository ppa:gnome3-team/gnome3
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sudo apt update &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> sudo apt install gnome-shell ubuntu-gnome-desktop
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;blockquote>
&lt;p>安装时如果提醒选择X Server的话选择&lt;code>gdm3&lt;/code>。安装完毕后在用户登陆界面中，用户名的右边按钮选择Gnome桌面登陆。另外，如果是安装的18.04应该是自带Gnome桌面了，安装就会简单不少。&lt;/p>
&lt;/blockquote>
&lt;ol start="2">
&lt;li>安装Tweak工具，这个在应用商店中可以找到。安装完毕后在Extension中打开User themes开关。&lt;/li>
&lt;li>安装主题和图标，我选择的是Arc-Darker主题和Papirus图标包。前者的安装方式是在&lt;a class="link" href="https://software.opensuse.org/download.html?project=home%3AHorst3180&amp;amp;package=arc-theme" target="_blank" rel="noopener"
>作者的OBS Repo&lt;/a>中下载&lt;code>.deb&lt;/code>文件直接安装，后者则是使用如下代码&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">sudo add-apt-repository ppa:papirus/papirus
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sudo apt-get update
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sudo apt-get install papirus-icon-theme
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>安装完毕后在Tweak中选择主题和图标包即可&lt;/p>
&lt;blockquote>
&lt;p>其他美化方法可以参照知乎中的&lt;a class="link" href="https://www.zhihu.com/question/20509148/answer/44518012" target="_blank" rel="noopener"
>该回答&lt;/a>和&lt;a class="link" href="https://zhuanlan.zhihu.com/p/36200924" target="_blank" rel="noopener"
>该文章&lt;/a>。另外如果最开始就打算安装Gnome3的话可以考虑安装Gnome Ubuntu（最高版本是16.04.5）或者更新的Ubuntu（默认就是Gnome）。&lt;/p>
&lt;/blockquote>
&lt;h3 id="nvidia显卡驱动安装">NVIDIA显卡驱动安装&lt;/h3>
&lt;p>由于后面还是打算拿这个系统跑深度学习的，因此显卡还是要装的~首先是驱动安装。安装驱动有两种方式，一个是使用&lt;code>.run&lt;/code>文件，另一种则是使用apt install，后一种比较简单，在安装全新的系统时推荐使用后面一种。&lt;/p>
&lt;ol>
&lt;li>使用&lt;code>.run&lt;/code>文件安装&lt;/li>
&lt;/ol>
&lt;p>从官网下载&lt;code>.run&lt;/code>驱动，下载以后放到一个好找的目录下。之后打开终端，输入&lt;code>sudo service lightdm stop&lt;/code>关闭X Server的显示，然后按&lt;kbd>Ctrl&lt;/kbd>+&lt;kbd>Alt&lt;/kbd>+&lt;kbd>F1&lt;/kbd>进入tty模式。找到驱动文件对应的目录，输入如下命令开始安装驱动&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">sudo chmod +x NVIDIA-Linux-x86_64-XXX.YY.run
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sudo ./NVIDIA-Linux-x86_64-XXX.YY.run
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>安装过程中的各种选项按需选择即可。安装完毕后再输入&lt;code>sudo service lightdm start&lt;/code>即可重新打开图形界面。&lt;/p>
&lt;ol start="2">
&lt;li>使用apt进行安装&lt;/li>
&lt;/ol>
&lt;p>打开命令行输入下列命令&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">sudo add-apt-repository ppa:graphics-drivers
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sudo apt-get update
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sudo apt-get install nvidia-XXX
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>安装完重启即可。安装结束时可能会提醒你关掉主板的Secure Boot，按照提示完成即可。&lt;/p>
&lt;h3 id="安装cuda">安装CUDA&lt;/h3>
&lt;blockquote>
&lt;p>CUDA的安装同样有两种方式，一种是使用.run，一种是使用.deb。后者是官方推荐的，而且相比之下deb文件不含驱动，很少有冲突，并且这样对CUDA的卸载和升级更加方便。如果网速比较好的话可以选择Online形式的deb包，这样使用起来就和一般repository差不多了，能自动升级，但是如果连接NVidia的网速不太行的话还是用Offline的deb包更方便。&lt;/p>
&lt;/blockquote>
&lt;p>用N卡做计算加速的话CUDA是必需的。从&lt;a class="link" href="https://developer.nvidia.com/cuda-downloads" target="_blank" rel="noopener"
>官网下载&lt;code>.deb&lt;/code>文件&lt;/a>，然后在终端运行如下命令&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">sudo dpkg -i &amp;lt;CUDA的.deb文件路径&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sudo apt-get update
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sudo apt-get install cuda
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>安装完成后修改环境变量。在终端输入&lt;code>sudo gedit ~/.bashrc&lt;/code>，然后在文件末尾添加如下几行&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># CUDA environment&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">export&lt;/span> &lt;span class="nv">CUDA_HOME&lt;/span>&lt;span class="o">=&lt;/span>/usr/local/cuda
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">export&lt;/span> &lt;span class="nv">LD_LIBRARY_PATH&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="nv">CUDA_HOME&lt;/span>&lt;span class="si">}&lt;/span>/lib64:&lt;span class="si">${&lt;/span>&lt;span class="nv">LD_LIBRARY_PATH&lt;/span>&lt;span class="si">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">export&lt;/span> &lt;span class="nv">PATH&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="nv">CUDA_HOME&lt;/span>&lt;span class="si">}&lt;/span>/bin:&lt;span class="si">${&lt;/span>&lt;span class="nv">PATH&lt;/span>&lt;span class="si">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;blockquote>
&lt;p>注意Linux下PATH的分隔符是冒号&lt;code>:&lt;/code>而不是分号&lt;code>;&lt;/code>&lt;/p>
&lt;/blockquote>
&lt;p>然后重启终端或者使用&lt;code>sudo ldconfig&lt;/code>命令使环境变量生效。验证是否安装成功可以通过编译官方的CUDA Samples完成&lt;/p>
&lt;h3 id="安装cudnn">安装CuDNN&lt;/h3>
&lt;blockquote>
&lt;p>这里采用的是&lt;code>.tar&lt;/code>压缩包安装方法，官网还提供&lt;code>.deb&lt;/code>安装文件，貌似可以CUDA+CuDNN一起安装&lt;/p>
&lt;/blockquote>
&lt;p>CuDNN是利用N卡给神经网络计算做加速的库，也是必需的。CuDNN的安装仅仅是把几个库文件拷到CUDA目录下就可以了。从&lt;a class="link" href="http://developer.nvidia.com/rdp/cudnn-download" target="_blank" rel="noopener"
>官网下载CuDNN库的&lt;code>.tgz&lt;/code>文件&lt;/a>，解压后打开终端进入到解压后的目录，然后运行如下命令即可&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">sudo cp -P cuda/include/cudnn.h /usr/local/cuda/include
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sudo cp -P cuda/lib64/libcudnn* /usr/local/cuda/lib64
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sudo chmod a+r /usr/local/cuda/include/cudnn.h
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;blockquote>
&lt;p>题一下我这里遇到的问题。我在之后安装完tensorflow后发现Tensorflow仍然找不到CuDNN，排除了目录不正确的可能之后发现是libcudnn.so.6.0.20文件的权限设置不正确。不知道为什么压缩包里解压出来的这个文件的权限是&lt;code>-rwxr-xr-x&lt;/code>，与其他的.so文件不同。之后我用&lt;code>chmod&lt;/code>命令将权限改成正常的&lt;code>-rw-r--r--&lt;/code>后即可正常使用Tensorflow了。&lt;/p>
&lt;/blockquote>
&lt;h3 id="安装ros">安装ROS&lt;/h3>
&lt;p>ROS也是我今后工作中会常用到的框架。目前ROS进行LTS支持的版本是Kinetic，并且刚好Kinetic也是支持Ubuntu 16.04的版本，因此我们就安装Kinetic版本的ROS框架。依次执行如下命令：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">sudo sh -c &lt;span class="s1">&amp;#39;echo &amp;#34;deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main&amp;#34; &amp;gt; /etc/apt/sources.list.d/ros-latest.list&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sudo apt-key adv --keyserver hkp://ha.pool.sks-keyservers.net:80 --recv-key 421C365BD9FF1F717815A3895523BAEEB01FA116
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sudo apt-get update
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sudo apt-get install ros-kinetic-desktop-full
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sudo rosdep init
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">rosdep update
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sudo apt-get install python-rosinstall
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">pip install trollius catkin-tools rospkg
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>最后一行是为ros的Python开发提供支持，其中trollius是catkin-tools的依赖项。安装完之后可以在&lt;code>.bashrc&lt;/code>文件里添加环境设置，使得ros的命令能默认在终端里执行。在终端输入&lt;code>sudo gedit ~/.bashrc&lt;/code>，然后在文件末尾添加如下几行&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># add ROS environment&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">source&lt;/span> /opt/ros/kinetic/setup.bash
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>ROS是否安装成功可以通过运行ROS示例来测试。&lt;/p>
&lt;blockquote>
&lt;p>若要使用TUNA镜像，可以将第一行命令中的&lt;code>http://packages.ros.org/ros/ubuntu&lt;/code>换成&lt;code>https://mirrors.tuna.tsinghua.edu.cn/ros/ubuntu/&lt;/code>。&lt;/p>
&lt;/blockquote>
&lt;hr>
&lt;p>整个安装到这就差不多结束了~Ubuntu的使用还是没有Windows那么友好的，不过在编程环境的配置方面还是能省不少事。以后买新电脑后甚至会考虑让这台机子常开Ubuntu当个服务器使了。&lt;/p></description></item></channel></rss>