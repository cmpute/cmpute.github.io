<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Memory on JacobZ</title><link>https://zyxin.xyz/blog/tags/Memory/</link><description>Recent content in Memory on JacobZ</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sun, 24 Jul 2022 14:15:17 +0000</lastBuildDate><atom:link href="https://zyxin.xyz/blog/tags/Memory/index.xml" rel="self" type="application/rss+xml"/><item><title>（C语言）变长数组的陷阱</title><link>https://zyxin.xyz/blog/2022-07/ThePitfallOfVLA/</link><pubDate>Sun, 24 Jul 2022 14:15:17 +0000</pubDate><guid>https://zyxin.xyz/blog/2022-07/ThePitfallOfVLA/</guid><description>&lt;p>{% note default %}&lt;/p>
&lt;h2 id="前言">前言&lt;/h2>
&lt;p>这篇文章转载自&lt;a class="link" href="https://blog.joren.ga/vla-pitfalls" target="_blank" rel="noopener"
>Jorengarenar的博客&lt;/a>。类似于前一篇文章，这一篇博文是我在搜索为什么Rust不支持动态栈分配的时候看到的。有很多人希望Rust支持变长数组，并且有一个&lt;a class="link" href="https://github.com/rust-lang/rust/issues/48055" target="_blank" rel="noopener"
>相关的RFC&lt;/a>，但是&lt;a class="link" href="https://users.rust-lang.org/t/a-question-about-how-memory-is-stored-and-vlas/33901/16?u=cmpute" target="_blank" rel="noopener"
>也有人提到这很危险&lt;/a>，并且不会带来太大的收益，这篇文章总结了变长数组的问题，可供参考。
{% endnote %}&lt;/p>
&lt;h2 id="正文">正文&lt;/h2>
&lt;blockquote>
&lt;p>相比于固定尺寸，它会生成更多的、并且更慢的代码（而且很脆弱）。—— &lt;a class="link" href="https://lkml.org/lkml/2018/3/7/621" target="_blank" rel="noopener"
>Linus Torvalds&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>VLA 是变长数组（variable-length array）的缩写，它指的是长度在运行时而不是编译时决定的数组（真·数组，而不是接口像数组的一块内存）。VLA在C99标准中被引进，乍看上去它很方便并且高效，但是这只是各幻觉，实际上它只是一些顽固问题的源头。&lt;/p>
&lt;p>这篇文章的批评主要针对自动变长数组（automatic VLA），而不是所有形式的VLA，因此我在后文会用缩写aVLA来进行区分。&lt;/p>
&lt;blockquote>
&lt;p>支持某种形式的VLA的语言有：Ada, Algol 68, C, C#, COBOL, Fortran, J 和 Object Pascal。你可能注意到了，除了C和C#之外，其他的语言都不主流了。&lt;/p>
&lt;p>你从开头的引言中可能也猜到了，一个相当依赖于VLA的项目不是别的，正是Linux内核。维护者们花费了很多精力来移除VLA，并且在内核版本4.20（2018年）后实现了完全无VLA。&lt;/p>
&lt;p>在这篇文章刚开头的时候，我还要指出，在一些情形下，VLA是一个好解决方案。这样的情形不多，但是确实存在。未来我会尽力好好介绍他们并且链接到这篇文章来。&lt;/p>
&lt;/blockquote>
&lt;h2 id="栈分配">栈分配&lt;/h2>
&lt;p>aVLA通常分配在栈上，这就绝大部分问题的根源。我们来看一个非常简单并且看起来很适合aVLA的例子：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">scanf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%d&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">long&lt;/span> &lt;span class="kt">double&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%Lf&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>你可以发现，这段代码从用户的输入读取数组长度。编译并且跑一下试试，看看在堆栈溢出造成区块错误（segfault）前，你可以输入多少值。在我的测试里这个上限是50万。这只是一个基础数据类型！想象以下对于一个结构体这个上限可能是多少！或者如果不仅仅是&lt;code>main()&lt;/code>？考虑下递归函数？这个上限会大幅降低。&lt;/p>
&lt;p>并且，你没有任何（可移植、标准）的方法来处理堆栈溢出——你的程序已经无可救药地崩了。因此你要么需要在声明数组之前进行严格的长度审查，要么指望用户不要输入太大的数据。（这样赌博的后果显而易见）&lt;/p>
&lt;p>因此程序员&lt;strong>必须&lt;/strong>保证aVLA的商都不能超过安全的上限。但是实际情况里，如果你知道这个安全上限，那没道理你不会去确认它。&lt;/p>
&lt;h2 id="最糟糕的是">最糟糕的是&lt;/h2>
&lt;p>最糟糕的是segfault只是不当使用aVLA造成的后果中最好的一个。最坏情况是造成可以被利用的漏洞，攻击者可能会选择一个值，使得这个数组与其他内存分配重叠，从而控制那些值。这是个安全性灾难。&lt;/p>
&lt;blockquote>
&lt;p>如果你接受（进一步）损失程序性能，在GCC中你可以开启&lt;code>-fstack-clash-protection&lt;/code>选项，它会在进行变长栈空间分配时，增加额外的指令来在每个内存页上进行探测。这可以确保所有的栈分配是有效的，或者在无效的时候抛出segfault，来缓解栈冲突（stack-clash）问题，从而将可能的代码执行攻击变成服务拒绝（denial of service）&lt;/p>
&lt;/blockquote>
&lt;h2 id="那如何修改这个例子">那如何修改这个例子？&lt;/h2>
&lt;p>如果我想让用户决定数组大小并且创建大的离谱的定长数组很浪费？很简单，用&lt;code>malloc()&lt;/code>！&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;stdlib.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">scanf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%d&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">long&lt;/span> &lt;span class="kt">double&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">arr&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nf">malloc&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="k">sizeof&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">arr&lt;/span>&lt;span class="p">));&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%Lf&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">free&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">arr&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在这个例子里我可以最大输入13亿而不让我的机子报错。这大概是之前的2500倍！但是我最后仍然会碰到segfault是吧？唔，区别在于我们可以检查&lt;code>malloc()&lt;/code>的返回值，然后比如我们就可以告知用户：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">long&lt;/span> &lt;span class="kt">double&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">arr&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nf">malloc&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="k">sizeof&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">arr&lt;/span>&lt;span class="p">));&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">arr&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">perror&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;malloc()&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// output: &amp;#34;malloc(): Cannot allocate memory&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;blockquote>
&lt;p>我碰到过相左的观点：C经常被用于系统和嵌入式的语言，这些情况下可能都没法使用&lt;code>malloc()&lt;/code>。&lt;/p>
&lt;p>唉。。看来我又要重复一遍了，不过这确实很重要。&lt;/p>
&lt;p>在这种设备上你同样也没有多少栈空间。因此相比于在栈上动态分配空间，你应该确定你到底需要多少内存然后只使用固定尺寸的内存。&lt;/p>
&lt;p>当在栈空间很小的设备上使用aVLA的时候，你很容易弄出一些看起来能用的东西，但是当你的函数在栈已经很深的，有很多数据的时候被调用，你的栈就会炸。&lt;/p>
&lt;p>如果你在每个地方都分配固定尺寸的栈空间，那么你知道这肯定没问题。如果你在栈上动态分配内存，你需要测试你所有的代码路径，并且在所有可能的分配尺寸情况下进行测试，这比前者更难更容易出错。不要在甚至没有好处的情况下让它更容易射到你的脚（一个歇后语：footgun）&lt;/p>
&lt;/blockquote>
&lt;h2 id="意外创建">意外创建&lt;/h2>
&lt;p>不像其他危险的C语言特性，aVLA没有什么门槛。很多新手会在试错之后开始使用这个特性，却根本不了解它的问题。有些时候甚至很有经验的程序员都会大意，在不需要aVLA的时候创建它。以下就是一个完全没必要的静静地创建了一个aVLA的例子：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="k">const&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">n&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">10&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="n">A&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>好在只要是个比较现代的编译器都会发现并且把这个aVLA给优化掉，但是。。。万一它没发现呢？或者它处于某种原因（安全？）没有这么做呢？优化没打开呢？但这肯定都问题不大，是吧？呃。。。&lt;/p>
&lt;h2 id="比定长慢">比定长慢&lt;/h2>
&lt;p>在编译器不优化的情况下，之前这个&lt;a class="link" href="https://godbolt.org/z/c7nPvGGcP" target="_blank" rel="noopener"
>aVLA的例子&lt;/a>在数组初始化之前会生成7倍多的汇编指令，相比于它&lt;a class="link" href="https://godbolt.org/z/jx94vx84T" target="_blank" rel="noopener"
>对应的定长情况&lt;/a>（参见&lt;code>jmp .L5&lt;/code>之前的汇编部分）。但这是没有开编译器优化的情况，如果开了生成的汇编是一模一样的。&lt;/p>
&lt;p>这里有一个aVLA不是意外插入的例子：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="nf">bar&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#if 1 &lt;/span>&lt;span class="c1">// 1 for aVLA, 0 for aVLA-free
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">foo&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">A&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">--&lt;/span>&lt;span class="p">;)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">scanf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%d&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">A&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">bar&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">A&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#else
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">foo&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">A&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1000&lt;/span>&lt;span class="p">];&lt;/span> &lt;span class="c1">// Let&amp;#39;s make it bigger than 10! (or there won&amp;#39;t be what to examine)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">--&lt;/span>&lt;span class="p">;)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">scanf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%d&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">A&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">bar&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">A&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#endif
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">foo&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">10&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">bar&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">B&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">--&lt;/span>&lt;span class="p">;)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%d %d&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">B&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>处于介绍的目的，在这个例子中&lt;code>-O1&lt;/code>级别的优化是最好的（生成的汇编会更清楚，然后&lt;code>-O2&lt;/code>并不会有太大的用处）。&lt;/p>
&lt;p>当我们编译aVLA的版本，在&lt;code>for&lt;/code>循环之前的指令如下：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">push rbp
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">mov rbp, rsp
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">push r14
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">push r13
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">push r12
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">push rbx
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">mov r13d, edi
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">movsx r12, edi ; here aVLA &amp;#34;starts&amp;#34;...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sal r12, 2 ;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">lea rax, [r12+15] ;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">and rax, -16 ;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sub rsp, rax ;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">mov r14, rsp ; ... and there &amp;#34;ends&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>而无aVLA的版本则生成：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">push r12
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">push rbp
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">push rbx
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sub rsp, 4000 ; this is caused by array definition
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">mov r12d, edi
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>因此不仅定长数组生成更少的代码，它也简单多了。为什么aVLA在最开始的时候会产生更多的开销？它没有什么特别伟大的任务，但仍然不是简简单单的一个指针移动。&lt;/p>
&lt;p>但是这些区别影响很大吗？&lt;a class="link" href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=02361bc77888" target="_blank" rel="noopener"
>是的，很大&lt;/a>。&lt;/p>
&lt;h2 id="无法初始化">无法初始化&lt;/h2>
&lt;p>在aVLA不经意间造成的问题中还有如下不被允许的例子：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="n">n&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">10&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="n">A&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>即便开了优化，aVLA仍然不支持初始化。因此尽管我们想要的是定长数组并且理论上编译器可以干这件事，但它就是行不通。&lt;/p>
&lt;h2 id="给编译器作者带来麻烦">给编译器作者带来麻烦&lt;/h2>
&lt;p>几个月前我存了Reddit上的一个&lt;a class="link" href="https://www.reddit.com/r/C_Programming/comments/jz2213/are_vlas_bad_even_if_theyre_not_allocated_on_the/gdc3hz6" target="_blank" rel="noopener"
>评论&lt;/a>，它列举了从编译器开发者的角度在VLA上碰到的问题。我把它引在下面：&lt;/p>
&lt;blockquote>
&lt;ul>
&lt;li>VLA其实适用于一个类型，而不是一个实际数组。因此你可以给VLA类型加一个&lt;code>typedef&lt;/code>，它会冻结用到的表达式，即便这个表达式的一部分在VLA类型被使用的时候已经变了&lt;/li>
&lt;li>VLA可以在代码块和循环中使用，这意味着要在栈上分配和释放动态长度的数据，如果你不想让偏移量（offsets）被乱搞，你就需要用指针来间接地实现它。&lt;/li>
&lt;li>你可以在有VLA被使用的情况下用&lt;code>goto&lt;/code>跳进或者跳出代码块，有些事情会被限制，但是也有不被限制的，而编译器却需要跟踪所有的这些骚操作&lt;/li>
&lt;li>VLA可以被用在多维数组上&lt;/li>
&lt;li>VLA可以被指针指向（因此你不需要分配空间，但是仍然需要跟踪所有变量的大小）&lt;/li>
&lt;li>有些编译器允许在结构体定义里面使用VLA（我真的不知道这是怎么弄的，或者在什么地方VLA的尺寸被定下来了，然后所有的结构体会拥有同样的VLA尺寸）&lt;/li>
&lt;li>一个函数可以同时有多个VLA被使用，并且它们可以在不同的地方，或者有条件地，或者在循环里被创建或者销毁。&lt;/li>
&lt;li>&lt;code>sizeof&lt;/code>需要被专门针对VLA实现（针对一个VLA实体，VLA类型，混合VLA和定长尺寸的类型，VLA数组，VLA指针）&lt;/li>
&lt;li>VLA这个词还被用于描述（当维数由传入参数确定时）多维数组的参数&lt;/li>
&lt;li>在Windows上用有些编译器的时候（至少GCC是这样），声明过大的局部数组（使得栈尺寸超过4KB）意味着要调用一个特殊的分配器（&lt;code>__chkstk()&lt;/code>），因为栈空间一次只能增长一个内存页）。当声明一个VLA的时候，编译器不知道它的长度，因此它需要在每个涉及的函数里都调用（&lt;code>__chkstk()&lt;/code>），即便VLA的尺寸实际上很小。&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>并且相信我，如果你在C语言的一些论坛里溜一圈，你会发现更多不同的抱怨。&lt;/p>
&lt;h2 id="降低可移植性">降低可移植性&lt;/h2>
&lt;p>由于前面提到的这所有问题，有些编译器决定不完全支持C99。最主要的例子是微软的MSVC。C语言标准委员会页注意到了这个问题，并且在C11修订版中将VLA的支持标为可选的。&lt;/p>
&lt;blockquote>
&lt;p>C2x计划将推翻这个决定，但是aVLA仍然不是强制的&lt;/p>
&lt;/blockquote>
&lt;p>这意味着使用VLA的代码有可能没法被一个C11编译器编译。因此你需要检查&lt;code>__STDC_NO_VLA__&lt;/code>宏，并且在不支持的时候增加备用选项。&lt;/p>
&lt;blockquote>
&lt;p>另外，C++没有VLA并且没有证据表明它有将来会支持。这不是什么大事，但是仍然给C的VLA提供了一个反例&lt;/p>
&lt;/blockquote>
&lt;h2 id="挑骨头打破调用习惯">（挑骨头）打破调用习惯&lt;/h2>
&lt;p>这是鸡蛋里挑骨头了，但是它确实是另一个让人不喜欢VLA的原因。一个常用的函数调用习惯是先传指针，再传参数，对于数组它的意思是：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">foo&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">**&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">m&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="cm">/* arr[i][j] = ... */&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>C99标准中，提到数组的长度必须在参数列表里遇到的时候立马被分析确定，这意味着在用VLA的时候你没法用跟上面一样的语法&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">foo&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="n">m&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">m&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="cm">/* arr[i][j] = ... */&lt;/span> &lt;span class="p">}&lt;/span> &lt;span class="c1">// 非法！
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>你需要&lt;/p>
&lt;ul>
&lt;li>打破这个习惯
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">foo&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">m&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="n">m&lt;/span>&lt;span class="p">])&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="cm">/* arr[i][j] = ... */&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>或者使用过时的语法（即将被标准删除）
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">foo&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">foo&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">arr&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">m&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="n">m&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// arr[i][j] = ...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;h2 id="结论">结论&lt;/h2>
&lt;p>简而言之，别用VLA，编译你代码的时候开启&lt;code>-Wvla&lt;/code>开关。VLA特性带来了很多危险却经常没有与之匹配的有用的回报。如果你发现在你的使用场景里里VLA是一个有效的解决方法，那就用它，但是记住我上面所提到的这些局限。&lt;/p>
&lt;blockquote>
&lt;p>可能还值得一提的是，VLA还被认为是解决问题同样很多的，不标准的&lt;code>alloca()&lt;/code>的一个途径。&lt;/p>
&lt;/blockquote></description></item></channel></rss>