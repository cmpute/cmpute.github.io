<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Cython on JacobZ</title><link>https://zyxin.xyz/blog/tags/Cython/</link><description>Recent content in Cython on JacobZ</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Wed, 28 Aug 2019 00:00:00 +0000</lastBuildDate><atom:link href="https://zyxin.xyz/blog/tags/Cython/index.xml" rel="self" type="application/rss+xml"/><item><title>Cython中的特殊函数</title><link>https://zyxin.xyz/blog/2019-08/CythonFunctions/</link><pubDate>Wed, 28 Aug 2019 00:00:00 +0000</pubDate><guid>https://zyxin.xyz/blog/2019-08/CythonFunctions/</guid><description>&lt;p>这次来介绍一下Cython中的特殊函数定义，Cython相比Python本身的特殊函数之外还增加了一些新的函数，用来满足对C特性的支持，其中有些内容还经常令人混淆。关于Python中特殊变量和特殊函数名的内容，&lt;a class="link" href="https://docs.python.org/3/reference/datamodel.html" target="_blank" rel="noopener"
>请参考Python官方文档&lt;/a>。&lt;/p>
&lt;h2 id="def-cdef和cpdef">&lt;code>def&lt;/code>, &lt;code>cdef&lt;/code>和&lt;code>cpdef&lt;/code>&lt;/h2>
&lt;p>首先最开始需要分清的便是Cython中的三种函数类型。&lt;code>def&lt;/code>定义的对象（包括变量、函数、类型）都是普通的Python对象，是Python可以直接调用的，因此其参数都只能是Python类型或对象；&lt;code>cdef&lt;/code>定义的对象则是C/C++层面的，可以直接用C/C++对象作为参数，因此不能被普通Python代码调用，这样减少了很多overhead因此可以提高运行效率。另外尽管&lt;code>cdef&lt;/code>的函数不是Python对象，无法当作变量使用，但还是可以获取函数指针的。而&lt;code>cpdef&lt;/code>则是同时兼具两方面特性，其本质是用&lt;code>cdef&lt;/code>定义函数后再用&lt;code>def&lt;/code>定义一个函数封装，使得在Cython中调用时可以调用高效的&lt;code>cdef&lt;/code>版本，而在Python中调用的是与Python兼容的&lt;code>def&lt;/code>版本。&lt;/p>
&lt;h2 id="__init__和__cinit__">&lt;code>__init__&lt;/code>和&lt;code>__cinit__&lt;/code>&lt;/h2>
&lt;p>在理清了上面几个关键字后另一个经常令人疑惑的点便是&lt;code>__init__&lt;/code>和&lt;code>__cinit__&lt;/code>的区别。&lt;code>__cinit__&lt;/code>和&lt;code>__dealloc__&lt;/code>都是Cython特有的特殊函数。&lt;a class="link" href="https://cython.readthedocs.io/en/latest/src/userguide/special_methods.html#initialisation-methods-cinit-and-init" target="_blank" rel="noopener"
>官方文档在其用法上解释&lt;/a>的并不清楚，只是说&lt;code>__cinit__&lt;/code>可以用来进行C/C++级别的初始化。实际上，使用&lt;code>__cinit__&lt;/code>的重要原因是源于其特性：&lt;code>__cinit__&lt;/code>会像C++一样自动执行基类的&lt;code>__cinit__&lt;/code>，因此它保证会在构造时被执行一次（且只被执行一次）。由于Python中的&lt;code>__init__&lt;/code>函数默认不会调用基类的&lt;code>__init__&lt;/code>，因此如果想保证类型中的&lt;code>cdef&lt;/code>成员被初始化，避免可能的堆栈问题（如指针没有初始化），那么就可以选择使用&lt;code>__cinit__&lt;/code>。如果理解了这一点就可以知道，什么时候需要使用&lt;code>__cinit__&lt;/code>了。&lt;/p>
&lt;p>但是使用&lt;code>__cinit__&lt;/code>的时候有很多限制需要了解：&lt;/p>
&lt;ol>
&lt;li>&lt;code>__cinit__&lt;/code>有时会带来额外的开销，&lt;a class="link" href="https://kaushikghose.wordpress.com/2015/03/08/cython-__cinit__/" target="_blank" rel="noopener"
>这篇博客中有一些分析&lt;/a>。&lt;/li>
&lt;li>&lt;code>__cinit__&lt;/code>的参数声明和&lt;code>__init__&lt;/code>必须一致，因为会同时被调用。因此通常&lt;code>__cinit__&lt;/code>的参数中会留下&lt;code>*kargs&lt;/code>和&lt;code>**kvargs&lt;/code>。&lt;a class="link" href="https://stackoverflow.com/a/33091422" target="_blank" rel="noopener"
>Stackoverflow上也有人问过这个情况&lt;/a>。&lt;/li>
&lt;li>&lt;code>__cinit__&lt;/code>中如果要用&lt;code>malloc&lt;/code>分配内存，记得在&lt;code>__dealloc__&lt;/code>中销毁。&lt;code>__dealloc__&lt;/code>相当于C++版本的&lt;code>__del__&lt;/code>&lt;/li>
&lt;li>&lt;code>__cinit__&lt;/code>和&lt;code>__init__&lt;/code>一样也只能使用&lt;code>def&lt;/code>声明，不能用&lt;code>__cdef__&lt;/code>和&lt;code>__cpdef__&lt;/code>。具体原因我并不清楚。&lt;/li>
&lt;/ol>
&lt;h2 id="运算符重载">运算符重载&lt;/h2>
&lt;p>其他大多数的特殊函数定义和用法几乎和Python相同，但是需要特别指出的是运算符重载的部分。以加法为例，在Python中加法&lt;code>a + b&lt;/code>的实现方式是：&lt;/p>
&lt;ol>
&lt;li>如果&lt;code>a&lt;/code>中定义了&lt;code>__add__&lt;/code>，那么调用&lt;code>a.__add__(b)&lt;/code>&lt;/li>
&lt;li>如果&lt;code>a&lt;/code>中没有定义，而&lt;code>b&lt;/code>中定义了&lt;code>__radd__&lt;/code>，那么调用&lt;code>b.__radd(a)&lt;/code>&lt;/li>
&lt;/ol>
&lt;p>而在Python的C扩展类里（包含Cython和pybind11的实现），其实现方式是寻找接受&lt;code>a&lt;/code>和&lt;code>b&lt;/code>类型的&lt;code>__add__&lt;/code>重载，也就是说本质上在C扩展类中定义的&lt;code>__add__&lt;/code>都是&lt;code>__add__&lt;/code>的重载，这也是与C++的&lt;code>operator&lt;/code>重载理念一致，只不过这个&lt;code>__add__&lt;/code>仍然需要定义在类里。在&lt;a class="link" href="https://cython.readthedocs.io/en/latest/src/userguide/special_methods.html#arithmetic-operators" target="_blank" rel="noopener"
>Cython文档中给出的运算符列表&lt;/a>里，参数里带&lt;code>self&lt;/code>的函数都是按照Python中的方法实现的，&lt;code>self&lt;/code>不能指定类型；而以&lt;code>x, y&lt;/code>这种形式为参数的则是按照C扩展类执行方式的函数，&lt;code>x&lt;/code>和&lt;code>y&lt;/code>都可以指定类型。&lt;/p>
&lt;p>另外Cython还定义了一个特殊的运算符函数&lt;code>__richcmp__&lt;/code>，这个是Python中没有的，不过其功能只是把比较符号（&amp;gt;,&amp;lt;,=）的实现合并了，与Python的&lt;code>__eq__&lt;/code>、&lt;code>__lt__&lt;/code>等函数没有本质区别。&lt;a class="link" href="https://cython.readthedocs.io/en/latest/src/userguide/special_methods.html#rich-comparison-operators" target="_blank" rel="noopener"
>这在官方文档中也有说明&lt;/a>&lt;/p>
&lt;h2 id="__getbuffer__">&lt;code>__getbuffer__&lt;/code>&lt;/h2>
&lt;p>&lt;a class="link" href="https://cython.readthedocs.io/en/latest/src/userguide/special_methods.html#buffer-interface-pep-3118-no-python-equivalents-see-note-1" target="_blank" rel="noopener"
>Cython中有两个版本的Buffer协议&lt;/a>，一种是提案PEP-3118定义的，另一种是Python官方定义之前Cython自己的定义方式。其中前者在&lt;a class="link" href="https://zyxin.xyz/blog/2019-08/CythonInterop/" >之前介绍Cython封装的文章&lt;/a>中已有介绍，就不多赘述。其相关的特殊函数是&lt;code>__getbuffer__&lt;/code>和&lt;code>__releasebuffer__&lt;/code>，这两个函数也都是Cython特有的。而后者比较难用，已经被标记为depricated废弃了，也不介绍了。&lt;/p>
&lt;h2 id="属性property">属性（property）&lt;/h2>
&lt;p>Cython中还提供了一套非常方便的属性定义方法。原本在Python中定义属性非常但疼，例如下面的代码定义了名为&lt;code>length&lt;/code>的属性，使得你可以通过&lt;code>square.length&lt;/code>的方法访问它&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">Square&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nd">@property&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">def&lt;/span> &lt;span class="nf">length&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">_length&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nd">@length.setter&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">def&lt;/span> &lt;span class="nf">length&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">_length&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">value&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nd">@length.deleter&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">def&lt;/span> &lt;span class="nf">length&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">_length&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>而在Cython中定义属性就更简单了，它除了支持上面的方法外还有另一种更加直观的定义方式（虽然这个方式也已经被标记为depricated了）：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="n">cdef&lt;/span> &lt;span class="k">class&lt;/span> &lt;span class="nc">Square&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">property&lt;/span> &lt;span class="n">length&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">def&lt;/span> &lt;span class="fm">__get__&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">_length&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">def&lt;/span> &lt;span class="fm">__set__&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">_length&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">value&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">def&lt;/span> &lt;span class="fm">__del__&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">_length&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;hr>
&lt;p>Cython的类型还有各种其他的奇奇怪怪的小特性，在Cython的这两篇文档里有详细介绍：&lt;a class="link" href="https://cython.readthedocs.io/en/latest/src/userguide/extension_types.html" target="_blank" rel="noopener"
>Extension Types&lt;/a>, &lt;a class="link" href="https://cython.readthedocs.io/en/latest/src/userguide/special_methods.html#buffer-interface-pep-3118-no-python-equivalents-see-note-1" target="_blank" rel="noopener"
>Special Methods of Extension Types&lt;/a>，仅供参考～&lt;/p></description></item><item><title>在Cython中操作数组</title><link>https://zyxin.xyz/blog/2019-08/CythonArray/</link><pubDate>Wed, 28 Aug 2019 00:00:00 +0000</pubDate><guid>https://zyxin.xyz/blog/2019-08/CythonArray/</guid><description>&lt;p>Cython提供了很多方法来搭建C/C++内存和Python对象间的桥梁，但是官方的教程只介绍了一些基础的方法。这篇文章就介绍一下我在各个场合学到和用到的Cython封装（多维）数组的技巧。一般而言这个桥梁会分为两部分，Python与Cython和Cython与C/C++。其中Python中的数组主要形式是&lt;code>list&lt;/code>、&lt;code>array.array&lt;/code>和&lt;code>numpy.ndarray&lt;/code>；Cython中的数组形式有&lt;code>[:,:,:]&lt;/code>（&lt;a class="link" href="https://cython.readthedocs.io/en/latest/src/userguide/memoryviews.html?highlight=pointer#view-cython-arrays" target="_blank" rel="noopener"
>Memoryview&lt;/a>/&lt;a class="link" href="https://www.python.org/dev/peps/pep-3118/" target="_blank" rel="noopener"
>Buffer&lt;/a>）和&lt;code>cython.view.array&lt;/code>；C/C++的数组形式有&lt;code>**&lt;/code>（指针）、&lt;code>vector&lt;/code>和&lt;code>Eigen::Vector/Matrix&lt;/code>。&lt;/p>
&lt;blockquote>
&lt;p>本篇介绍的主要内容也来自于Cython的文档：&lt;a class="link" href="http://cython.readthedocs.io/en/latest/src/userguide/memoryviews.html" target="_blank" rel="noopener"
>Typed Memoryviews&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;p>在这里也先介绍一下Cython中的这几个概念：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Memoryview&lt;/strong>：这是cython提供的一种语法糖，相当于提供了C中&lt;code>int[][][]&lt;/code>形式数组的类型。由于Memoryview可以兼容Python的Buffer协议，因此我把他们放在了一起。Memoryview需要指定元素的类型，这个类型必须是内置数值类型或者&lt;strong>C结构体&lt;/strong>。&lt;/li>
&lt;li>&lt;strong>&lt;code>cython.view.array&lt;/code>&lt;/strong>：这是Cython提供的一个多维数组类型，与&lt;code>numpy.ndarray&lt;/code>非常相似了。
这两个东西也是可以相互转换的，例如&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="kn">from&lt;/span> &lt;span class="nn">cython.view&lt;/span> &lt;span class="n">cimport&lt;/span> &lt;span class="n">array&lt;/span> &lt;span class="k">as&lt;/span> &lt;span class="n">cvarray&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># Cython array to Memoryview&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">cyarr&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">cvarray&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">shape&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="n">itemsize&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">int&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="nb">format&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;i&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">cdef&lt;/span> &lt;span class="nb">int&lt;/span> &lt;span class="p">[:,&lt;/span> &lt;span class="p">:,&lt;/span> &lt;span class="p">:]&lt;/span> &lt;span class="n">cyarr_view&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">cyarr&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># Memoryview to Cython array&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">cdef&lt;/span> &lt;span class="n">cvarray&lt;/span> &lt;span class="n">back&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">cyarr_view&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="python与cython数组相互转换">Python与Cython数组相互转换&lt;/h2>
&lt;p>Python与Cython之间的转换基本上都由Cython的Memoryview提供了接口，实际上直接赋值就可以。例如官方给出的这段例子：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="kn">from&lt;/span> &lt;span class="nn">cpython&lt;/span> &lt;span class="n">cimport&lt;/span> &lt;span class="n">array&lt;/span> &lt;span class="k">as&lt;/span> &lt;span class="n">cparray&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kn">import&lt;/span> &lt;span class="nn">numpy&lt;/span> &lt;span class="k">as&lt;/span> &lt;span class="nn">np&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># Memoryview on a NumPy array&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">narr&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">np&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">arange&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">27&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">dtype&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">np&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">dtype&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;i&amp;#34;&lt;/span>&lt;span class="p">))&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">reshape&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">cdef&lt;/span> &lt;span class="nb">int&lt;/span> &lt;span class="p">[:,&lt;/span> &lt;span class="p">:,&lt;/span> &lt;span class="p">:]&lt;/span> &lt;span class="n">narr_view&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">narr&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># Memoryview on a CPython array&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">parr&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">cparray&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">array&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;i&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">cdef&lt;/span> &lt;span class="nb">int&lt;/span> &lt;span class="p">[:]&lt;/span> &lt;span class="n">parr_view&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">parr&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>顺带一提，&lt;code>list&lt;/code>对象由于本身不代表一段连续内存，因此需要先转换为&lt;code>array&lt;/code>或&lt;code>ndarray&lt;/code>再赋值给Memoryview。反过来由于Numpy支持Buffer协议，因此Memoryview和Cython的&lt;code>cython.view.array&lt;/code>都可以直接转换为&lt;code>numpy.ndarray&lt;/code>，然后转换为&lt;code>array&lt;/code>和&lt;code>list&lt;/code>：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="kn">from&lt;/span> &lt;span class="nn">cpython&lt;/span> &lt;span class="n">cimport&lt;/span> &lt;span class="n">array&lt;/span> &lt;span class="k">as&lt;/span> &lt;span class="n">cparray&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kn">import&lt;/span> &lt;span class="nn">numpy&lt;/span> &lt;span class="k">as&lt;/span> &lt;span class="nn">np&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">parr&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">cparray&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">array&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;i&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">cdef&lt;/span> &lt;span class="nb">int&lt;/span> &lt;span class="p">[:]&lt;/span> &lt;span class="n">parr_view&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">parr&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">narr&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">np&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">array&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">parr_view&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1"># explicit version: np.array(parr_view, copy=False)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;blockquote>
&lt;p>以上这些代码中的等式都没有发生内存拷贝。&lt;/p>
&lt;/blockquote>
&lt;h2 id="cython数组与cc数组相互转换">Cython数组与C/C++数组相互转换&lt;/h2>
&lt;p>Cython的Memoryview同样承担了大量与C/C++数组进行转换的功能，不过Memoryview只支持一种转换方法，就是与raw指针的相互转换：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="kn">from&lt;/span> &lt;span class="nn">libc.stdlib&lt;/span> &lt;span class="n">cimport&lt;/span> &lt;span class="n">malloc&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">cdef&lt;/span> &lt;span class="n">double&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">data&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">double&lt;/span>&lt;span class="o">*&amp;gt;&lt;/span>&lt;span class="n">malloc&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">double&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># Convert pointer to Memoryview&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">cdef&lt;/span> &lt;span class="n">double&lt;/span>&lt;span class="p">[:]&lt;/span> &lt;span class="n">view&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">double&lt;/span>&lt;span class="p">[:&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">,:&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="n">data&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># Convert Memoryview to pointer&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">data&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">view&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;blockquote>
&lt;p>以上代码的等式中也没有发生内存拷贝。&lt;/p>
&lt;/blockquote>
&lt;p>这里需要指出的是，由于指针本身只是一段内存的代表，因此在转换时制定类型和长度（如&lt;code>&amp;lt;double[4]&amp;gt;&lt;/code>），并且需要保证指针指向的数组是C型连续的（多维数组中最后一维的内存是连续的）。如果要将&lt;code>vector&lt;/code>和&lt;code>Eigen::Matrix&lt;/code>转换为Memoryview，那么也同样需要获取其内存指针（&lt;code>vector::data&lt;/code>和&lt;code>Eigen::Matrix::data&lt;/code>）。另外，通过&lt;strong>指针转换出来的Memoryview没有引用计数&lt;/strong>，因此如果你的指针是某个Cython类的成员，那么不要使用指针转换，而使用Buffer协议的方式进行传递。&lt;/p>
&lt;h2 id="其他直接转换的方法">其他直接转换的方法&lt;/h2>
&lt;p>除了上面提到的方法之外还有一些直接转换的方法，但是这些方法往往不会做类型和尺寸检查，以及很重要的内存连续性检查（Memoryview会区分C型内存和Fortran型内存），因此使用时需要谨慎。&lt;/p>
&lt;ul>
&lt;li>&lt;code>cdef vector[int] data; cdef list view = data&lt;/code>：Cython提供了list和vector直接转换的接口&lt;/li>
&lt;li>&lt;code>cdef np.ndarray[double] data; cdef double* view = &amp;lt;double*&amp;gt; data.data&lt;/code>&lt;/li>
&lt;li>&lt;code>cdef np.ndarray[double, ndim=2] data; cdef double* view = &amp;amp;data[0,0]&lt;/code>&lt;/li>
&lt;li>&lt;code>cdef array.array data; cdef double* view = data.data.as_doubles[0]&lt;/code>：利用了&lt;a class="link" href="https://cython.readthedocs.io/en/latest/src/tutorial/array.html#zero-overhead-unsafe-access-to-raw-c-pointer" target="_blank" rel="noopener"
>Cython中的API&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="非内置类型的转换">非内置类型的转换&lt;/h2>
&lt;p>在实际应用过程中还会碰到由复杂元素构成的数组（例如PCL里面的PointXYZ、SLAM里会用到的Quaternion），这时就有将复杂类型（通常是自定义struct）在Python和C/C++之间转换的需求。这时可以选择利用Cython提供的MemoryView，也可以利用Python的Buffer协议直接将C++对象传递给Python。&lt;/p>
&lt;p>使用Buffer协议的方法请直接参考&lt;a class="link" href="https://cython.readthedocs.io/en/latest/src/userguide/buffer.html" target="_blank" rel="noopener"
>Cython文档&lt;/a>，使用Memoryview的例子如下：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="kn">from&lt;/span> &lt;span class="nn">libc.stdlib&lt;/span> &lt;span class="n">cimport&lt;/span> &lt;span class="n">malloc&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kn">import&lt;/span> &lt;span class="nn">numpy&lt;/span> &lt;span class="k">as&lt;/span> &lt;span class="nn">np&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">cdef&lt;/span> &lt;span class="n">struct&lt;/span> &lt;span class="n">buf&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">int&lt;/span> &lt;span class="n">size&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">int&lt;/span> &lt;span class="n">count&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">cdef&lt;/span> &lt;span class="n">buf&lt;/span>&lt;span class="p">[:]&lt;/span> &lt;span class="n">data&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="p">[:&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="n">malloc&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">np&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">array&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">data&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">dtype&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># [(&amp;#39;size&amp;#39;, &amp;#39;&amp;lt;i4&amp;#39;), (&amp;#39;count&amp;#39;, &amp;#39;&amp;lt;i4&amp;#39;)]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div></description></item><item><title>Cython与C/C++的交互</title><link>https://zyxin.xyz/blog/2019-08/CythonInterop/</link><pubDate>Tue, 27 Aug 2019 00:00:00 +0000</pubDate><guid>https://zyxin.xyz/blog/2019-08/CythonInterop/</guid><description>&lt;p>用Cython也用了很有一段时间了，这次就介绍一下它的最重要功能——使用Cython来封装C/C++代码。最基本的封装方法可以参见Cython文档中的相关页面：&lt;a class="link" href="https://cython.readthedocs.io/en/latest/src/userguide/external_C_code.html" target="_blank" rel="noopener"
>Interfacing with External C Code&lt;/a>和&lt;a class="link" href="https://cython.readthedocs.io/en/latest/src/userguide/wrapping_CPlusPlus.html" target="_blank" rel="noopener"
>Using C++ in Cython&lt;/a>，本文介绍主要是比较重要和常用的Cython/C++交互特性，而自定义Python拓展类（而不是封装现有C++）的一些操作可以&lt;a class="link" href="https://cython.readthedocs.io/en/latest/src/tutorial/cdef_classes.html" target="_blank" rel="noopener"
>参考官方教程&lt;/a>。&lt;/p>
&lt;p>封装C++代码时，最重要的关键词就是&lt;code>extern&lt;/code>，在定义函数时使用这个关键字就说明该声明是外部的，而使用&lt;code>cdef extern from&lt;/code>语句就能指定声明对应的头文件。例如如果要封装函数&lt;code>func&lt;/code>，对应的Cython语句是&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="n">cdef&lt;/span> &lt;span class="n">extern&lt;/span> &lt;span class="kn">from&lt;/span> &lt;span class="s2">&amp;#34;func.c&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">void&lt;/span> &lt;span class="n">func&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">int&lt;/span> &lt;span class="n">arg&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="文件结构">文件结构&lt;/h2>
&lt;p>首先讲一下Cython的文件结构。如果你之有一个小模块需要封装的话你可以把所有代码写到同一个&lt;code>pyx&lt;/code>里进行编译，否则的话你就可以利用Cython的目录结构来管理多个层次的代码。Cython的文件一共有三种：&lt;code>pyx&lt;/code>，&lt;a class="link" href="https://cython.readthedocs.io/en/latest/src/userguide/language_basics.html#the-include-statement-and-include-files" target="_blank" rel="noopener"
>&lt;code>pxi&lt;/code>&lt;/a>（&lt;a class="link" href="https://stackoverflow.com/a/45440199" target="_blank" rel="noopener"
>注意与&lt;code>pyi&lt;/code>区分&lt;/a>）和&lt;code>pxd&lt;/code>（&lt;a class="link" href="https://stackabuse.com/differences-between-pyc-pyd-and-pyo-python-files/" target="_blank" rel="noopener"
>注意与&lt;code>pyd&lt;/code>区分&lt;/a>）。&lt;/p>
&lt;p>&lt;code>.pyx&lt;/code>是Cython的源文件，类似于&lt;code>.cpp&lt;/code>文件在C++中的地位，而对应&lt;code>.h&lt;/code>头文件地位的则是&lt;code>pyi&lt;/code>。在Cython中添加&lt;code>import 'header.pyi'&lt;/code>的语句就会将&lt;code>header.pyi&lt;/code>文件中的内容原封不动地直接插入当前位置，这与C++的&lt;code>#include&lt;/code>语句的作用是相同的。而&lt;code>pxd&lt;/code>则是另一套符号化的逻辑，&lt;code>.pxd&lt;/code>文件中只能声明函数、声明类型、不能有函数和类型的定义内容（除了&lt;code>inline&lt;/code>函数外），而在&lt;code>cimport&lt;/code>了&lt;code>pxd&lt;/code>的定义之后当前代码便引入了对应的函数或者类型签名。这个工作方式则更符合C++中头文件的实际用途。定义了&lt;code>pxd&lt;/code>后就可以在多个Cython文件之间共享同一个类型了。&lt;/p>
&lt;p>不过既然涉及了&lt;code>include&lt;/code>语法，就必然要指定类似于C++的引用路径了。&lt;code>pxi&lt;/code>和&lt;code>pxd&lt;/code>文件的引用路径可以&lt;a class="link" href="https://cython.readthedocs.io/en/latest/src/userguide/sharing_declarations.html#search-paths-for-definition-files" target="_blank" rel="noopener"
>在cythonize过程中手动指定&lt;/a>，而&lt;code>pxd&lt;/code>由于是符号化的还可以通过新建&lt;code>__init__.pxd&lt;/code>的方式来实现类似于Python的引用方法。只要在Cython搜索目录下的文件夹中包含&lt;code>__init__.pxd&lt;/code>文件，Cython就会认为这是一个Cython库，之后就可以用&lt;code>cimport&lt;/code>语句通过与Python中&lt;code>import&lt;/code>相类似的语法将对应模块文件（&lt;code>.pxd&lt;/code>文件）引用进来。当然，&lt;code>pxd&lt;/code>文件&lt;a class="link" href="https://cython.readthedocs.io/en/latest/src/userguide/source_files_and_compilation.html#compiling-with-the-cythonize-command" target="_blank" rel="noopener"
>也可以通过命令参数直接导入&lt;/a>。关于如何组织这些文件以及头文件之间的关系，读者可以参考&lt;a class="link" href="https://github.com/cmpute/pcl.py" target="_blank" rel="noopener"
>我写的PCL封装库&lt;/a>和&lt;a class="link" href="https://cython.readthedocs.io/en/latest/src/userguide/sharing_declarations.html" target="_blank" rel="noopener"
>Cython的相关文档&lt;/a>。&lt;/p>
&lt;blockquote>
&lt;p>函数在pxd中的定义不能显式指定默认参数，而是必须用&lt;code>*&lt;/code>代替，例如&lt;code>cdef void func(a=0)&lt;/code>在&lt;code>pxd&lt;/code>中声明的话需要改为&lt;code>cdef void func(a=*)&lt;/code>。&lt;/p>
&lt;/blockquote>
&lt;h2 id="类型封装">类型封装&lt;/h2>
&lt;p>Cython对C++的类型提供了基本可用的封装语法。为什么说基本可用，是因为Cython目前对模板的支持还非常有限，因此实际上可以说Cython只支持到C++98的程度。不过尽管如此，Cython已经能够完成大多数代码的封装需求了。Cython对&lt;code>class&lt;/code>的支持通过&lt;code>cdef cppclass &amp;lt;class-name&amp;gt;&lt;/code>来实现，这里&lt;code>cppclass&lt;/code>关键词是为了和Cython的&lt;code>class&lt;/code>关键词进行区分。Cython中&lt;code>class&lt;/code>关键词代表的是和Python一致的&lt;code>PyObject&lt;/code>对象，代表的是Python类型，而&lt;code>cppclass&lt;/code>则指代C++原生类型，由于Cython文件中无法直接编写C++代码，因此&lt;code>cdef cppclass&lt;/code>语句通常在&lt;code>cdef extern from&lt;/code>的语法块中，用来封装现有的C++类型。另外一点需要注意的地方是Cython&lt;a class="link" href="https://cython.readthedocs.io/en/latest/src/userguide/language_basics.html#c-variable-and-type-definitions" target="_blank" rel="noopener"
>提供封装&lt;code>enum&lt;/code>和&lt;code>struct&lt;/code>的语法&lt;/a>，但是针对的是C中的&lt;code>enum&lt;/code>和&lt;code>struct&lt;/code>，而非C++中的&lt;code>enum class&lt;/code>和&lt;code>struct&lt;/code>（C++中&lt;code>struct&lt;/code>和&lt;code>class&lt;/code>几乎没有区别）。如果要封装C++版本的&lt;code>enum&lt;/code>和&lt;code>struct&lt;/code>可以直接使用&lt;code>cppclass&lt;/code>关键词。以下是封装C++类型的一个例子：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="n">cdef&lt;/span> &lt;span class="n">extern&lt;/span> &lt;span class="kn">from&lt;/span> &lt;span class="s2">&amp;#34;test.h&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">cdef&lt;/span> &lt;span class="n">cppclass&lt;/span> &lt;span class="n">Test&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">void&lt;/span> &lt;span class="nb">print&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="别名与-namespace-关键字">别名与 namespace 关键字&lt;/h3>
&lt;p>由于Cython最后生成的是全局的C代码，因此在引用C++类时需要明确声明类型含命名空间的全称，这里就需要用到别名的机制。Cython允许从&lt;code>.h&lt;/code>文件中导入声明的时候给类型和方法改名字，具体用法如下&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="n">cdef&lt;/span> &lt;span class="n">extern&lt;/span> &lt;span class="kn">from&lt;/span> &lt;span class="s2">&amp;#34;&amp;lt;header-name&amp;gt;&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">cdef&lt;/span> &lt;span class="n">void&lt;/span> &lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">new&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">function&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="s2">&amp;#34;&amp;lt;origin-function-name&amp;gt;&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">pass&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">cdef&lt;/span> &lt;span class="n">cppclass&lt;/span> &lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">new&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">class&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="s2">&amp;#34;&amp;lt;origin-class-name&amp;gt;&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">pass&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>简而言之就是在方法或者类型名称后添加引号，引号里写上原本C++中的名字。这个机制有很多tricky的用法，它可以用来声明带命名空间的方法和类型、可以用来&lt;a class="link" href="https://stackoverflow.com/a/25955546" target="_blank" rel="noopener"
>重命名C++中的运算符&lt;/a>、可以用来直接声明实例化的模板类型、甚至可以用来把C++常量声明成类型用于模板参数（这种操作可以&lt;a class="link" href="https://github.com/wouterboomsma/eigency/blob/master/eigency/core.pxd" target="_blank" rel="noopener"
>参考eigency库中的代码&lt;/a>）。&lt;/p>
&lt;p>其中针对第一种用法，为了简化带有命名空间对象的声明，Cython加入了&lt;code>namespace&lt;/code>关键字。在&lt;code>cdef&lt;/code>语句中添加&lt;code>namespace&lt;/code>从句可以使得Cython编译器默认给其包含的语句块中所有的类型加上对应的命名空间，例如&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="n">cdef&lt;/span> &lt;span class="n">extern&lt;/span> &lt;span class="kn">from&lt;/span> &lt;span class="s2">&amp;#34;test.h&amp;#34;&lt;/span> &lt;span class="n">namespace&lt;/span> &lt;span class="s2">&amp;#34;ns&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">cdef&lt;/span> &lt;span class="n">cppclass&lt;/span> &lt;span class="n">Test&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">pass&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>与以下代码是等价的&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="n">cdef&lt;/span> &lt;span class="n">extern&lt;/span> &lt;span class="kn">from&lt;/span> &lt;span class="s2">&amp;#34;test.h&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">cdef&lt;/span> &lt;span class="n">cppclass&lt;/span> &lt;span class="n">Test&lt;/span> &lt;span class="s2">&amp;#34;ns::Test&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">pass&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="模板支持">模板支持&lt;/h3>
&lt;p>这个特性在&lt;a class="link" href="https://zyxin.xyz/blog/2018-12/CythonTypes/" >之前介绍Cython类型的文章中&lt;/a>也有提到过，这里补充一下它的一些特性。Cython对C++模板的支持通过&lt;code>[]&lt;/code>符号实现，以下是Cython中对&lt;code>vector&lt;/code>的封装代码可供参考&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="n">cdef&lt;/span> &lt;span class="n">extern&lt;/span> &lt;span class="kn">from&lt;/span> &lt;span class="s2">&amp;#34;&amp;lt;vector&amp;gt;&amp;#34;&lt;/span> &lt;span class="n">namespace&lt;/span> &lt;span class="s2">&amp;#34;std&amp;#34;&lt;/span> &lt;span class="n">nogil&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">cdef&lt;/span> &lt;span class="n">cppclass&lt;/span> &lt;span class="n">vector&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">ALLOCATOR&lt;/span>&lt;span class="o">=*&lt;/span>&lt;span class="p">]:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">ctypedef&lt;/span> &lt;span class="n">T&lt;/span> &lt;span class="n">value_type&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">ctypedef&lt;/span> &lt;span class="n">ALLOCATOR&lt;/span> &lt;span class="n">allocator_type&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">...&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>其中&lt;code>vector[T,ALLOCATOR=*]&lt;/code>对应的就是C++中的&lt;code>vector&amp;lt;T, ALLOCATOR&amp;gt;&lt;/code>符号。模板参数在Cython中同样可以有复数个，也可以有默认值，&lt;a class="link" href="https://gist.github.com/bjodah/3cc42d9c5f70a321af29" target="_blank" rel="noopener"
>似乎现在也支持常数作为模板参数&lt;/a>，不过我没有尝试过，而据说老版本是不支持常数模板参数的。&lt;/p>
&lt;p>之前有提到Cython中对模板的支持是阉割过的，主要特征有以下几点：&lt;/p>
&lt;ul>
&lt;li>Cython不支持模板参数的类型声明访问。例如上面的&lt;code>vector&lt;/code>类型声明中不能使用&lt;code>ctypedef allocator_type.size_type size_type&lt;/code>这样的语法，而这样的类型推断在C++中是有很多的。&lt;/li>
&lt;li>Cython不支持模板构造函数中包含新的模板参数
不过Cython一直在改进对模板的支持，因此以后也很有可能会得到改进。&lt;/li>
&lt;/ul>
&lt;h2 id="buffer协议">Buffer协议&lt;/h2>
&lt;p>Cython还针对性地支持了&lt;a class="link" href="https://docs.python.org/3/c-api/buffer.html" target="_blank" rel="noopener"
>Python的Buffer协议&lt;/a>，用来传递一块结构化的内存，这个协议的标准被记录在了&lt;a class="link" href="https://www.python.org/dev/peps/pep-3118/" target="_blank" rel="noopener"
>提案PEP-3118&lt;/a>中。这个协议通过&lt;a class="link" href="https://cython.readthedocs.io/en/latest/src/userguide/buffer.html" target="_blank" rel="noopener"
>&lt;code>__getbuffer__&lt;/code>和&lt;code>__releasebuffer__&lt;/code>&lt;/a>两个Cython自定义的特殊函数实现，通过这个方式Cython代码就可以将C++内存转化为Python识别的内存。因为Numpy支持将支持Buffer协议的对象转换为ndarray，因此这个Buffer协议的通常用法是将一个C++对象变成Numpy的矩阵。具体的使用案例也可以&lt;a class="link" href="https://github.com/cmpute/pcl.py/blob/master/pcl/PointCloud.pyx#L565" target="_blank" rel="noopener"
>参照我的pcl封装库中的对应代码&lt;/a>。&lt;/p>
&lt;hr>
&lt;p>本文介绍了Cython中操作C/C++对象的方法，不过仅仅介绍了一些进阶用法。如果是新手的话还是先参照之前提到两篇文档学习基本的函数、类型封装方法吧～&lt;/p></description></item><item><title>如何选择Python与C++之间的胶水</title><link>https://zyxin.xyz/blog/2019-08/GluePythonCpp/</link><pubDate>Sun, 11 Aug 2019 00:00:00 +0000</pubDate><guid>https://zyxin.xyz/blog/2019-08/GluePythonCpp/</guid><description>&lt;p>Python作为一门胶水语言，它与C/C++之间的兼容性（Interoperability）我认为是它相比其他动态语言脱颖而出的最大原因。Python原生支持的是与C语言的接口，Python的发行版自带有&lt;code>Python.h&lt;/code>头文件，里面提供了在C中调用Python和反过来在Python中调用C的接口定义。但是C++就不一样了，虽然C++ ⇔ C ⇔ Python的通道是可行的，但是想要完整兼容C++的特性的话需要很多额外的重复代码（boilerplate）。因此相应针对Python/C++绑定的库也就应运而生了，我所了解的库主要有四个：&lt;a class="link" href="https://www.boost.org/doc/libs/1_70_0/libs/python/doc/html/index.html" target="_blank" rel="noopener"
>Boost.Python&lt;/a>，&lt;a class="link" href="https://cython.org/" target="_blank" rel="noopener"
>Cython&lt;/a>，&lt;a class="link" href="https://pybind11.readthedocs.io/en/stable/" target="_blank" rel="noopener"
>pybind11&lt;/a>，&lt;a class="link" href="http://www.swig.org/" target="_blank" rel="noopener"
>SWIG&lt;/a>。虽然网上也有不少比较三者的页面，但是我觉得都不够详细，这篇博客就介绍一下我基于使用这几个库的经验比较。&lt;/p>
&lt;p>上面说到的这些库我基本都有接触过，其中用过的有pybind11和Cython，分别用在了我正在写的&lt;a class="link" href="https://github.com/cmpute/cgal.py" target="_blank" rel="noopener"
>CGAL&lt;/a>和&lt;a class="link" href="https://github.com/cmpute/pcl.py" target="_blank" rel="noopener"
>PCL&lt;/a>的绑定上。另外二者则是在其他库的代码中有读过（如Caffe和CGAL的官方绑定）。总的来说，Boost.Python和pybind11主要用于给现有C++代码提供Python绑定，并且不用学习新的语法;SWIG提供一个给C++代码编写多种语言绑定的框架，它本质上是一种代码生成器，基于SWIG自定义的语法;Cython则是基于Python的C/C++代码封装器，其本质也是代码生成器，但是Cython的语法是Python的超集，也就是说Python的代码可以零成本移植到Cython中。&lt;/p>
&lt;h2 id="boostpython-vs-pybind11">Boost.Python vs pybind11&lt;/h2>
&lt;p>Boost.Python是一个Boost框架中封装C++代码的工具，通过宏定义和元编程来简化Python的API调用，消灭bolierplate。Boost.Python还提供对Numpy底层API的封装，因此适用性很强，能满足Python绑定的绝大多数需求。而pybind11则是受Boost.Python启发的一套类似的API，其目标是提供Header-only的易用的Python接口。由于pybind11脱胎于Boost，因此它们的接口非常相似，例如最简单的封装一个函数，Boost.Python代码如下&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;boost/python.hpp&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">j&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">j&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">BOOST_PYTHON_MODULE&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">example&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">using&lt;/span> &lt;span class="k">namespace&lt;/span> &lt;span class="n">boost&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">python&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">def&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;add&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">add&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>而对应的pybind11代码则是&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;pybind11/pybind11.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">j&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">j&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">PYBIND11_MODULE&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">example&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">m&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">m&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">def&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;add&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">add&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>因此熟练掌握这两者之一的开发者能很快上手另一个库的使用。他们的编译方式也是相似的，只需添加一个工程，写好对应的封装代码，然后利用他们的CMake模块进行编译，生成的动态链接库只要文件名正确就可以直接从Python进行import了。他们二者的区别主要有以下几个方面：&lt;/p>
&lt;ol>
&lt;li>pybind11是Header-only的，因此只需把它的头文件添加到include目录就算安装好了。而Boost.Python则是需要先编译安装才能使用，需要处理其依赖。&lt;/li>
&lt;li>pybind11的社区更加活跃，Boost.Python则受限于Boost的更新周期，回应反馈可能会比较慢。&lt;/li>
&lt;li>pybind11的易用性更好，文档齐全且友善，由于没有依赖问题，编译方便上手也快。&lt;/li>
&lt;li>Boost.Python兼容旧特性的C++，也兼容Boost自定义的类型（如smartptr），因此如果需要封装的代码是基于Boost的，那可能Boost.Python会比pybind11合适。pybind11针对的环境则是C++1x，并且只支持标准C++库。&lt;/li>
&lt;li>Boost.Python对Numpy的支持比较完备，例如Boost.Python支持自定义&lt;code>numpy.dtype&lt;/code>，而pybind11对Numpy的支持主要基于Python的buffer协议。
因此基本上如果封装不基于Boost的库的话可以先考虑pybind11，而如果是封装基于Boost的库（如PCL），或者深度操作Numpy，那还是直接上Boost.Python吧～&lt;/li>
&lt;/ol>
&lt;h2 id="boostpythonpybind11-vs-cython">Boost.Python/pybind11 vs Cython&lt;/h2>
&lt;p>这两者的选用其实差别非常大，因为他们的代码逻辑都是不同的。而具体选择哪个库就纯粹是根据需求出发了。他们的区别如下（以下pybind11同时也代表了Boost.Python）&lt;/p>
&lt;ol>
&lt;li>pybind11基于C++，更适合C++工程师。Cython则是基于Python，写习惯的Python的人上手更快，并且能同时方便地兼容Python和C++。&lt;/li>
&lt;li>Cython相比pybind11的环境配置更加简单，用户只需通过pip安装Cython就可以利用Cython的功能了，也无需配置路径。&lt;/li>
&lt;li>Cython封装C++类会比Boost.Python更加繁杂，你需要先定义C++类，再封装成Python类。相当于Cython还多一步翻译头文件的工作。&lt;/li>
&lt;li>Cython支持模板（虽然是阉割版本）！这是Cython独家的一个killer特性，不过是与第3点相关联的。如果你已经翻译好了现有的模板代码，那么用户就可以用Python的语法来自行展开模板了！pybind11需要在编译的时候实例化模板，因此一般只封装常用的实例，或者穷举所有实例化可能（这会导致生成的封装库尺寸爆炸）&lt;/li>
&lt;li>pybind11封装重载函数比Cython要方便太多！Cython封装重载函数的话一般需要定义大量的可选参数和类型判断。&lt;/li>
&lt;li>Cython封装继承类就更加麻烦了，不仅要处理方法重载，还要复制继承关系，十分繁复。&lt;/li>
&lt;li>Cython无法利用上C++的宏定义，这对支持条件编译非常不利，很多时候还需要自己利用&lt;a class="link" href="https://cython.readthedocs.io/en/latest/src/userguide/language_basics.html#conditional-statements" target="_blank" rel="noopener"
>Cython的条件语句&lt;/a>翻译一套条件编译的逻辑。&lt;/li>
&lt;li>Cython似乎在封装上比pybind11性能好，参见&lt;a class="link" href="https://github.com/pybind/pybind11/issues/1227" target="_blank" rel="noopener"
>pybind11#1227&lt;/a>和&lt;a class="link" href="https://github.com/pybind/pybind11/issues/2005" target="_blank" rel="noopener"
>pybind#2005&lt;/a>。如果你的代码需要经常调用封装后的函数，那么选择Cython性能更好。&lt;/li>
&lt;/ol>
&lt;p>以前很多人使用Cython的原因是Cython可以很方便地加速Python代码，但是&lt;code>numba.jit&lt;/code>的出现则让这个功能实际上成了鸡肋，因此Cython最近的使用率也是越来越低了。如果没有很强的对保留模板灵活性的需求，或者不是封装目标不是基于C语言的，那还是选择pybind11来的方便。如果封装接口只是一小部分需求的话也还是用Cython会更加一致，我在自己的PCL绑定项目中使用Cython的原因是有大量基于Python的扩展代码，因此使用Cython还是能更方便。&lt;/p>
&lt;h2 id="swig">SWIG&lt;/h2>
&lt;p>SWIG是个很神奇的东西，他能够将C++代码封装成Python/C#/Java/Ruby等多种语言，但是也正因为这个灵活性，它对C++的高级特性的支持就比较辣鸡了。在&lt;a class="link" href="https://github.com/sciencectn/cgal-bindings" target="_blank" rel="noopener"
>CGAL官方的绑定库&lt;/a>中可以看到有不少代码需要针对Python和Java打补丁，因此如果没有多语言的需求的话SWIG应该是下下策了。这应该也是SWIG一直没啥发展的原因吧～&lt;/p>
&lt;hr>
&lt;p>总而言之，如果有多语言绑定的需求可以选择SWIG，如果有以下需求可以选择Cython，其他情况选择pybind11即可&lt;/p>
&lt;ul>
&lt;li>需要保留模板参数，让用户可以自行选择用什么类型展开，或者目标用户有继续使用和拓展C++ API的需求时，用Cython便于用户使用&lt;/li>
&lt;li>有大量的封装函数调用时，Cython的性能最好&lt;/li>
&lt;li>绑定的对象是C语言写的API或者不涉及面向对象的话，那么用Cython写封装会更方便（不用处理编译的问题）&lt;/li>
&lt;/ul>
&lt;p>本文介绍了Boost.Python/pybin11/Cython/SWIG之间的特性与区别，而具体用法则是一笔带过。如果大家对其中的某工具感兴趣的话可以直接去官网看教程～也欢迎参考我的&lt;a class="link" href="https://zyxin.xyz/blog/blog/tags/Cython/" >Cython系列博客&lt;/a>，以及我的一些Github项目如&lt;a class="link" href="https://github.com/cmpute/pcl.py" target="_blank" rel="noopener"
>pcl.py&lt;/a>，&lt;a class="link" href="https://github.com/cmpute/cgal.py" target="_blank" rel="noopener"
>cgal.py&lt;/a>。&lt;/p></description></item><item><title>Cython中的类型系统</title><link>https://zyxin.xyz/blog/2018-12/CythonTypes/</link><pubDate>Wed, 05 Dec 2018 00:00:00 +0000</pubDate><guid>https://zyxin.xyz/blog/2018-12/CythonTypes/</guid><description>&lt;p>由于最近的几个项目都有接触到Cython的使用，也积累了一些Cython的经验，于是决定把&lt;img src="https://zyxin.xyz/blog/blog/https://zyxin.xyz/blog/2017-12/CythonIntro/"
loading="lazy"
alt="上次的介绍"
>续上（蜜汁发现刚好过了一年。。），将Cython的一些用法记录下来。这一些文章可以作为一些学习的参考，不过kick-start的话还是去看看&lt;a class="link" href="https://zyxin.xyz/blog/2017-12/CythonIntro/" >之前的博文&lt;/a>以及&lt;a class="link" href="http://docs.cython.org/en/latest/src/quickstart/index.html" target="_blank" rel="noopener"
>官方的例子&lt;/a>吧~&lt;/p>
&lt;h2 id="cython对cc内置类型的支持">Cython对C/C++内置类型的支持&lt;/h2>
&lt;p>Cython在类型设置上和C/C++是十分相似的，不仅默认支持基本C类型&lt;code>int&lt;/code>、&lt;code>float&lt;/code>、&lt;code>unsigned long&lt;/code>等等以及他们的指针类型，还支持C的&lt;code>struct&lt;/code>、&lt;code>union&lt;/code>、&lt;code>enum&lt;/code>以及C++的&lt;code>cppclass&lt;/code>（即C++中的类）。需要注意的是在Cython中，定义C/C++对象都需要使用cdef关键字，或者&lt;a class="link" href="https://cython.readthedocs.io/en/latest/src/userguide/early_binding_for_speed.html#early-binding-for-speed" target="_blank" rel="noopener"
>使用cpdef关键字定义一个Python封装过的对象&lt;/a>。另外Cython还通过&lt;code>ctypedef&lt;/code>支持C/C++形式的typedef。下面是一些定义变量的例子：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="n">cdef&lt;/span> &lt;span class="nb">int&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">j&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">k&lt;/span> &lt;span class="c1"># i,j,k是C中的int类型&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">cdef&lt;/span> &lt;span class="nb">float&lt;/span> &lt;span class="n">f&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">g&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">42&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">h&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">cdef&lt;/span> &lt;span class="n">struct&lt;/span> &lt;span class="n">Grail&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="c1"># C形式的结构体&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">int&lt;/span> &lt;span class="n">age&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">float&lt;/span> &lt;span class="n">volume&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">cdef&lt;/span> &lt;span class="n">Grail&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">gp&lt;/span> &lt;span class="c1"># 结构体指针，注意不是cdef struct Grail&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">cdef&lt;/span> &lt;span class="n">enum&lt;/span> &lt;span class="n">CheeseState&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="c1"># C++形式的枚举类&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">hard&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">soft&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">2&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">runny&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">3&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">cdef&lt;/span> &lt;span class="n">enum&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="c1"># C形式的匿名枚举&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">tons_of_spam&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">3&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;blockquote>
&lt;ul>
&lt;li>&lt;code>size_t&lt;/code>和&lt;code>Py_ssize_t&lt;/code>也是受Cython语言支持的类型。如果想使用&lt;code>uint32_t&lt;/code>形式的类型，则需要添加&lt;code>from libc.stdint cimport uint32_t&lt;/code>形式的语句。&lt;/li>
&lt;li>这些变量的作用域定义与Python是相同的，但是cdef定义的对象是不能import到Python代码中的，而cpdef定义的对象则可以。&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="cython对python内置类型的支持">Cython对Python内置类型的支持&lt;/h2>
&lt;p>尽管Cython兼容Python的语法，但是我们还可以通过cdef来使得Python对象具有静态类型，以提高运行效率。Cython在除了支持Python内置的&lt;code>list&lt;/code>、&lt;code>dict&lt;/code>、&lt;code>tuple&lt;/code>外，还支持直接声明Python的基本类型，这需要通过&lt;code>from cpython cimport int&lt;/code>形式的语句来实现。此外有一类特殊的类型是&lt;code>ctuple&lt;/code>，能够直接定义tuple中元素的类型与数量，有些类似于C# 7中的语法，例子如下：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="n">cdef&lt;/span> &lt;span class="nb">dict&lt;/span> &lt;span class="n">sd&lt;/span> &lt;span class="c1"># 直接定义内置类型，实际是PyDict对象&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kn">from&lt;/span> &lt;span class="nn">cpython&lt;/span> &lt;span class="n">cimport&lt;/span> &lt;span class="nb">int&lt;/span> &lt;span class="k">as&lt;/span> &lt;span class="n">pyint&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">cdef&lt;/span> &lt;span class="n">pyint&lt;/span> &lt;span class="n">big_a&lt;/span> &lt;span class="c1"># PyInt对象&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kn">from&lt;/span> &lt;span class="nn">libcpp&lt;/span> &lt;span class="n">cimport&lt;/span> &lt;span class="nb">bool&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">cdef&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nb">int&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">unsigned&lt;/span> &lt;span class="n">long&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">bool&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">table&lt;/span> &lt;span class="c1"># ctuple对象&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="cython的类型映射">Cython的类型映射&lt;/h2>
&lt;p>在将Python的基本类型对象与C/C++的基本类型对象进行相互赋值的过程中，Cython会进行自动的类型转换，可识别的转换规则有：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>C types&lt;/th>
&lt;th>From Python types&lt;/th>
&lt;th>To Python types&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>[unsigned] char, [unsigned] short, int, long&lt;/td>
&lt;td>int, long&lt;/td>
&lt;td>int&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>unsigned int, unsigned long, [unsigned] long long&lt;/td>
&lt;td>int, long&lt;/td>
&lt;td>long&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>float, double, long double&lt;/td>
&lt;td>int, long, float&lt;/td>
&lt;td>float&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>char*&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>&lt;/td>
&lt;td>str/bytes&lt;/td>
&lt;td>str/bytes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>C array&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>&lt;/td>
&lt;td>iterable&lt;/td>
&lt;td>list&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>struct&lt;/td>
&lt;td>union&lt;/td>
&lt;td>dict&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>如果自动类型转换不被支持、或者自动转换类型不是所需类型的话，还可以使用强制类型转换，语法是在变量前加&lt;code>&amp;lt;type-name&amp;gt;&lt;/code>，例如&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="kn">from&lt;/span> &lt;span class="nn">cpython.ref&lt;/span> &lt;span class="n">cimport&lt;/span> &lt;span class="n">PyObject&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">cdef&lt;/span> &lt;span class="n">extern&lt;/span> &lt;span class="kn">from&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">ctypedef&lt;/span> &lt;span class="n">Py_ssize_t&lt;/span> &lt;span class="n">Py_intptr_t&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">python_string&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;foo&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">cdef&lt;/span> &lt;span class="n">void&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">ptr&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">void&lt;/span>&lt;span class="o">*&amp;gt;&lt;/span>&lt;span class="n">python_string&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">cdef&lt;/span> &lt;span class="n">Py_intptr_t&lt;/span> &lt;span class="n">adress_in_c&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Py_intptr_t&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="n">ptr&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;blockquote>
&lt;p>如果使用&lt;code>&amp;lt;type-name?&amp;gt;&lt;/code>形式则会在转换时执行运行时检查&lt;/p>
&lt;/blockquote>
&lt;h2 id="cython中的模板">Cython中的模板&lt;/h2>
&lt;p>Cython还支持C++中的模板，语法是&lt;code>class_name[template_args]&lt;/code>，不过模板参数目前只支持类型参数，因此更像是C#中的泛型。对模板的支持不仅是可以声明模板类，还可以支持绑定已有C++的模板类，这也是Cython区别于Boost.Python、Pybind11等C++端绑定库的重要一点。由于后者在编译期无法了解Python代码的使用需求，因此只能在编译器展开模板（Instantiation），而Cython则可以通过&lt;code>.pxd&lt;/code>头文件保留模板的格式，在引用该库需要编译时再展开。&lt;/p>
&lt;p>模板的应用例子如下：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="kn">from&lt;/span> &lt;span class="nn">libcpp.vector&lt;/span> &lt;span class="n">cimport&lt;/span> &lt;span class="n">vector&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">cdef&lt;/span> &lt;span class="n">vector&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nb">int&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="n">vect&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">cdef&lt;/span> &lt;span class="nb">int&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">x&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">for&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">10&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">vect&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">push_back&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;blockquote>
&lt;p>&lt;strong>参考内容：&lt;/strong>
&lt;a class="link" href="https://cython.readthedocs.io/en/latest/index.html" target="_blank" rel="noopener"
>Cython文档&lt;/a>
&lt;a class="link" href="http://cython.readthedocs.io/en/latest/src/userguide/language_basics.html" target="_blank" rel="noopener"
>Cython文档 - Language Basics&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>Python2中转换成str，Python3中转换成bytes&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2">
&lt;p>char数组除外&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>Cython - 入门简介</title><link>https://zyxin.xyz/blog/2017-12/CythonIntro/</link><pubDate>Tue, 05 Dec 2017 00:00:00 +0000</pubDate><guid>https://zyxin.xyz/blog/2017-12/CythonIntro/</guid><description>&lt;h2 id="python--cc">Python &amp;amp; C/C++&lt;/h2>
&lt;p>近来用Python用的越来越多，对这种十分灵活的动态语言的哲学也有了较深的理解。虽然Python有不少缺点，如没有强类型，GIL全局锁，没有编译因此效率底下，但正因为其动态性，它非常适合写软件的Prototype。因此一种典型而高效的工作流程是&lt;strong>先用Python调用各种轮子，快速实现软件原型，然后再优化代码，将稳定的部分用C++或其他编译语言进行重写，变成一个供调用的库&lt;/strong>。&lt;/p>
&lt;p>在这个过程中就难免碰到Python与C++相互调用的问题，尤其体现在：&lt;/p>
&lt;ol>
&lt;li>在原型开发阶段，如何将现有的C++库封装成Python能够方便调用的库，避免重造轮子&lt;/li>
&lt;li>当原型开发结束后，如何将Python代码高效地转换成其他语言的代码&lt;/li>
&lt;/ol>
&lt;p>能够完成Python与C/C++相互操作的方式有很多，可以参见&lt;a class="link" href="https://zhuanlan.zhihu.com/p/20150641" target="_blank" rel="noopener"
>知乎的这篇专栏&lt;/a>，但是本文介绍的Cython却鲜有详细或通俗的中文资料。Cython是个易用的Python扩展，在Anaconda等发行包里面都自带了，可以用Python的语法写出Python的C语言扩展。因此我选择这一款扩展库学习，之后也会把相关的学习经验写下来~&lt;/p>
&lt;h2 id="安装与基本使用">安装与基本使用&lt;/h2>
&lt;blockquote>
&lt;p>后文中的环境都是在 Windows10 + Visual Studio 2017 下&lt;/p>
&lt;/blockquote>
&lt;p>Cython在流行的Python发行版本中都有被包含，包括&lt;a class="link" href="http://docs.continuum.io/anaconda/" target="_blank" rel="noopener"
>Anaconda&lt;/a>、&lt;a class="link" href="https://enthought.com/products/canopy/" target="_blank" rel="noopener"
>Canopy&lt;/a>、&lt;a class="link" href="http://www.pythonxy.com/" target="_blank" rel="noopener"
>Pythonxy&lt;/a>和&lt;a class="link" href="http://sagemath.org" target="_blank" rel="noopener"
>Sage&lt;/a>等。如果使用普通的Python的话可以使用pip安装：&lt;code>pip install Cython&lt;/code>。&lt;/p>
&lt;h3 id="简单运行cython代码">简单运行Cython代码&lt;/h3>
&lt;p>从语言层面来说，Cython是一种拓展的Python，其文件的扩展名为&lt;code>.pyx&lt;/code>。这种类型的文件通过编译之后可以变成供Python直接调用的动态链接库（Linux/Mac下是&lt;code>.so&lt;/code>，Windows下是&lt;code>.pyd&lt;/code>）。根据官方文档，主要如下几编译方式：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>(推荐)&lt;/strong> 通过&lt;code>setup.py&lt;/code>中调用&lt;code>Cython.Build&lt;/code>进行编译&lt;/li>
&lt;li>使用&lt;code>pyximport&lt;/code>调用&lt;code>.pyx&lt;/code>文件，这种方法&lt;code>.pyx&lt;/code>文件相当于普通的&lt;code>.py&lt;/code>文件&lt;/li>
&lt;li>在命令行使用&lt;code>cython&lt;/code>命令从&lt;code>.pyx&lt;/code>文件生成&lt;code>.c&lt;/code>文件，再使用外部编译器将&lt;code>.c&lt;/code>文件编译成Python可用的库&lt;/li>
&lt;li>使用&lt;code>Jupyter Notebook&lt;/code>或者&lt;code>Sage Notebook&lt;/code>直接运行Cython代码&lt;/li>
&lt;/ol>
&lt;p>这上面四种方法里&lt;strong>最简单的是第三种方法&lt;/strong>。运行&lt;code>cythonize -i &amp;lt;.pyx File&amp;gt;&lt;/code>即可编译&lt;code>.pyx&lt;/code>成二进制库，并保存在与&lt;code>.pyx&lt;/code>文件相同的目录下。&lt;code>cythonize&lt;/code>命令有其他的参数，可以通过命令行查看。这个命令也可以通过&lt;code>python -m Cython.Build.Cythonize -i &amp;lt;.pyx File&amp;gt;&lt;/code>来完成。&lt;/p>
&lt;p>不过推荐使用的是第一种方法，原理也就是通过指定&lt;code>distutils&lt;/code>或者&lt;code>setuptools&lt;/code>库中的&lt;code>ext_modules&lt;/code>参数来编译Cython代码。以&lt;a class="link" href="http://docs.cython.org/en/latest/src/quickstart/build.html#building-a-cython-module-using-distutils" target="_blank" rel="noopener"
>官方示例&lt;/a>为例，它的&lt;code>setup.py&lt;/code>文件如下&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="kn">from&lt;/span> &lt;span class="nn">distutils.core&lt;/span> &lt;span class="kn">import&lt;/span> &lt;span class="n">setup&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kn">from&lt;/span> &lt;span class="nn">Cython.Build&lt;/span> &lt;span class="kn">import&lt;/span> &lt;span class="n">cythonize&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">setup&lt;/span>&lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">name&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s1">&amp;#39;Hello world app&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">ext_modules&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">cythonize&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;hello.pyx&amp;#34;&lt;/span>&lt;span class="p">),&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>其中&lt;code>hello.pyx&lt;/code>的代码为&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">say_hello_to&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;Hello &lt;/span>&lt;span class="si">%s&lt;/span>&lt;span class="s2">!&amp;#34;&lt;/span> &lt;span class="o">%&lt;/span> &lt;span class="n">name&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>编辑保存之后直接运行&lt;code>python setup.py build_ext --inplace&lt;/code>即可进行编译。其中&lt;code>--inplace&lt;/code>参数可以让对应的链接库生成在源代码所在的目录。&lt;/p>
&lt;p>编译中可能遇到的问题有&lt;/p>
&lt;ul>
&lt;li>&lt;code>error: command 'cl.exe' failed: No such file or directory&lt;/code>: 这说明在环境中没有找到C编译器。由于我电脑中安装了Visual Studio，我的解决方法是根据平台使用VS的&lt;strong>x86 Native Command Prompt&lt;/strong>或&lt;strong>x64 Native Command Prompt&lt;/strong>来运行编译命令。此外还可以选择通过&lt;code>python setup.py build_ext --inplace --compiler=mingw32&lt;/code>使用Anaconda内置的MinGW32编译器，不过这种情况下还可能会遇到&lt;a class="link" href="https://stackoverflow.com/questions/24683305/python-cant-install-packages-typeerror-unorderable-types-nonetype-str" target="_blank" rel="noopener"
>内置MinGW32的问题&lt;/a>，具体的解决方法在链接里。&lt;/li>
&lt;/ul>
&lt;p>编译之后直接通过&lt;code>import hello&lt;/code>或&lt;code>from hello import say_hello_to&lt;/code>即可调用这个编译好的库。&lt;/p>
&lt;h3 id="复杂cython工程的setuppy">复杂Cython工程的setup.py&lt;/h3>
&lt;p>如果的Cython工程中有很多&lt;code>.pyx&lt;/code>文件，甚至有很多&lt;code>.cpp&lt;/code>文件需要编译，那么这时候最好使用&lt;code>setup.py&lt;/code>进行编译，并使用&lt;code>Cython.Build.cythonize&lt;/code>模块。具体编写方式如下：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="kn">from&lt;/span> &lt;span class="nn">distutils.core&lt;/span> &lt;span class="kn">import&lt;/span> &lt;span class="n">setup&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kn">from&lt;/span> &lt;span class="nn">distutils.extension&lt;/span> &lt;span class="kn">import&lt;/span> &lt;span class="n">Extension&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kn">from&lt;/span> &lt;span class="nn">Cython.Build&lt;/span> &lt;span class="kn">import&lt;/span> &lt;span class="n">cythonize&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">extensions&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Extension&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;Module Name&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;file1.pyx&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;file2.cpp&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">...&lt;/span>&lt;span class="p">],&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">include_dirs&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="o">...&lt;/span>&lt;span class="p">],&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">libraries&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="o">...&lt;/span>&lt;span class="p">],&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">library_dirs&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="o">...&lt;/span>&lt;span class="p">]),&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Extension&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;Module 2&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">...&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">setup&lt;/span>&lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">name&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;XXX&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">ext_modules&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">cythonize&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">extensions&lt;/span>&lt;span class="p">),&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>最后的&lt;code>setup&lt;/code>部分还有另一种写法：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="n">setup&lt;/span>&lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">name&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;XXX&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">ext_modules&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">extensions&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">cmdclass&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="s1">&amp;#39;build_ext&amp;#39;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Cython&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">Build&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">build_ext&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这样的写法可以让安装整个库的时候一起执行掉Cython代码的编译和安装。此外，如果要在编译&lt;code>.pyx&lt;/code>和&lt;code>.cpp&lt;/code>时指定语言或者编译参数，在&lt;code>Extension&lt;/code>类的构造函数中添加合适的参数即可。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>本文介绍了Cython的安装与初步使用，看完以后就已经可以动手试试写Cython代码啦~Cython语言的特性也有不少，掌握其中的一小部分就能大大提高你的Python代码的运行效率！这些内容将会在之后的文章中讲述~&lt;/p>
&lt;blockquote>
&lt;p>Cython的完整介绍可以参考&lt;a class="link" href="http://cython.org/" target="_blank" rel="noopener"
>Cython官网&lt;/a>
Cython代码的编译还有其他方法，参见&lt;a class="link" href="http://docs.cython.org/en/latest/src/reference/compilation.html" target="_blank" rel="noopener"
>Cython文档的编译部分&lt;/a>&lt;/p>
&lt;/blockquote></description></item></channel></rss>