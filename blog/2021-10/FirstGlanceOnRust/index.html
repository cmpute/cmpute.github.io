<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="近些年一直有听闻Rust的发展，相比其他新语言（如julia），我觉得Rust是切实解决了一些程序开发的痛点的，并且Rust比较适合作为底层"><title>初识Rust - 从一个Python/C++/C#程序员的角度对比Rust</title><link rel=canonical href=https://zyxin.xyz/blog/2021-10/FirstGlanceOnRust/><link rel=stylesheet href=/blog/scss/style.min.5be32ca3f6e1a997c75795c4359147cc6d4fbd34948c0acd51e31d237033978a.css><meta property="og:title" content="初识Rust - 从一个Python/C++/C#程序员的角度对比Rust"><meta property="og:description" content="近些年一直有听闻Rust的发展，相比其他新语言（如julia），我觉得Rust是切实解决了一些程序开发的痛点的，并且Rust比较适合作为底层"><meta property="og:url" content="https://zyxin.xyz/blog/2021-10/FirstGlanceOnRust/"><meta property="og:site_name" content="JacobZ"><meta property="og:type" content="article"><meta property="article:section" content="Post"><meta property="article:tag" content="Rust"><meta property="article:tag" content="Python"><meta property="article:tag" content="C++"><meta property="article:tag" content="C#"><meta property="article:tag" content="Comparison"><meta property="article:published_time" content="2021-10-29T00:00:00+00:00"><meta property="article:modified_time" content="2021-10-29T00:00:00+00:00"><meta name=twitter:title content="初识Rust - 从一个Python/C++/C#程序员的角度对比Rust"><meta name=twitter:description content="近些年一直有听闻Rust的发展，相比其他新语言（如julia），我觉得Rust是切实解决了一些程序开发的痛点的，并且Rust比较适合作为底层"><link rel="shortcut icon" href=/img/icon16.png></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label=切换菜单>
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/blog><img src=/blog/img/avatar_hua7c33bdc6ff69af7d15e47ee16119217_164168_300x0_resize_box_3.png width=300 height=300 class=site-logo loading=lazy alt=Avatar></a>
<span class=emoji>🐈</span></figure><div class=site-meta><h1 class=site-name><a href=/blog>JacobZ</a></h1><h2 class=site-description>的博客</h2></div></header><ol class=social-menu><li><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank title=GitHub rel=me><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=https://www.last.fm/user/cmpute target=_blank title=Last.fm rel=me><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-radio" width="44" height="44" viewBox="0 0 24 24" stroke-width="1.5" stroke="#2c3e50" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M14 3 4.629 6.749A1 1 0 004 7.677V19a1 1 0 001 1h14a1 1 0 001-1V8a1 1 0 00-1-1H4.5"/><path d="M4 12h16"/><path d="M7 12v-2"/><path d="M17 16v.01"/><path d="M13 16v.01"/></svg></a></li><li><a href=mailto:cmpute@foxmail.com target=_blank title=Mail rel=me><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-mail" width="44" height="44" viewBox="0 0 24 24" stroke-width="1.5" stroke="#2c3e50" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><rect x="3" y="5" width="18" height="14" rx="2"/><polyline points="3 7 12 13 21 7"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/blog/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg><span>主页</span></a></li><li><a href=/blog/about/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg><span>关于</span></a></li><li><a href=/blog/archives/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg><span>归档</span></a></li><li><a href=/blog/search/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg><span>搜索</span></a></li><div class=menu-bottom-section><li id=i18n-switch><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-language" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M4 5h7"/><path d="M9 3v2c0 4.418-2.239 8-5 8"/><path d="M5 9c-.003 2.144 2.952 3.908 6.7 4"/><path d="M12 20l4-9 4 9"/><path d="M19.1 18h-6.2"/></svg><select name=language onchange="window.location.href=this.selectedOptions[0].value"><option value=https://zyxin.xyz/blog/en/>English</option><option value=https://zyxin.xyz/blog/ selected>中文</option></select></li><li id=dark-mode-toggle><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><span>暗色模式</span></li></div></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">目录</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#语法>语法</a><ol><li><a href=#赋值>赋值</a></li><li><a href=#初始化>初始化</a></li><li><a href=#只读>只读</a></li><li><a href=#全局变量静态成员>全局变量、静态成员</a></li><li><a href=#异常处理>异常处理：</a></li><li><a href=#空变量空类型>空变量，空类型</a></li><li><a href=#别名>别名</a></li><li><a href=#函数声明>函数声明</a></li><li><a href=#语法糖><code>?</code>语法糖</a></li><li><a href=#unicode-字符串>Unicode 字符串</a></li><li><a href=#宏>宏</a></li><li><a href=#修饰器>修饰器</a></li></ol></li><li><a href=#类型系统>类型系统</a><ol><li><a href=#定义成员函数methodmember-function>定义成员函数（method/member function）</a></li><li><a href=#强弱类型>强/弱类型</a></li><li><a href=#类型推断>类型推断</a></li><li><a href=#动态类型>动态类型</a></li><li><a href=#反射内省>反射/内省</a></li></ol></li><li><a href=#面向对象>面向对象</a><ol><li><a href=#封装>封装</a></li><li><a href=#继承多态>继承、多态</a></li><li><a href=#泛型>泛型</a></li></ol></li><li><a href=#函数式编程>函数式编程</a><ol><li><a href=#函数对象和闭包>函数对象和闭包</a></li><li><a href=#模式匹配>模式匹配</a></li><li><a href=#遍历器iterator>遍历器（iterator）</a></li><li><a href=#元组tuple>元组（tuple）</a></li></ol></li><li><a href=#不安全代码c交互>不安全代码、C交互</a></li><li><a href=#并行和异步>并行和异步</a><ol><li><a href=#异步和协程>异步和协程</a></li><li><a href=#线程>线程</a></li><li><a href=#进程>进程</a></li></ol></li><li><a href=#包管理器>包管理器</a></li><li><a href=#常用数据结构>常用数据结构</a></li><li><a href=#rust特有的特性>Rust特有的特性</a></li></ol></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/blog/categories/Coding/>Coding</a>
<a href=/blog/categories/Language/>Language</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/blog/2021-10/FirstGlanceOnRust/>初识Rust - 从一个Python/C++/C#程序员的角度对比Rust</a></h2></div><footer class=article-time><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg><time class=article-time--published>2021-10-29</time></div><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><time class=article-time--reading>阅读时长: 22 分钟</time></div></footer></div></header><section class=article-content><p>近些年一直有听闻Rust的发展，相比其他新语言（如julia），我觉得Rust是切实解决了一些程序开发的痛点的，并且Rust比较适合作为底层软件开发的语言，我很感兴趣。Rust官方有一本<a class=link href=https://doc.rust-lang.org/stable/book/ target=_blank rel=noopener>Gitbook教程</a>，因此我就直接通过阅读它来上手Rust了。</p><p>本文记录一些我在看完这本书之后初步总结的一些Rust与我熟悉的Python/C++/C#之间的各方面的异同。如果你也有Python/C++/C#的编程经验，并且想上手Rust，那么这篇文章应该能帮助你概括性地了解Rust的特性。本文也是我对Python/C++/C#之间特性的一个对比总结，但是我对这些语言的了解也没有那么深，因此如有谬误还请指教。</p><blockquote><p>备注：</p><ul><li>本文中的代码仅为代码片段，对于Python之外的代码你可能需要将部分代码放在主函数中才能正确运行。</li><li>本文的代码格式以精简为主，没有按照语言的标准格式编写。</li></ul></blockquote><h2 id=语法>语法</h2><h3 id=赋值>赋值</h3><p>在变量进行赋值的时候，内容的传递有三种模式：传引用、复制、移动。其中最后一种指的是旧内容被复制到新对象中，然后旧对象中的内容变为不可用。</p><ul><li><strong>Python</strong>: 是传引用</li><li><strong>C#</strong>: 引用类型是传引用、值类型是复制</li><li><strong>C</strong>: 都是复制，但是是浅复制</li><li><strong>C++</strong>: 默认是复制，但是可以通过<code>std::move</code>实现移动（需要C++11)</li><li><strong>Rust</strong>: 默认是移动。复制需要使用<code>.clone()</code></li></ul><h3 id=初始化>初始化</h3><p>这几种语言初始化一个对象的语法有不少相似之处，因此列举在这里供比较。
{% tabs Function Code Example %}</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1>##### initialize class instance #####</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Point</span><span class=p>:</span>
</span></span><span class=line><span class=cl>  <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=bp>self</span><span class=o>.</span><span class=n>x</span> <span class=o>=</span> <span class=n>x</span>
</span></span><span class=line><span class=cl>    <span class=bp>self</span><span class=o>.</span><span class=n>y</span> <span class=o>=</span> <span class=n>y</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>p</span> <span class=o>=</span> <span class=n>Point</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>##### intialize array #####</span>
</span></span><span class=line><span class=cl><span class=n>arr</span> <span class=o>=</span> <span class=p>[</span><span class=n>Point</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>)]</span> <span class=o>*</span> <span class=mi>10</span>  <span class=c1># use list algorithmic operator</span>
</span></span><span class=line><span class=cl><span class=n>arr</span> <span class=o>=</span> <span class=p>[</span><span class=n>Point</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>)</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>10</span><span class=p>)]</span>  <span class=c1># use list comprehension</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>///// initialize struct instance /////
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>typedef</span> <span class=k>struct</span> <span class=n>Point</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>double</span> <span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>Point_t</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// declare and initialize
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Point_t</span> <span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>p</span><span class=p>.</span><span class=n>x</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>p</span><span class=p>.</span><span class=n>y</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>// bracket initialization
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Point_t</span> <span class=n>q</span> <span class=o>=</span> <span class=p>{</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>2</span> <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=n>Point_t</span> <span class=n>r</span> <span class=o>=</span> <span class=p>{</span> <span class=p>.</span><span class=n>x</span> <span class=o>=</span> <span class=mi>1</span><span class=p>,</span> <span class=p>.</span><span class=n>y</span> <span class=o>=</span> <span class=mi>2</span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=c1>// initialize on heap
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Point_t</span> <span class=o>*</span><span class=n>s</span> <span class=o>=</span> <span class=p>(</span><span class=n>Point_t</span> <span class=o>*</span><span class=p>)</span><span class=nf>malloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=n>Point_t</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=n>s</span><span class=o>-&gt;</span><span class=n>x</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>s</span><span class=o>-&gt;</span><span class=n>y</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>///// initialize array /////
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Point_t</span> <span class=n>arr</span><span class=p>[</span><span class=mi>10</span><span class=p>];</span> <span class=c1>// declare without initialization
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Point_t</span> <span class=n>arr2</span><span class=p>[</span><span class=mi>5</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span> <span class=p>{.</span><span class=n>x</span> <span class=o>=</span> <span class=mi>1</span><span class=p>,</span> <span class=p>.</span><span class=n>y</span> <span class=o>=</span> <span class=mi>2</span><span class=p>},</span> <span class=p>{.</span><span class=n>x</span> <span class=o>=</span> <span class=mi>3</span><span class=p>,</span> <span class=p>.</span><span class=n>y</span> <span class=o>=</span> <span class=mi>4</span><span class=p>}</span> <span class=p>};</span> <span class=c1>// initializer, here the third value is uninitialized
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Point_t</span> <span class=n>arr3</span><span class=p>[]</span> <span class=o>=</span> <span class=p>{</span> <span class=p>{.</span><span class=n>x</span> <span class=o>=</span> <span class=mi>1</span><span class=p>,</span> <span class=p>.</span><span class=n>y</span> <span class=o>=</span> <span class=mi>2</span><span class=p>}</span> <span class=p>};</span> <span class=c1>// the size of array is inferred to be 1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Point_t</span> <span class=n>arr4</span><span class=p>[</span><span class=mi>5</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span> <span class=p>{.</span><span class=n>x</span> <span class=o>=</span> <span class=mi>1</span><span class=p>,</span> <span class=p>.</span><span class=n>y</span> <span class=o>=</span> <span class=mi>2</span><span class=p>},</span> <span class=p>[</span><span class=mi>1</span> <span class=p>...</span> <span class=mi>4</span><span class=p>]</span> <span class=o>=</span> <span class=p>{.</span><span class=n>x</span> <span class=o>=</span> <span class=mi>3</span><span class=p>,</span> <span class=p>.</span><span class=n>y</span> <span class=o>=</span> <span class=mi>4</span><span class=p>}</span> <span class=p>};</span> <span class=c1>// range initialize 2nd ~ 5th item
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>arr_2d</span><span class=p>[</span><span class=mi>3</span><span class=p>][</span><span class=mi>3</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span><span class=mi>1</span><span class=p>,</span><span class=mi>2</span><span class=p>,</span><span class=mi>3</span><span class=p>,</span><span class=mi>4</span><span class=p>,</span><span class=mi>5</span><span class=p>,</span><span class=mi>6</span><span class=p>,</span><span class=mi>7</span><span class=p>,</span><span class=mi>8</span><span class=p>,</span><span class=mi>9</span><span class=p>};</span> <span class=c1>// you can even initialize 2D array with bracket initialization
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>arr2_2d</span><span class=p>[</span><span class=mi>3</span><span class=p>][</span><span class=mi>3</span><span class=p>]</span> <span class=o>=</span> <span class=p>{{</span><span class=mi>1</span><span class=p>,</span><span class=mi>2</span><span class=p>,</span><span class=mi>3</span><span class=p>},{</span><span class=mi>4</span><span class=p>,</span><span class=mi>5</span><span class=p>,</span><span class=mi>6</span><span class=p>},{</span><span class=mi>7</span><span class=p>,</span><span class=mi>8</span><span class=p>,</span><span class=mi>9</span><span class=p>}};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// declare the array on heap with 5 items
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Point_t</span> <span class=o>*</span><span class=n>arr5</span> <span class=o>=</span> <span class=p>(</span><span class=n>Point_t</span> <span class=o>*</span><span class=p>)</span><span class=nf>malloc</span><span class=p>(</span><span class=mi>5</span> <span class=o>*</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>Point_t</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=nf>free</span><span class=p>(</span><span class=n>arr5</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>///// initialize class instance /////
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>Point</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=kt>double</span> <span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=c1>// C++ will create default constructors with no args, field args and initializer list
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// declare and initialize
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Point</span> <span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>p</span><span class=p>.</span><span class=n>x</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>p</span><span class=p>.</span><span class=n>y</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>// direct initialize
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Point</span> <span class=nf>q</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// initializer
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Point</span> <span class=n>r</span> <span class=p>{</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>2</span> <span class=p>};</span> <span class=c1>// list initializer (C++11)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Point</span> <span class=n>s</span> <span class=p>{</span> <span class=p>.</span><span class=n>x</span> <span class=o>=</span> <span class=mi>1</span><span class=p>,</span> <span class=p>.</span><span class=n>y</span> <span class=o>=</span> <span class=mi>2</span> <span class=p>};</span> <span class=c1>// aggregate initializer (C++20)
</span></span></span><span class=line><span class=cl><span class=c1>// initialize on heap
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Point</span> <span class=o>*</span><span class=n>t</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Point</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>Point</span> <span class=o>*</span><span class=n>u</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Point</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>///// initialize array /////
</span></span></span><span class=line><span class=cl><span class=c1>// C++ supports all initialization method from C, but you might need C++11/20
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// declare the array on heap with 5 items
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Point</span><span class=o>*</span> <span class=n>arr</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Point</span><span class=p>[</span><span class=mi>5</span><span class=p>]{</span> <span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>}</span> <span class=p>};</span> <span class=c1>// all initializer syntax can be used here
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>delele</span><span class=p>[]</span> <span class=n>arr</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=cs>///// initialize class instance /////</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Point</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>public</span> <span class=kt>double</span> <span class=n>X</span> <span class=p>{</span> <span class=k>get</span><span class=p>;</span> <span class=k>set</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>public</span> <span class=kt>double</span> <span class=n>Y</span> <span class=p>{</span> <span class=k>get</span><span class=p>;</span> <span class=k>set</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=n>Point</span><span class=p>()</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>  <span class=n>Point</span><span class=p>(</span><span class=kt>double</span> <span class=n>x</span><span class=p>,</span> <span class=kt>double</span> <span class=n>y</span><span class=p>)</span> <span class=p>{</span> <span class=n>X</span> <span class=p>=</span> <span class=n>x</span><span class=p>;</span> <span class=n>Y</span> <span class=p>=</span> <span class=n>y</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// declare and initialize</span>
</span></span><span class=line><span class=cl><span class=n>Point</span> <span class=n>p</span> <span class=p>=</span> <span class=k>new</span> <span class=n>Point</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=n>p</span><span class=p>.</span><span class=n>x</span> <span class=p>=</span> <span class=m>1</span><span class=p>;</span> <span class=n>p</span><span class=p>.</span><span class=n>y</span> <span class=p>=</span> <span class=m>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>// constructor</span>
</span></span><span class=line><span class=cl><span class=n>Point</span> <span class=n>q</span> <span class=p>=</span> <span class=k>new</span> <span class=n>Point</span><span class=p>(</span><span class=m>1</span><span class=p>,</span> <span class=m>2</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>Point</span> <span class=n>r</span> <span class=p>=</span> <span class=k>new</span> <span class=n>Point</span> <span class=p>{</span> <span class=n>X</span> <span class=p>=</span> <span class=m>1</span><span class=p>,</span> <span class=n>Y</span> <span class=p>=</span> <span class=m>2</span> <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=c1>// anonymous type</span>
</span></span><span class=line><span class=cl><span class=kt>var</span> <span class=n>s</span> <span class=p>=</span> <span class=k>new</span> <span class=p>{</span> <span class=n>X</span> <span class=p>=</span> <span class=m>1</span><span class=p>,</span> <span class=n>Y</span> <span class=p>=</span> <span class=m>2</span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cs>///// initialize array /////</span>
</span></span><span class=line><span class=cl><span class=n>Point</span><span class=p>[]</span> <span class=n>arr</span> <span class=p>=</span> <span class=k>new</span> <span class=n>Point</span><span class=p>[</span><span class=m>3</span><span class=p>];</span> <span class=c1>// new array with null values (or default value for struct type)</span>
</span></span><span class=line><span class=cl><span class=n>Point</span><span class=p>[]</span> <span class=n>arr2</span> <span class=p>=</span> <span class=k>new</span> <span class=n>Point</span><span class=p>[</span><span class=m>3</span><span class=p>]</span> <span class=p>{</span> <span class=n>p</span><span class=p>,</span> <span class=n>q</span><span class=p>,</span> <span class=n>r</span> <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=n>Point</span><span class=p>[,]</span> <span class=n>arr2d</span> <span class=p>=</span> <span class=k>new</span> <span class=n>Point</span><span class=p>[</span><span class=m>2</span><span class=p>,</span> <span class=m>2</span><span class=p>]</span> <span class=p>{</span> <span class=p>{</span><span class=n>p</span><span class=p>,</span> <span class=n>q</span><span class=p>},</span> <span class=p>{</span><span class=n>r</span><span class=p>,</span> <span class=n>r</span><span class=p>}</span> <span class=p>};</span> <span class=c1>// initialize 2d array</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>var</span> <span class=n>numbers</span> <span class=p>=</span> <span class=k>new</span> <span class=n>Dictionary</span><span class=p>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=kt>string</span><span class=p>&gt;</span> <span class=c1>// initialize object with indexers</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=na>    [7]</span> <span class=p>=</span> <span class=s>&#34;seven&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=na>    [9]</span> <span class=p>=</span> <span class=s>&#34;nine&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=na>    [13]</span> <span class=p>=</span> <span class=s>&#34;thirteen&#34;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=c1>///// initialize struct instance /////
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=nc>Point</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>x</span>: <span class=kt>f64</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>y</span>: <span class=kt>f64</span>
</span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>p</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Point</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>x</span>: <span class=mf>1.</span><span class=p>,</span><span class=w> </span><span class=n>y</span>: <span class=mf>2.</span><span class=w> </span><span class=p>};</span><span class=w> </span><span class=c1>// rust don&#39;t automatically cast the type
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span><span class=w> </span><span class=n>q</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Point</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>x</span>: <span class=mf>2.</span><span class=p>,</span><span class=w> </span><span class=o>..</span><span class=n>p</span><span class=w> </span><span class=p>};</span><span class=w> </span><span class=c1>// partial copy from another instance
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mf>2.</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>r</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Point</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>x</span><span class=p>,</span><span class=w> </span><span class=n>y</span>: <span class=mf>2.</span><span class=w> </span><span class=p>};</span><span class=w> </span><span class=c1>// using the variable with the same name in scope
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>///// initialize array /////
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span><span class=w> </span><span class=n>_</span>: <span class=p>[</span><span class=kt>u8</span><span class=p>;</span><span class=w> </span><span class=mi>3</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>[</span><span class=mi>1</span><span class=p>,</span><span class=w> </span><span class=mi>2</span><span class=p>,</span><span class=w> </span><span class=mi>3</span><span class=p>];</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>arr</span>: <span class=p>[</span><span class=n>Point</span><span class=p>;</span><span class=w> </span><span class=mi>3</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>[</span><span class=w> </span><span class=n>p</span><span class=p>,</span><span class=w> </span><span class=n>q</span><span class=p>,</span><span class=w> </span><span class=n>r</span><span class=w> </span><span class=p>];</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>{% endtabs %}</p><h3 id=只读>只读</h3><ul><li><strong>Python</strong>： 没有什么东西是只读的，你唯一能做的就是hack一些函数，让别人在修改的时候报错</li><li><strong>C</strong>: 有<code>const</code>关键字，可以定义全局常量或者函数内常量</li><li><strong>C++</strong>: 有<code>const</code>，<code>constexpr</code>（后者更接近C的<code>const</code>，需要C++11），成员函数可以单独控制只读性，相当于可以对成员函数的<code>this</code>参数加上<code>const</code></li><li><strong>C#</strong>: 有<code>readonly</code>, <code>const</code>，前者修饰不变量而后者是编译器常量。C# 9引入了record，可以实现immutable。</li><li><strong>Rust</strong>: 变量默认都是不可变的，可变需要添加关键字<code>mut</code>（这个名字可太迷惑了，默认不可变的东西是不是不应该叫变量），成员函数可以通过外置定义的第一个参数单独控制只读性(<code>self&</code> / <code>mut self&</code>)，这个逻辑类似C++</li></ul><p>{% tabs Const Code Example %}</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># usually people follow certain style (like all uppercase) to name the constant variable</span>
</span></span><span class=line><span class=cl><span class=n>SOME_CONSTANT</span> <span class=o>=</span> <span class=mi>1</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span> <span class=n>SOME_CONSTANT</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// constexpr is used for compile time constant
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>constexpr</span> <span class=kt>int</span> <span class=n>SOME_CONSTANT</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>constexpr</span> <span class=kt>int</span> <span class=nf>constexpr_func</span><span class=p>()</span> <span class=p>{</span> <span class=k>return</span> <span class=mi>1</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// const can be used to describe class members
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>Coords</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>shift</span> <span class=p>(</span><span class=k>const</span> <span class=n>Coords</span> <span class=o>&amp;</span><span class=n>offset</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>double</span> <span class=nf>sum</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=n>_x</span> <span class=o>+</span> <span class=n>_y</span><span class=p>;</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=kt>double</span> <span class=n>_x</span><span class=p>,</span> <span class=n>_y</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Coords</span><span class=p>(</span><span class=kt>double</span> <span class=n>x</span><span class=p>,</span> <span class=kt>double</span> <span class=n>y</span><span class=p>)</span> <span class=o>:</span> <span class=n>_x</span><span class=p>(</span><span class=n>x</span><span class=p>),</span> <span class=n>_y</span><span class=p>(</span><span class=n>y</span><span class=p>)</span> <span class=p>{}</span> <span class=c1>// const field must be initialized using initializer list
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// const variables are only able to call const member function
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>const</span> <span class=n>Coords</span> <span class=n>coord</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>coord</span><span class=p>.</span><span class=n>sum</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=c1>// coord.shift() is illegal here
</span></span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=c1>// `const` is used for compile time constant</span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span> <span class=n>SOME_CONSTANT</span> <span class=p>=</span> <span class=m>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>SomeType</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>public</span> <span class=k>const</span> <span class=kt>int</span> <span class=n>const_field</span> <span class=p>=</span> <span class=m>1</span><span class=p>;</span> <span class=c1>// the value still need to be defined in compile time</span>
</span></span><span class=line><span class=cl>  <span class=k>private</span> <span class=k>readonly</span> <span class=kt>string</span> <span class=n>const_field2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>SomeType</span><span class=p>(</span><span class=kt>string</span> <span class=n>str_in</span><span class=p>)</span> <span class=p>{</span> <span class=n>const_field2</span> <span class=p>=</span> <span class=n>str_in</span><span class=p>;</span> <span class=p>}</span> <span class=c1>// readonly field must be initialized in declaration or constructor</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// since C# 7.2, readonly can be used to declare immutable type</span>
</span></span><span class=line><span class=cl><span class=k>public</span> <span class=k>readonly</span> <span class=k>struct</span> <span class=nc>Coords</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>public</span> <span class=n>Coords</span><span class=p>(</span><span class=kt>double</span> <span class=n>x</span><span class=p>,</span> <span class=kt>double</span> <span class=n>y</span><span class=p>)</span> <span class=p>{</span> <span class=n>X</span> <span class=p>=</span> <span class=n>x</span><span class=p>;</span> <span class=n>Y</span> <span class=p>=</span> <span class=n>y</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>public</span> <span class=kt>double</span> <span class=n>X</span> <span class=p>{</span> <span class=k>get</span><span class=p>;</span> <span class=k>init</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>public</span> <span class=kt>double</span> <span class=n>Y</span> <span class=p>{</span> <span class=k>get</span><span class=p>;</span> <span class=k>init</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>public</span> <span class=k>readonly</span> <span class=kt>double</span> <span class=n>Sum</span><span class=p>()</span> <span class=p>{</span> <span class=k>return</span> <span class=n>X</span> <span class=p>+</span> <span class=n>Y</span><span class=p>;</span> <span class=p>}</span> <span class=c1>// C# 8.0</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// alternatively readonly can be applied to properties individually</span>
</span></span><span class=line><span class=cl><span class=k>public</span> <span class=k>struct</span> <span class=nc>Coords</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>public</span> <span class=n>Coords</span><span class=p>(</span><span class=kt>double</span> <span class=n>x</span><span class=p>,</span> <span class=kt>double</span> <span class=n>y</span><span class=p>)</span> <span class=p>{</span> <span class=n>_x</span> <span class=p>=</span> <span class=n>x</span><span class=p>;</span> <span class=n>Y</span> <span class=p>=</span> <span class=n>y</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>private</span> <span class=kt>int</span> <span class=n>_x</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>public</span> <span class=kt>double</span> <span class=n>X</span> <span class=p>{</span> <span class=k>readonly</span> <span class=k>get</span> <span class=p>=&gt;</span> <span class=n>_x</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>public</span> <span class=k>readonly</span> <span class=kt>double</span> <span class=n>Y</span> <span class=p>{</span> <span class=k>get</span><span class=p>;</span> <span class=k>init</span><span class=p>;</span> <span class=p>}</span> <span class=c1>// C# 9.0</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=c1>// use `const` for compile time constant
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>const</span><span class=w> </span><span class=n>SOME_CONSTANT</span>: <span class=kt>u32</span> <span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>some_constant</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w> </span><span class=c1>// immutable by default
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span><span class=w> </span><span class=n>some_constant</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>2</span><span class=p>;</span><span class=w> </span><span class=c1>// this will shadow the previous definition
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>struct</span> <span class=nc>Coords</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>x</span>: <span class=kt>f64</span><span class=p>,</span><span class=w> </span><span class=n>y</span>: <span class=kt>f64</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>impl</span><span class=w> </span><span class=n>Coords</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>fn</span> <span class=nf>sum</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>f64</span> <span class=p>{</span><span class=w> </span><span class=c1>// the instance is also immutable in methods
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=bp>self</span><span class=p>.</span><span class=n>x</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>y</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>fn</span> <span class=nf>offset</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>Coords</span><span class=w> </span><span class=n>offset</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=bp>self</span><span class=p>.</span><span class=n>x</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=n>offset</span><span class=p>.</span><span class=n>x</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=bp>self</span><span class=p>.</span><span class=n>y</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=n>offset</span><span class=p>.</span><span class=n>y</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>{% endtabs %}</p><h3 id=全局变量静态成员>全局变量、静态成员</h3><blockquote><p>静态成员可以看作从属于某个范围的全局变量</p></blockquote><ul><li><strong>Python</strong>: 支持全局变量，但是在全局范围以外默认不可变，可变需要使用global关键字</li><li><strong>C</strong>: 支持全局变量</li><li><strong>C++</strong>: 支持全局变量，并且支持<code>namespace</code>级别的，支持静态变量，并且支持函数内定义静态变量</li><li><strong>C#</strong>: 不支持，可以通过类型的静态变量和静态构造函数实现</li><li><strong>Rust</strong>: 支持，通过<code>const</code>或者<code>static</code>关键字。由于rust无法追踪静态变量的引用，因此使用静态变量需要在<code>unsafe</code>代码块中。</li></ul><p>{% tabs Global Code Example %}</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># variables defined in global are global variables</span>
</span></span><span class=line><span class=cl><span class=n>counter</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>some_func</span><span class=p>():</span>
</span></span><span class=line><span class=cl>  <span class=nb>print</span><span class=p>(</span><span class=n>counter</span><span class=p>)</span> <span class=c1># global vars are available in the current module</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>some_func_mod</span><span class=p>():</span>
</span></span><span class=line><span class=cl>  <span class=k>global</span> <span class=n>counter</span> <span class=c1># you need `global` keyword to modify</span>
</span></span><span class=line><span class=cl>  <span class=n>counter</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Player</span><span class=p>:</span>
</span></span><span class=line><span class=cl>  <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=nb>id</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=bp>self</span><span class=o>.</span><span class=n>_id</span> <span class=o>=</span> <span class=nb>id</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>counter</span> <span class=o>=</span> <span class=mi>0</span> <span class=c1># member defined in class is actually a static member</span>
</span></span><span class=line><span class=cl>  <span class=nd>@staticmethod</span>
</span></span><span class=line><span class=cl>  <span class=k>def</span> <span class=nf>create_player</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=n>player</span> <span class=o>=</span> <span class=n>Player</span><span class=p>(</span><span class=n>counter</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>counter</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>player</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// variables defined in global are global variables
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>counter</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=n>counter</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=c1>// this is a global variable
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=k>namespace</span> <span class=n>sub</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>sub_counter</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=c1>// this is a global variable, but here &#34;global&#34; is a namespace
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>static</span> <span class=kt>int</span> <span class=n>counter2</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=c1>// rarely used, static here means the variable is local to this compliation unit (this source file)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Player</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>id</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// static members of a class
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>static</span> <span class=kt>int</span> <span class=n>counter</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>static</span> <span class=n>Player</span> <span class=nf>create_player</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>Player</span> <span class=p>{</span> <span class=n>counter</span><span class=o>++</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// static variable can be inside a function
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>static</span> <span class=n>Player</span> <span class=nf>create_player2</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=kt>int</span> <span class=n>counter2</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>Player</span> <span class=p>{</span> <span class=n>counter2</span><span class=o>++</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=c1>// there is no global variable, you have to tie the variable to a class.</span>
</span></span><span class=line><span class=cl><span class=c1>// But note that const variable can be in global scope, and you don&#39;t need to declare it as static</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=k>class</span> <span class=nc>Utility</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>static</span> <span class=kt>int</span> <span class=n>counter</span> <span class=p>=</span> <span class=m>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>static</span> <span class=k>readonly</span> <span class=kt>int</span> <span class=n>some_constant</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>static</span> <span class=n>Utility</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>some_constant</span> <span class=p>=</span> <span class=m>1</span><span class=p>;</span> <span class=c1>// the static constructor can be used to assign value to static readonly object</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Player</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>Player</span><span class=p>(</span><span class=kt>int</span> <span class=n>id</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>private</span> <span class=k>static</span> <span class=kt>int</span> <span class=n>counter</span> <span class=p>=</span> <span class=m>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>public</span> <span class=k>static</span> <span class=n>Player</span> <span class=n>create_player</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=k>new</span> <span class=n>Player</span><span class=p>(</span><span class=n>counter</span><span class=p>++);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=c1>// you need static keyword to declare global/static variables
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>static</span><span class=w> </span><span class=n>some_constant</span>: <span class=kt>i32</span> <span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>static</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>counter</span>: <span class=kt>i32</span> <span class=o>=</span><span class=w> </span><span class=mi>0</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>struct</span> <span class=nc>Player</span><span class=p>(</span><span class=kt>i32</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>create_player</span><span class=p>()</span><span class=w> </span>-&gt; <span class=nc>Player</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;{}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>some_constant</span><span class=p>);</span><span class=w> </span><span class=c1>// read constant static variable is safe
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>unsafe</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=c1>// read and write to mutable static variable is unsafe in rust
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=n>counter</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>return</span><span class=w> </span><span class=n>Player</span><span class=p>(</span><span class=n>counter</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>{% endtabs %}</p><h3 id=异常处理>异常处理：</h3><ul><li><strong>Python</strong>：exception, try catch finally, raise</li><li><strong>C++</strong>: assert, static_assert, throw</li><li><strong>C</strong>: error code, assert</li><li><strong>C#</strong>: exception, try catch finally, throw</li><li><strong>Rust</strong>: <code>Result</code> 枚举和 <code>panic!</code></li></ul><h3 id=空变量空类型>空变量，空类型</h3><ul><li><strong>Python</strong>: <code>None</code>，是个对象，类型为<code>NoneType</code></li><li><strong>C</strong>: <code>(void*)NULL</code> 空指针，空类型<code>void</code></li><li><strong>C++</strong>: <code>nullptr</code> 空指针, <code>std::Optional&lt;T></code>，空类型<code>void</code></li><li><strong>C#</strong>: <code>null</code> 本质上是空指针, <code>Nullable&lt;T></code>, <code>?</code>操作符支持，没有空类型</li><li><strong>Rust</strong>: 不提供空类型，<code>Option&lt;T></code>，<code>?</code>操作符支持，有个单元类型（unit type）<code>()</code>可以看作空类型，用于填充类型参数，另外还有<code>!</code>类型（叫“从不”类型）专门指无返回值的函数或者表达式</li></ul><h3 id=别名>别名</h3><ul><li><strong>Python</strong>: 类本身也是对象，可以赋值给别的变量。而<code>import .. as ..</code>语法也可以实现别名</li><li><strong>C</strong>: <code>typedef</code>, <code>#define</code></li><li><strong>C++</strong>: <code>typedef</code>, <code>using</code>, <code>#define</code></li><li><strong>C#</strong>: <code>using</code></li><li><strong>Rust</strong>: <code>type .. = ..</code>, <code>use ... as</code></li></ul><h3 id=函数声明>函数声明</h3><ul><li><strong>Python</strong>: 支持默认参数，以列表、字典两种方式支持可变参数</li><li><strong>C</strong>: 支持变长参数，不支持默认参数</li><li><strong>C++</strong>: 支持变长参数、变长模板参数（variadic type param)，支持默认参数</li><li><strong>C#</strong>: 支持默认参数、变长参数(<code>params</code>)，不支持变长形参</li><li><strong>Rust</strong>: 不支持默认参数和变长参数，前者一般通过<code>Option&lt;T></code>实现，后者一般通过宏实现</li></ul><h3 id=语法糖><code>?</code>语法糖</h3><ul><li><strong>Python</strong>: 可以通过<code>or</code>变相实现</li><li><strong>C/C++</strong>: 无</li><li><strong>C#</strong>: <code>?</code>可以用在引用类型上，或者<code>Nullable&lt;T></code>加值类型上，还有<code>??</code>操作符</li><li><strong>Rust</strong>: 可以用在<code>Option&lt;T></code>和<code>Result&lt;T, E></code>上</li></ul><h3 id=unicode-字符串>Unicode 字符串</h3><ul><li><strong>Python</strong>: 在Python 2里，<code>bytes</code>=<code>str</code>，都表示的是ANSI字符串，而Unicode字符串需要用<code>unicode</code>类型，常量需要用<code>u"文字"</code>。在Python 3里，<code>bytes</code>可以表示ASCII字符串，而<code>str</code>是支持Unicode了，<code>"文字"</code>直接就是UTF8字符串。</li><li><strong>C</strong>: 甚至没有专门的字符串类型，只有<code>char</code>数组</li><li><strong>C++</strong>: <code>std::string</code>并没有专门支持Unicode，它可以用来存储Unicode字符串，但是没有针对性的处理工具。声明UTF8字符串需要用<code>u8"文字"</code>格式的前缀。处理Unicode字符一般会选择ICU这个C++库。</li><li><strong>C#</strong>：<code>String</code>是带有编码信息的，并且<code>System.Encoding</code>里面有<code>String</code>和<code>byte[]</code>相互转换的工具。</li><li><strong>Rust</strong>: 最常用的<code>String</code>字符串是UTF8编码的（好像不支持UTF16？），并且支持Unicode字符的操作（如字符边界等），另外还有<code>str</code>类型是个slice类型。Rust还提供了<code>CString</code>来表示ANSI字符串。</li></ul><h3 id=宏>宏</h3><ul><li><strong>Python</strong>: 不支持</li><li><strong>C</strong>: 仅支持<code>#define</code>系列和<code>#if</code>系列</li><li><strong>C++</strong>: 支持的非常丰富，甚至有专门的库。。。</li><li><strong>C#</strong>: 仅支持<code>#if</code>系列</li><li><strong>Rust</strong>: 有三种宏，声明宏（Declarative macro），主要是进行匹配和展开，类似于C/C++用宏来枚举类型；过程宏（Procedural macro），可以解析语法树，从struct结构生成代码；类属性宏（Attribute-like macros），可以从任意代码生成任意代码；类函数宏（Function-like macro），通常用于解析一小段token</li></ul><h3 id=修饰器>修饰器</h3><ul><li><strong>Python</strong>: decorator</li><li><strong>C/C++</strong>: 无，一小部分功能可以通过宏实现</li><li><strong>C#</strong>: Attribute</li><li><strong>Rust</strong>: 类属性宏</li></ul><h2 id=类型系统>类型系统</h2><ul><li><strong>Python</strong>: 有<code>class</code>，不过类也是对象，是一个用来生成其他对象的对象。</li><li><strong>C</strong>: 只有<code>struct</code>（和<code>union</code>）</li><li><strong>C++</strong>: 有<code>struct</code>和<code>class</code>，但是<code>struct</code>只是一个成员默认为<code>public</code>的<code>class</code>，没有本质区别，是为了兼容C而存在的。</li><li><strong>Rust</strong>: 只有<code>struct</code>（<code>unsafe</code>模式下有<code>union</code>）</li><li><strong>C#</strong>: <code>struct</code>、<code>class</code>、<code>interface</code>、<code>enum</code>、<code>delegates</code>。其中<code>struct</code>/<code>enum</code>是值类型、<code>class</code>/<code>interface</code>/<code>delegates</code>都是引用类型，在之间转换会有封箱和拆箱操作。</li></ul><h3 id=定义成员函数methodmember-function>定义成员函数（method/member function）</h3><ul><li><strong>Python</strong>: 在<code>class</code>代码块里写，也可以动态给Python对象添加函数（过于牛逼，不过定义了<code>__slot__</code>的对象除外）</li><li><strong>C</strong>: 没有成员函数一说</li><li><strong>C++</strong>: 在<code>class</code>代码内部写或者使用外部声明语法</li><li><strong>C#</strong>: 在<code>class</code>代码块内部写，但是有个<code>partial</code>关键字非常给力，可以让一个类的代码块分成几个区域</li><li><strong>Rust</strong>: 有个<code>impl</code>代码块，只有外部声明语法，并且如果是泛型的话也得标记上类型参数。在逻辑上更像是C的写法</li></ul><h3 id=强弱类型>强/弱类型</h3><ul><li><strong>Python</strong>: 弱类型，没有类型检查，只有Python 3.5引入的类型标注。你可以使用<code>mypy</code>来实现类型标注检查，但是错误的类型并不会影响程序运行。</li><li><strong>C</strong>: 强类型，所有变量和参数均需要声明类型</li><li><strong>C++/Rust/C#</strong>: 强类型，在这些语言中，绝大部分情况下变量和参数都拥有固定的类型，但是他们也提供不同程度的类型推断。此外他们也支持均动态类型。</li></ul><h3 id=类型推断>类型推断</h3><ul><li><strong>Python</strong>: 动态类型，无需推断</li><li><strong>C#</strong>: <code>var</code>关键字</li><li><strong>C++</strong>: <code>auto</code>关键字 (C++11)</li><li><strong>C</strong>: 无</li><li><strong>Rust</strong>: 默认推断，并且推荐能不写类型就不写，交给编译器，这无疑使代码更简洁了。</li></ul><h3 id=动态类型>动态类型</h3><p>动态类型一般仅在强类型中被提及，因为弱类型语言一般不进行类型检查，其指的是类型检查推迟到运行时。动态类型通常可以分为两种，一种是变体类型（Variant），指的是变量可以是几个类型中的任意一种；另一种是任意类型（Any Type），更接近动态类型的本身，指的是变量可以取任意类型。</p><ul><li><strong>Python</strong>: 弱类型语言</li><li><strong>C#</strong>: 支持，有<code>dynamic</code>关键字可以使类型检查在运行时进行（需要C# 4），通过<code>System.Dynamic.ExpandoObject</code>和<code>System.Dynamic.DynamicObject</code>类型实现动态成员，并且还支持匿名类型</li><li><strong>C</strong>: 通过<code>void*</code>指针可以变相实现任意类型。</li><li><strong>C++</strong>: 通过<code>std::variant&lt;...></code>和<code>std::any&lt;T></code>可以分别实现变体类型和任意类型（均需要C++17)，也可以通过<code>reintepret_cast</code>进行强制转换。</li><li><strong>Rust</strong>: 通过<code>Enum</code>可以实现变体类型，通过trait object（<code>dyn</code>关键字+<code>Box</code>）可以部分实现任意类型。<blockquote><p>这里的<code>dynamic</code>其实是指的dynamic dispatch（动态分发），也就是类型参数在运行时展开。静态分发就类似于C++的模板，而动态分发就更接近C#的运行时泛型。</p></blockquote></li></ul><h3 id=反射内省>反射/内省</h3><p>反射和内省的概念可能只有学过C#的人比较熟悉，它指的是在运行时获取类型的信息，例如所有的方法、所有的成员变量等等。</p><ul><li><strong>Python</strong>: 通过<code>__dict__</code>接口，以及<code>hasattr</code>, <code>getattr</code>, <code>setattr</code>三剑客可以实现动态获取类成员。</li><li><strong>C</strong>: 不支持，唯一相关的就是<code>sizeof</code>关键字，只能获取类型对象的大小。</li><li><strong>C++</strong>: 除了<code>sizeof</code>以外还有<code>typeid</code>关键字，但是获取的<code>type_info</code>对象只有名字信息，仅用于比较。</li><li><strong>C#</strong>: 通过<code>Object</code>这个基类所支持的<code>GetType()</code>方法可以获取类型信息，返回一个<code>Type</code>对象。这个对象包含了非常丰富的内容，可以获取名字、成员列表、嵌套类型信息等等</li><li><strong>Rust</strong>: <code>Any</code> trait有<code>get_type_id</code>方法，类似于C++的<code>typeid</code>，仅用于类型比较。</li></ul><h2 id=面向对象>面向对象</h2><h3 id=封装>封装</h3><ul><li><strong>Python</strong>: 除C扩展之外，几乎所有对象都是公开的，无法限制访问，只有一个约定俗成的<code>_</code>和<code>__</code>习惯（<code>_</code>开头的变量表示私有成员，形如<code>__xxx__</code>的变量表示特殊成员）</li><li><strong>C</strong>: 无访问控制，但是编译之后的library一般是无法修改的，因此可以通过选择头文件的内容来阻止访问部分代码。</li><li><strong>C++</strong>: <code>public</code>/<code>private</code>/<code>protected</code>关键字可以指定成员，或者继承的基类的可见度。另外还有<code>friend</code>关键字指定特定的可见关系，C++还可以通过匿名命名空间实现模块的私有化。</li><li><strong>C#</strong>: <code>public</code>/<code>private</code>/<code>protected</code>关键字类似于C++，但只能修饰类成员。另外还有<code>internal</code>关键字可以实现仅对同一个二进制内的代码公开的能力。</li><li><strong>Rust</strong>: 默认模块、类型、成员均为private，有<code>pub</code>关键字使得祖先可以访问。与其他语言不同的是<code>pub</code>可以修饰模块，并且其公开性是仅对祖先模块的。</li></ul><h3 id=继承多态>继承、多态</h3><ul><li><strong>Python</strong>: 可以多继承，使用Mixin的写法是个常用的范式。</li><li><strong>C++</strong> 可以多继承，也有trait体系，还有<code>virtual</code>和<code>override</code>。菱形问题可以通过虚继承解决。</li><li><strong>C#</strong>: 只能继承一个基类，可以继承多个接口。引用类型的基类都是object，而值类型是ValueType（虽然ValueType继承了object，但是编译器会有特别处理）。另外C#还有抽象类（<code>abstract</code>)，<code>virtual</code>, <code>override</code>, <code>sealed</code>。在C# 8之后支持接口的默认实现。</li><li><strong>Rust</strong>: 没有继承，但是可以定义和实现trait（即接口），并且接口支持默认实现。</li></ul><blockquote><p>Rust 在书17.1中认为，用继承的方式实现多态已经越来越不主流了，实际在使用时我确实也发现自己的代码里需要使用继承的方法不多，有点同意这个观点，但是我也仍能想到使用继承的场景，尤其是在面向现实问题以及GUI相关的代码中。而在数据结构中其实使用trait系统会更方便（尤其是二叉树定义其node类型的时候）。当然我猜测Rust选择不引入继承系统的原因还可能是它可能会带来的overhead（如果要允许子类实现自己的方法被父类调用，那就必然会需要虚函数，而这会引入vtable产生内存开销）。
一个比较奇怪的设计是Rust的trait支持静态函数（associated function），直觉上来说接口不应该限制静态成员的设计，毕竟接口方法都是与类型实例相关的，C#的接口中就不允许添加静态成员</p></blockquote><h3 id=泛型>泛型</h3><ul><li><strong>Python</strong>: 动态类型不需要泛型</li><li><strong>C#</strong> 有泛型，并且通过<strong>where</strong>支持类型限制，编译时不展开</li><li><strong>C</strong> 无泛型，但是可以通过指针强制转换进行类型变换以支持动态类型</li><li><strong>C++</strong> 有模板，在编译时会展开，并且模板的功能远超一般的泛型。模板参数支持整数</li><li><strong>Rust</strong> 有泛型，并且通过<strong>where</strong>支持类型限制，但是在编译时会展开。Rust 1.47正在测试模板参数支持整数。</li></ul><h2 id=函数式编程>函数式编程</h2><h3 id=函数对象和闭包>函数对象和闭包</h3><ul><li><strong>Python</strong>: 函数也是对象，想怎么玩都可以。Python的局部函数可以当作闭包使用</li><li><strong>C</strong>: 仅支持函数指针</li><li><strong>C#</strong>: 有匿名函数和lambda函数，还有<code>Delegate</code>/<code>event</code>，lambda函数是闭包，并且无需指定如何封装环境内变量</li><li><strong>C++</strong>: 有lambda函数和std::function，lambda函数是闭包，并且可以细致地指定如何封装环境内的变量</li><li><strong>Rust</strong>: 有闭包，可以赋值给<code>Fn</code> trait，支持局部函数但局部函数不是闭包。封装方式可以通过<code>Fn</code>/<code>FnMut</code>/<code>FnOnce</code>或者<code>move</code>关键字进行指定。普通的函数指针有<code>fn</code>类型</li></ul><blockquote><p>匿名函数仅仅指不需要指定函数名的函数，而closure是能够使用外部scope变量的函数，一般是匿名函数，但也可以不匿名。lambda函数即匿名函数，有可能是一个闭包</p></blockquote><p>{% tabs Function Code Example %}</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># normal function</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>add</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>):</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>a</span> <span class=o>+</span> <span class=n>b</span>
</span></span><span class=line><span class=cl><span class=n>func</span> <span class=o>=</span> <span class=n>add</span> <span class=c1># function is also an object</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># closure, usually used in decorators</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>closure</span><span class=p>():</span>
</span></span><span class=line><span class=cl>  <span class=n>some_value</span> <span class=o>=</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>  <span class=k>def</span> <span class=nf>increase</span><span class=p>(</span><span class=n>x</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>some_value</span> <span class=o>+</span> <span class=n>x</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>increase</span>
</span></span><span class=line><span class=cl><span class=n>func</span> <span class=o>=</span> <span class=n>closure</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># lambda function (which is a closure)</span>
</span></span><span class=line><span class=cl><span class=n>prefix</span> <span class=o>=</span> <span class=s2>&#34;INFO:&#34;</span>
</span></span><span class=line><span class=cl><span class=n>log_handler</span> <span class=o>=</span> <span class=k>lambda</span> <span class=n>x</span><span class=p>:</span> <span class=nb>print</span><span class=p>(</span><span class=n>prefix</span> <span class=o>+</span> <span class=n>x</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// normal function
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>add</span><span class=p>(</span><span class=kt>int</span> <span class=n>a</span><span class=p>,</span> <span class=kt>int</span> <span class=n>b</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>a</span> <span class=o>+</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// function pointers
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=p>(</span><span class=o>*</span><span class=n>fn_ptr</span><span class=p>)</span> <span class=p>(</span><span class=kt>int</span><span class=p>,</span> <span class=kt>int</span><span class=p>)</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>add</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=p>(</span><span class=k>const</span> <span class=o>*</span><span class=n>fn_cptr</span><span class=p>)</span> <span class=p>(</span><span class=kt>int</span><span class=p>,</span> <span class=kt>int</span><span class=p>)</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>add</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// normal function
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>add</span><span class=p>(</span><span class=kt>int</span> <span class=n>a</span><span class=p>,</span> <span class=kt>int</span> <span class=n>b</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>a</span> <span class=o>+</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// function pointers are also supported in C++
</span></span></span><span class=line><span class=cl><span class=c1>// note that the syntax can be much more complex in C++ than in C
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=p>(</span><span class=o>*</span><span class=n>fn_ptr</span><span class=p>)</span> <span class=p>(</span><span class=kt>int</span><span class=p>,</span> <span class=kt>int</span><span class=p>)</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>add</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=p>(</span><span class=k>const</span> <span class=o>*</span><span class=n>fn_cptr</span><span class=p>)</span> <span class=p>(</span><span class=kt>int</span><span class=p>,</span> <span class=kt>int</span><span class=p>)</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>add</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// std::function is a safer pointer implementation
</span></span></span><span class=line><span class=cl><span class=c1>// (since C++11, you can use boost::function before C++11)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>std</span><span class=o>::</span><span class=n>function</span><span class=o>&lt;</span><span class=kt>int</span> <span class=p>(</span><span class=kt>int</span><span class=p>,</span> <span class=kt>int</span><span class=p>)</span><span class=o>&gt;</span> <span class=n>func</span> <span class=o>=</span> <span class=n>add</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// lambda function (which is a closure, since C++11)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>prefix</span> <span class=o>=</span> <span class=s>&#34;INFO:&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>log_handler</span> <span class=o>=</span> <span class=p>[</span><span class=o>&amp;</span><span class=n>prefix</span><span class=p>](</span><span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span> <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>prefix</span> <span class=o>&lt;&lt;</span> <span class=n>x</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>function</span><span class=o>&lt;</span><span class=kt>void</span> <span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=p>)</span><span class=o>&gt;</span> <span class=n>func2</span> <span class=o>=</span> <span class=n>log_handler</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=c1>// normal function</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=k>add</span><span class=p>(</span><span class=kt>int</span> <span class=n>a</span><span class=p>,</span> <span class=kt>int</span> <span class=n>b</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>a</span> <span class=p>+</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// delegates are function pointer types in C#</span>
</span></span><span class=line><span class=cl><span class=k>public</span> <span class=k>delegate</span> <span class=kt>int</span> <span class=n>AddFunc</span> <span class=p>(</span><span class=kt>int</span> <span class=n>a</span><span class=p>,</span> <span class=kt>int</span> <span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>AddFunc</span> <span class=n>func</span> <span class=p>=</span> <span class=k>add</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>System</span><span class=p>.</span><span class=n>Func</span><span class=p>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=kt>int</span><span class=p>,</span> <span class=kt>int</span><span class=p>&gt;</span> <span class=n>func2</span> <span class=p>=</span> <span class=k>add</span><span class=p>;</span> <span class=c1>// there are also predefined delegates</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// C# also provides Event to handle a chain of functions</span>
</span></span><span class=line><span class=cl><span class=c1>// (usually used in GUI applications)</span>
</span></span><span class=line><span class=cl><span class=k>public</span> <span class=k>event</span> <span class=n>AddFunc</span> <span class=n>addEvents</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>addEvents</span> <span class=p>+=</span> <span class=n>func</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// lambda function in C#, note that the types of parameter and return value</span>
</span></span><span class=line><span class=cl><span class=c1>//     are decided by the function type signature</span>
</span></span><span class=line><span class=cl><span class=kt>string</span> <span class=n>prefix</span> <span class=p>=</span> <span class=s>&#34;INFO:&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>System</span><span class=p>.</span><span class=n>Func</span><span class=p>&lt;</span><span class=kt>string</span><span class=p>,</span> <span class=k>void</span><span class=p>&gt;</span> <span class=n>log_handler</span> <span class=p>=</span> <span class=p>(</span><span class=n>x</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=n>Console</span><span class=p>.</span><span class=n>WriteLine</span><span class=p>(</span><span class=n>prefix</span> <span class=p>+</span> <span class=n>x</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=c1>// normal function
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>fn</span> <span class=nf>add</span><span class=p>(</span><span class=n>a</span>: <span class=kt>i32</span><span class=p>,</span><span class=w> </span><span class=n>b</span>: <span class=kt>i32</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>i32</span> <span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>a</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>b</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// function pointer has type `fn`
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span><span class=w> </span><span class=n>func</span>: <span class=nc>fn</span><span class=p>(</span><span class=kt>i32</span><span class=p>,</span><span class=w> </span><span class=kt>i32</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>i32</span> <span class=o>=</span><span class=w> </span><span class=n>add</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// define and return closure
</span></span></span><span class=line><span class=cl><span class=c1>// You need to wrap closure with Box in order to return it since the size of closure is unknown for compiler
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>fn</span> <span class=nf>closure</span><span class=p>()</span><span class=w> </span>-&gt; <span class=nb>Box</span><span class=o>&lt;</span><span class=k>dyn</span><span class=w> </span><span class=nb>Fn</span><span class=p>(</span><span class=kt>i32</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>i32</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kd>let</span><span class=w> </span><span class=n>some_value</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>2</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kd>let</span><span class=w> </span><span class=n>increase</span>: <span class=nb>Fn</span><span class=p>(</span><span class=kt>i32</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>i32</span> <span class=o>=</span><span class=w> </span><span class=o>|</span><span class=n>x</span><span class=o>|</span><span class=w> </span><span class=n>some_value</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>x</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nb>Box</span>::<span class=n>new</span><span class=p>(</span><span class=n>increase</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>func_boxed</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>closure</span><span class=p>();</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>{% endtabs %}</p><h3 id=模式匹配>模式匹配</h3><ul><li><strong>Python</strong>: 3.10开始引入支持</li><li><strong>C</strong>: 不支持</li><li><strong>C++</strong>: 暂无语言内置支持，但是可以通过魔改模板实现，例如<a class=link href=https://github.com/solodon4/Mach7 target=_blank rel=noopener>Mach7</a></li><li><strong>C#</strong>: C# 7引入<code>switch</code>支持</li><li><strong>Rust</strong>: 内置<code>match</code>支持</li></ul><h3 id=遍历器iterator>遍历器（iterator）</h3><p>关于异步遍历参见后文<a class=link href=#%e5%bc%82%e6%ad%a5%e5%92%8c%e5%8d%8f%e7%a8%8b>异步</a>一节</p><ul><li><strong>Python</strong>: 内置<code>iter()</code>, generator类型, <code>yield</code>，Python 3.6之后支持<code>async</code>函数中使用<code>yield</code></li><li><strong>C++</strong>: 没有语言支持，但是在STL里面定义了一套通用接口，有<code>std::foreach</code>，也有<code>for(type value: collection)</code>语句</li><li><strong>C</strong>: 不支持</li><li><strong>C#</strong>: <code>IEnumerable</code>, <code>foreach</code>, <code>yield return</code>。C# 8.0之后引入<code>IAsyncEnumerable&lt;T></code>，支持异步返回流（即在async函数中使用<code>yield return</code>)。(这个功能支持的比Python晚好多= =)</li><li><strong>Rust</strong>: 容器类型的<code>iter()</code>方法</li></ul><h3 id=元组tuple>元组（tuple）</h3><ul><li><strong>Python</strong>：内置<code>tuple</code>类型，不限长度，一个重要区别是python的tuple是不可变(immutable)的, Cython的ctuple</li><li><strong>C++</strong>: <code>std::tuple</code>，也不限长度，C++17支持解构语法？（structure binding）</li><li><strong>Rust</strong>: 内置<code>tuple</code>支持，tuple类型的签名例如(u32, u32)，长度虽然不限，但是有些语法只支持最长12个对象hhhh</li><li><strong>C#</strong>: 曾经对tuple的支持只有<code>System.Tuple&lt;T1, T2, ...></code>，由于C#不支持变长类型参数，因此这个<code>Tuple</code>类型变得相当冗余，而且也很麻烦。在C# 7之后引入了tuple的语法，之后使用起来就方便多了</li></ul><h2 id=不安全代码c交互>不安全代码、C交互</h2><ul><li><strong>Python</strong>: 由于Python的最常用解释器CPython就是基于C的，并提供了丰富且完整的C-<strong>API</strong>，因此Python对与C交互的支持非常好，这也是Python被常用为胶水语言的原因。调用C-ABI可以使用内置的<code>ctypes</code>库, 而如果想给C/C++代码写Python API，则可以用Cython、pybind11、boost.Python</li><li><strong>C#</strong>: C#是托管语言，可以使用<code>unsafe</code>编写操作指针的代码, 利用<code>DLLImport</code>（P/Invoke）可以调用C-ABI</li><li><strong>C++</strong>: C++本身是C的超集，几乎可以完美兼容C，也就是说C/C++的代码混合编译是没有问题的。另外在<code>extern</code>代码块中的函数和类不会被混淆（mangle），可以生成C-ABI</li><li><strong>Rust</strong>: 在Rust中使用<code>unsafe</code>代码块可以不进行引用检查, <code>extern</code>代码块可以避免函数签名被混淆（mangle）</li></ul><h2 id=并行和异步>并行和异步</h2><p>由于Rust对变量生命周期的严格管理，在Rust中进行并行和异步会变得非常麻烦，Rust官方专门有一本<a class=link href=https://rust-lang.github.io/async-book target=_blank rel=noopener>独立的书</a>介绍相关的异步内容，在这我就不细展开Rust的用例了，仅介绍大致的用法，留个印象。<del>因为我也还没学会</del></p><blockquote><p>关于协程、线程、进程之间的区别可以参考<a class=link href=https://zyxin.xyz/blog/2019-11/ParallelismInPythonAndCsharp/>我之前的这篇博客</a>。</p></blockquote><h3 id=异步和协程>异步和协程</h3><p>我对Python和C#的异步都有一定的使用经验，对C++的也略有了解，不得不说还是C#的异步语法使用起来最舒服。这也是部分得益于托管语言带来的好处，像C/C++/Rust想要实现异步就需要非常麻烦的语法和生命周期管理。</p><ul><li><strong>Python</strong>: Python 3.5引入了<code>async</code>，<code>await</code>关键字，并且有<code>asyncio</code>库实现各个层级的异步封装（封装过多反而导致使用起来很摸不着头脑）</li><li><strong>C</strong>: 没有内置支持</li><li><strong>C++</strong>: <code>&lt;future></code>库提供了异步的初步支持，C++20引入<code>co_await</code>，终于在语言层面支持了程序流中插入异步块，不过真是太不elegant了，并且还只主要是给库的开发者用的。另外好像C++的协程默认都是单开线程的，而不像是其他语言可以进行单线程协程。</li><li><strong>C#</strong>: 从C# 5.0引入了<code>async</code>，<code>await</code>关键字，应该是这些语言中引入最早的，也是支持最简明的，最容易上手的。C# 7.0后await的对象可以自定义类型了。</li><li><strong>Rust</strong>: 有<code>async</code>, <code>await</code>关键字支持</li></ul><p>{% tabs Async Code Example %}</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>asyncio</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># define and use async function</span>
</span></span><span class=line><span class=cl><span class=k>async</span> <span class=k>def</span> <span class=nf>io_task</span><span class=p>():</span>
</span></span><span class=line><span class=cl>  <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;fake io processing...&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>await</span> <span class=n>asyncio</span><span class=o>.</span><span class=n>sleep</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># launch the task in the current thread</span>
</span></span><span class=line><span class=cl><span class=n>asyncio</span><span class=o>.</span><span class=n>get_event_loop</span><span class=p>()</span><span class=o>.</span><span class=n>run_until_complete</span><span class=p>(</span><span class=n>io_task</span><span class=p>())</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// before C++20
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#include</span> <span class=cpf>&lt;future&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;thread&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>io_task</span> <span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;fake io processing</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>this_thread</span><span class=o>::</span><span class=n>sleep_for</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>chrono</span><span class=o>::</span><span class=n>seconds</span><span class=p>(</span><span class=mi>1</span><span class=p>));</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>future</span><span class=o>&lt;</span><span class=kt>bool</span><span class=o>&gt;</span> <span class=n>fut</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>async</span><span class=p>(</span><span class=n>io_task</span><span class=p>);</span> <span class=c1>// start a thread to run the task
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>bool</span> <span class=n>result</span> <span class=o>=</span> <span class=n>fut</span><span class=p>.</span><span class=n>get</span><span class=p>();</span> <span class=c1>// wait for the result
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// co_await has been introduced in C++20, but it&#39;s still not ready to use
</span></span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=k>using</span> <span class=nn>System.Threading.Tasks</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>async</span> <span class=n>Task</span> <span class=n>io_task</span><span class=p>()</span> <span class=p>{</span> <span class=c1>// the return type for async functions is void / Task / Task&lt;T&gt;. For WinRT, you&#39;ll need IAsyncOperation in place of Task</span>
</span></span><span class=line><span class=cl>  <span class=n>Console</span><span class=p>.</span><span class=n>WriteLine</span><span class=p>(</span><span class=s>&#34;fake io processing...&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>await</span> <span class=n>Task</span><span class=p>.</span><span class=n>Delay</span><span class=p>(</span><span class=m>1000</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=n>io_task</span><span class=p>().</span><span class=n>Wait</span><span class=p>();</span> <span class=c1>// start the coroutine and wait for its completion, very intuitive</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>async</span> <span class=k>void</span> <span class=n>io_task_detached</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>await</span> <span class=n>io_task</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=n>io_task_detached</span><span class=p>();</span> <span class=c1>// start the coroutine and don&#39;t wait for it.</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>time</span>::<span class=n>Duration</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>async_std</span>::<span class=n>task</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// async function has normal return types
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>async</span><span class=w> </span><span class=k>fn</span> <span class=nf>io_task</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;fake io processing...&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>task</span>::<span class=n>sleep</span><span class=p>(</span><span class=n>Duration</span>::<span class=n>from_secs</span><span class=p>(</span><span class=mi>1</span><span class=p>)).</span><span class=k>await</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// async block returns a Future&lt;T&gt; object
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>task</span>::<span class=n>block_on</span><span class=p>(</span><span class=k>async</span><span class=w> </span><span class=p>{</span><span class=n>io_task</span><span class=p>()})</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>{% endtabs %}</p><h3 id=线程>线程</h3><ul><li><strong>Python</strong>: 虽然Python提供了<code>threading</code>库，但是由于CPython全局锁的存在，实际上通常情况下同时只能执行一个线程，只有在进行IO操作的时候threading会非常游泳</li><li><strong>C</strong>: 在POSIX系统上通常使用<code>pthread</code>库，而在MSVC下面则可以使用<code>pthread_win32</code>或者Windows API</li><li><strong>C++</strong>: <code>&lt;thread></code>库提供了线程的相关支持（需要C++11）</li><li><strong>C#</strong>: <code>System.Threading</code>提供了线程的相关支持</li><li><strong>Rust</strong>: <code>std::thread</code>标准模块中提供了线程的相关支持，不过由于Rust对变量声明周期的管理，写代码时经常需要用到<code>Mutex</code>和<code>Arc</code></li></ul><h3 id=进程>进程</h3><ul><li><strong>Python</strong>: 在<code>os</code>和<code>subprocess</code>库中提供了创建进程的函数。另外Python还在<code>multiprocessing</code>库中则是提供了非常方便的MPI接口，这是Python比其他语言都好用的地方，可能也算是对全局锁的补偿把。</li><li><strong>C</strong>: 在POSIX系统上通常使用<code>unistd.h</code>中的<code>fork</code>，而在MSVC下可以使用Windows API</li><li><strong>C++</strong>: 标准库中并没有提供支持，可以用<code>boost.process</code>库来解决</li><li><strong>C#</strong>: <code>System.Diagnostics</code>中的<code>Process</code>类提供了相关支持</li><li><strong>Rust</strong>: <code>std::process</code>标准模块中提供了进程相关支持。</li></ul><h2 id=包管理器>包管理器</h2><p>为什么要专门拎出来这一点，是因为包管理是我放弃julia的最大理由。。。</p><ul><li><strong>Python</strong>: <code>pip</code>挺不错，安装方便使用简单；<code>conda</code>功能更强大，更方便支持带C扩展的包，但是性能差</li><li><strong>C/C++</strong>: 一般都依赖Linux的包管理器。在Mac上有<code>brew</code>，而在Windows上只到最近<code>vcpkg</code>的出现才算勉强有了可用的包管理。总体而言还是没有好用的包管理器，甚至编译体系都有好几种（<code>conf</code>/<code>make</code>, <code>autoconf</code>, <code>CMake</code>, Qt的<code>qmake</code>, Boost的<code>b2</code>, Visual Studio的<code>nmake</code>, &mldr;），这也是C++挺劝退的点。</li><li><strong>C#</strong>: <code>nuget</code>，算不上好用但好在有宇宙第一IDE——VS的支持。</li><li><strong>Rust</strong>: <code>cargo</code>，目前的体验都挺友好的~设计上比较像<code>npm</code></li></ul><h2 id=常用数据结构>常用数据结构</h2><p>下表总结了各个语言中常用数据结构的对应关系（非严格对应，他们的实现上或多或少有点区别）</p><div class=table-wrapper><table><thead><tr><th>Python</th><th>C++</th><th>C#</th><th>Rust</th></tr></thead><tbody><tr><td><code>list</code></td><td><code>vector</code></td><td><code>List</code></td><td><code>Vec</code></td></tr><tr><td><code>SortedDict</code></td><td><code>map</code></td><td><code>SortedDictionary</code></td><td><code>BTreeMap</code></td></tr><tr><td><code>dict</code></td><td><code>unordered_map</code></td><td><code>Dictionary</code></td><td><code>HashMap</code></td></tr><tr><td><code>SortedSet</code></td><td><code>set</code></td><td><code>SortedSet</code></td><td><code>BTreeSet</code></td></tr><tr><td><code>set</code></td><td><code>unordered_set</code></td><td><code>Set</code></td><td><code>HashSet</code></td></tr><tr><td>-</td><td><code>function</code></td><td><code>Action</code>/<code>Func</code></td><td><code>Fn</code>/<code>FnMut</code>/<code>FnOnce</code></td></tr><tr><td>-</td><td><code>list</code></td><td><code>LinkedList</code></td><td><code>LinkedList</code></td></tr><tr><td><code>deque</code></td><td><code>deque</code></td><td><code>Queue</code></td><td><code>VecDeque</code></td></tr><tr><td><code>heapify</code></td><td><code>make_heap</code></td><td><code>PriorityQueue</code></td><td><code>BinaryHeap</code></td></tr><tr><td>-</td><td><code>unique_ptr</code></td><td>-</td><td><code>Box</code></td></tr><tr><td>-</td><td><code>smart_ptr</code></td><td>-</td><td><code>Rc</code></td></tr><tr><td>另外，C++ <code>std::const_cast</code> 可以在 Rust 中用<code>Cell&lt;T></code>和<code>RefCell&lt;T></code>起到类似效果(对应引用类型和指针类型？)</td><td></td><td></td><td></td></tr></tbody></table></div><h2 id=rust特有的特性>Rust特有的特性</h2><p>在别的语言里面没有的概念，以及Rust独特的语法特性如下</p><ul><li>引用检查（Borrow checker）</li><li>生命周期（Lifetime）声明</li><li><code>{}</code>代码块和<code>if</code>、<code>else</code>、<code>break</code>也都是表达式，而非语句</li><li>功能强大的宏系统</li></ul><hr><p>总而言之，语法设计上最优雅的我觉得还是C#和Python，功能和性能最强大的还是C++，最简单和底层的还是C，但是Rust至少有望替代C，这也是我为什么学习这些语言的原因。Rust有一些语法，虽然套用了同一个格式，但是却有很多是编译器特殊支持的（最常见的就是跟Trait相关的，如<code>Box</code>），这就使得Rust有时候很不优雅，关于这一点可以看<a class=link href=https://tuna.moe/event/2021/rust/ target=_blank rel=noopener>TUNA的讲座</a>。</p><p>本文仅为我读完Rust官方入门教材之后的总结，之后有实战经验了我可能会再写一些心得吧~</p><blockquote><p>另外在总结本文的时候还发现了一个<a class=link href=https://ttu.github.io/kotlin-is-like-csharp/ target=_blank rel=noopener>对比Kotlin和C#的网页</a>，挺有意思的，贴在这供参考</p></blockquote></section><footer class=article-footer><section class=article-tags><a href=/blog/tags/Rust/>Rust</a>
<a href=/blog/tags/Python/>Python</a>
<a href=/blog/tags/C++/>C++</a>
<a href=/blog/tags/C#/>C#</a>
<a href=/blog/tags/Comparison/>Comparison</a></section><section class=article-copyright><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg><span>Licensed under CC BY-NC-SA 4.0</span></section></footer></article><aside class=related-content--wrapper><h2 class=section-title>相关文章</h2><div class=related-content><div class="flex article-list--tile"><article><a href=/blog/2019-11/ParallelismInPythonAndCsharp/><div class=article-details><h2 class=article-title>进程、线程与协程 (C# vs Python)</h2></div></a></article><article><a href=/blog/2019-08/GluePythonCpp/><div class=article-details><h2 class=article-title>如何选择Python与C++之间的胶水</h2></div></a></article><article><a href=/blog/2019-08/CythonFunctions/><div class=article-details><h2 class=article-title>Cython中的特殊函数</h2></div></a></article><article><a href=/blog/2019-08/CythonArray/><div class=article-details><h2 class=article-title>在Cython中操作数组</h2></div></a></article><article><a href=/blog/2019-08/CythonInterop/><div class=article-details><h2 class=article-title>Cython与C/C++的交互</h2></div></a></article></div></div></aside><div class=disqus-container><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//jacob-zhongs-blog.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div><style>.disqus-container{background-color:var(--card-background);border-radius:var(--card-border-radius);box-shadow:var(--shadow-l1);padding:var(--card-padding)}</style><script>window.addEventListener("onColorSchemeChange",e=>{typeof DISQUS=="object"&&DISQUS.reset({reload:!0})})</script><footer class=site-footer><section class=copyright>&copy;
2017 -
2023 JacobZ</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>主题 <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.16.0>Stack</a></b> 由 <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a> 设计</section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/blog/ts/main.js defer></script>
<script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>