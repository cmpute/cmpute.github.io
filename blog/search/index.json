[{"content":"{% note default %}\n前言 这篇文章转载自Jorengarenar的博客。类似于前一篇文章，这一篇博文是我在搜索为什么Rust不支持动态栈分配的时候看到的。有很多人希望Rust支持变长数组，并且有一个相关的RFC，但是也有人提到这很危险，并且不会带来太大的收益，这篇文章总结了变长数组的问题，可供参考。 {% endnote %}\n正文 相比于固定尺寸，它会生成更多的、并且更慢的代码（而且很脆弱）。—— Linus Torvalds\nVLA 是变长数组（variable-length array）的缩写，它指的是长度在运行时而不是编译时决定的数组（真·数组，而不是接口像数组的一块内存）。VLA在C99标准中被引进，乍看上去它很方便并且高效，但是这只是各幻觉，实际上它只是一些顽固问题的源头。\n这篇文章的批评主要针对自动变长数组（automatic VLA），而不是所有形式的VLA，因此我在后文会用缩写aVLA来进行区分。\n支持某种形式的VLA的语言有：Ada, Algol 68, C, C#, COBOL, Fortran, J 和 Object Pascal。你可能注意到了，除了C和C#之外，其他的语言都不主流了。\n你从开头的引言中可能也猜到了，一个相当依赖于VLA的项目不是别的，正是Linux内核。维护者们花费了很多精力来移除VLA，并且在内核版本4.20（2018年）后实现了完全无VLA。\n在这篇文章刚开头的时候，我还要指出，在一些情形下，VLA是一个好解决方案。这样的情形不多，但是确实存在。未来我会尽力好好介绍他们并且链接到这篇文章来。\n栈分配 aVLA通常分配在栈上，这就绝大部分问题的根源。我们来看一个非常简单并且看起来很适合aVLA的例子：\n1 2 3 4 5 6 7 8 9 #include \u0026lt;stdio.h\u0026gt; int main(void) { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); long double arr[n]; printf(\u0026#34;%Lf\u0026#34;, arr[0]); return 0; } 你可以发现，这段代码从用户的输入读取数组长度。编译并且跑一下试试，看看在堆栈溢出造成区块错误（segfault）前，你可以输入多少值。在我的测试里这个上限是50万。这只是一个基础数据类型！想象以下对于一个结构体这个上限可能是多少！或者如果不仅仅是main()？考虑下递归函数？这个上限会大幅降低。\n并且，你没有任何（可移植、标准）的方法来处理堆栈溢出——你的程序已经无可救药地崩了。因此你要么需要在声明数组之前进行严格的长度审查，要么指望用户不要输入太大的数据。（这样赌博的后果显而易见）\n因此程序员必须保证aVLA的商都不能超过安全的上限。但是实际情况里，如果你知道这个安全上限，那没道理你不会去确认它。\n最糟糕的是 最糟糕的是segfault只是不当使用aVLA造成的后果中最好的一个。最坏情况是造成可以被利用的漏洞，攻击者可能会选择一个值，使得这个数组与其他内存分配重叠，从而控制那些值。这是个安全性灾难。\n如果你接受（进一步）损失程序性能，在GCC中你可以开启-fstack-clash-protection选项，它会在进行变长栈空间分配时，增加额外的指令来在每个内存页上进行探测。这可以确保所有的栈分配是有效的，或者在无效的时候抛出segfault，来缓解栈冲突（stack-clash）问题，从而将可能的代码执行攻击变成服务拒绝（denial of service）\n那如何修改这个例子？ 如果我想让用户决定数组大小并且创建大的离谱的定长数组很浪费？很简单，用malloc()！\n1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main(void) { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); long double* arr = malloc(n * (sizeof *arr)); printf(\u0026#34;%Lf\u0026#34;, arr[0]); free(arr); return 0; } 在这个例子里我可以最大输入13亿而不让我的机子报错。这大概是之前的2500倍！但是我最后仍然会碰到segfault是吧？唔，区别在于我们可以检查malloc()的返回值，然后比如我们就可以告知用户：\n1 2 3 4 long double* arr = malloc(n * (sizeof *arr)); if (arr == NULL) { perror(\u0026#34;malloc()\u0026#34;); // output: \u0026#34;malloc(): Cannot allocate memory\u0026#34; } 我碰到过相左的观点：C经常被用于系统和嵌入式的语言，这些情况下可能都没法使用malloc()。\n唉。。看来我又要重复一遍了，不过这确实很重要。\n在这种设备上你同样也没有多少栈空间。因此相比于在栈上动态分配空间，你应该确定你到底需要多少内存然后只使用固定尺寸的内存。\n当在栈空间很小的设备上使用aVLA的时候，你很容易弄出一些看起来能用的东西，但是当你的函数在栈已经很深的，有很多数据的时候被调用，你的栈就会炸。\n如果你在每个地方都分配固定尺寸的栈空间，那么你知道这肯定没问题。如果你在栈上动态分配内存，你需要测试你所有的代码路径，并且在所有可能的分配尺寸情况下进行测试，这比前者更难更容易出错。不要在甚至没有好处的情况下让它更容易射到你的脚（一个歇后语：footgun）\n意外创建 不像其他危险的C语言特性，aVLA没有什么门槛。很多新手会在试错之后开始使用这个特性，却根本不了解它的问题。有些时候甚至很有经验的程序员都会大意，在不需要aVLA的时候创建它。以下就是一个完全没必要的静静地创建了一个aVLA的例子：\n1 2 const int n = 10; int A[n]; 好在只要是个比较现代的编译器都会发现并且把这个aVLA给优化掉，但是。。。万一它没发现呢？或者它处于某种原因（安全？）没有这么做呢？优化没打开呢？但这肯定都问题不大，是吧？呃。。。\n比定长慢 在编译器不优化的情况下，之前这个aVLA的例子在数组初始化之前会生成7倍多的汇编指令，相比于它对应的定长情况（参见jmp .L5之前的汇编部分）。但这是没有开编译器优化的情况，如果开了生成的汇编是一模一样的。\n这里有一个aVLA不是意外插入的例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;stdio.h\u0026gt; void bar(int*, int); #if 1 // 1 for aVLA, 0 for aVLA-free void foo(int n) { int A[n]; for (int i = n; i--;) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;A[i]); } bar(A, n); } #else void foo(int n) { int A[1000]; // Let\u0026#39;s make it bigger than 10! (or there won\u0026#39;t be what to examine) for (int i = n; i--;) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;A[i]); } bar(A, n); } #endif int main(void) { foo(10); return 0; } void bar(int* B, int n) { for (int i = n; i--;) { printf(\u0026#34;%d %d\u0026#34;, i, B[i]); } } 处于介绍的目的，在这个例子中-O1级别的优化是最好的（生成的汇编会更清楚，然后-O2并不会有太大的用处）。\n当我们编译aVLA的版本，在for循环之前的指令如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 push rbp mov rbp, rsp push r14 push r13 push r12 push rbx mov r13d, edi movsx r12, edi ; here aVLA \u0026#34;starts\u0026#34;... sal r12, 2 ; lea rax, [r12+15] ; and rax, -16 ; sub rsp, rax ; mov r14, rsp ; ... and there \u0026#34;ends\u0026#34; 而无aVLA的版本则生成：\n1 2 3 4 5 push r12 push rbp push rbx sub rsp, 4000 ; this is caused by array definition mov r12d, edi 因此不仅定长数组生成更少的代码，它也简单多了。为什么aVLA在最开始的时候会产生更多的开销？它没有什么特别伟大的任务，但仍然不是简简单单的一个指针移动。\n但是这些区别影响很大吗？是的，很大。\n无法初始化 在aVLA不经意间造成的问题中还有如下不被允许的例子：\n1 2 int n = 10; int A[n] = { 0 }; 即便开了优化，aVLA仍然不支持初始化。因此尽管我们想要的是定长数组并且理论上编译器可以干这件事，但它就是行不通。\n给编译器作者带来麻烦 几个月前我存了Reddit上的一个评论，它列举了从编译器开发者的角度在VLA上碰到的问题。我把它引在下面：\nVLA其实适用于一个类型，而不是一个实际数组。因此你可以给VLA类型加一个typedef，它会冻结用到的表达式，即便这个表达式的一部分在VLA类型被使用的时候已经变了 VLA可以在代码块和循环中使用，这意味着要在栈上分配和释放动态长度的数据，如果你不想让偏移量（offsets）被乱搞，你就需要用指针来间接地实现它。 你可以在有VLA被使用的情况下用goto跳进或者跳出代码块，有些事情会被限制，但是也有不被限制的，而编译器却需要跟踪所有的这些骚操作 VLA可以被用在多维数组上 VLA可以被指针指向（因此你不需要分配空间，但是仍然需要跟踪所有变量的大小） 有些编译器允许在结构体定义里面使用VLA（我真的不知道这是怎么弄的，或者在什么地方VLA的尺寸被定下来了，然后所有的结构体会拥有同样的VLA尺寸） 一个函数可以同时有多个VLA被使用，并且它们可以在不同的地方，或者有条件地，或者在循环里被创建或者销毁。 sizeof需要被专门针对VLA实现（针对一个VLA实体，VLA类型，混合VLA和定长尺寸的类型，VLA数组，VLA指针） VLA这个词还被用于描述（当维数由传入参数确定时）多维数组的参数 在Windows上用有些编译器的时候（至少GCC是这样），声明过大的局部数组（使得栈尺寸超过4KB）意味着要调用一个特殊的分配器（__chkstk()），因为栈空间一次只能增长一个内存页）。当声明一个VLA的时候，编译器不知道它的长度，因此它需要在每个涉及的函数里都调用（__chkstk()），即便VLA的尺寸实际上很小。 并且相信我，如果你在C语言的一些论坛里溜一圈，你会发现更多不同的抱怨。\n降低可移植性 由于前面提到的这所有问题，有些编译器决定不完全支持C99。最主要的例子是微软的MSVC。C语言标准委员会页注意到了这个问题，并且在C11修订版中将VLA的支持标为可选的。\nC2x计划将推翻这个决定，但是aVLA仍然不是强制的\n这意味着使用VLA的代码有可能没法被一个C11编译器编译。因此你需要检查__STDC_NO_VLA__宏，并且在不支持的时候增加备用选项。\n另外，C++没有VLA并且没有证据表明它有将来会支持。这不是什么大事，但是仍然给C的VLA提供了一个反例\n（挑骨头）打破调用习惯 这是鸡蛋里挑骨头了，但是它确实是另一个让人不喜欢VLA的原因。一个常用的函数调用习惯是先传指针，再传参数，对于数组它的意思是：\n1 void foo(int** arr, int n, int m) { /* arr[i][j] = ... */ } C99标准中，提到数组的长度必须在参数列表里遇到的时候立马被分析确定，这意味着在用VLA的时候你没法用跟上面一样的语法\n1 void foo(int arr[n][m], int n, int m) { /* arr[i][j] = ... */ } // 非法！ 你需要\n打破这个习惯 1 void foo(int n, int m, int arr[n][m]) { /* arr[i][j] = ... */ } 或者使用过时的语法（即将被标准删除） 1 2 3 4 5 6 7 8 void foo(int[*][*], int, int); void foo(arr, n, n) int n; int m; int arr[n][m] { // arr[i][j] = ... } 结论 简而言之，别用VLA，编译你代码的时候开启-Wvla开关。VLA特性带来了很多危险却经常没有与之匹配的有用的回报。如果你发现在你的使用场景里里VLA是一个有效的解决方法，那就用它，但是记住我上面所提到的这些局限。\n可能还值得一提的是，VLA还被认为是解决问题同样很多的，不标准的alloca()的一个途径。\n","date":"2022-07-24T14:15:17Z","permalink":"https://zyxin.xyz/blog/2022-07/ThePitfallOfVLA/","title":"（C语言）变长数组的陷阱"},{"content":"{% note default %}\n前言 此文转载自Prelert的博客，作者为David。这篇文章目前只能在WebArchive找到了，因此我把此文转载并翻译到我的博客上。\n我是在搜索为什么Rust没有对应C/C++中long double的数据类型的时候看到了这篇博文，Rust不提供对应的数据类型造成了一些互操作性的问题（参见这里和这里）。与此相对的是，Zig和新发布的Carbon语言都支持f16和f128数据类型（其中Zig还支持f80，Carbon还支持bfloat16）。不过这倒是不令人意外，因为Zig和Carbon都以与C/C++的极致兼容性为卖点。这篇博客也许能解释一部分Rust不支持更高精度浮点数的原因。 {% endnote %}\n正文 C++ 提供三种浮点数据类型：float, double 和 long double。关于这些类型，C++11标准只提到了：\ndouble类型需要提供至少与float同等的精度，而long double需要提供至少与double同等的精度。\nfloat类型所有支持的数值是duoble的子集；double类型所有支持的数值是long duoble的子集。各浮点类型的数据表示方法取决于具体的实现。\n但是，几乎所有C++编译器都带一个C编译器，而C99标准的F附件则有更详细的规定：\nfloat 类型对应IEC 60559标准的单精度浮点数 double 类型对应IEC 60559标准的双精度浮点数 long double类型对应IEC 60559标准的扩展精度浮点数，或者非IEC 60559的扩展精度浮点数，或者IEC 60559的双精度浮点数。 只有一个彻头彻尾的M才会编写一个在C++和C部分使用不同浮点类型的C++编译器，因此实际上C++也要服从同样的规定。我所使用果的所有近20年内的C++编译器都使用IEC 60559（也就是IEEE 754）所规定的单精度和双精度浮点数，但是在实现最后一个类型——long double——上这些编译器会有不一致，这也导致了一些问题。\n在我的整个软件开发生涯中，我遇到过的几次与long double类型相关的问题，可以被归为两类：\n缺乏测试 可移植性 缺乏测试 在去年底我记录了一个可以归为第一类的问题。一个glibc在x86_64平台上的powl()函数实现中的bug有五年多未得到修复。我感觉如果这个bug是在用的更广泛的pow()函数中，那么会有更多人感到惊奇然后有人会更快修复它。因为这个函数的long double版本用的人较少，因此这个bug就烂在那了。\n另一个long double缺乏测试的例子是我在加入Prelert之前碰到的，与IBM的xlC/C++编译器相关在AIX系统上的问题。调用这个编译器的时候使用的名字（硬链接）决定了它的行为方式，当使用名称 xlC128_r 调用编译器时，它使用128位的 long double 表示。然后有一段时间，即使是最简单的程序编译都会崩（core dump）。尽管bug报告里面提到了一个调用fork()的例子，但其实如果打开了-brtl开关，最简单的\u0026quot;hello world\u0026quot;程序也能崩！显然所有的测试都是在使用其他更常用的名字调用编译器时完成的（这些情况下long double不是128位）。\n可移植性 而关于可移植性，一些需要注意的坑有：\n微软的Visual C++使用IEEE 754双精度浮点数表示long double——跟double一样（C99标准所允许的第三种情况）。因此在你的代码中区分long double和double毫无意义如果你只用微软的VC++进行编译。但如果你的代码需要支持别的平台并且你仍然使用long double，那么你就给你的代码里面掺入了一个很关键的，与平台相关的行为区别，它会让你吃亏的。大部分其他x86编译器都把long double看作x87所使用的80位扩展精度浮点数。 在SPARC芯片上（我知道它已经快挂了），long double类型使用128位的表示，但是默认情况下，编译器会生成软件实现，而非硬件实现的（浮点数）操作。这个情况可以回溯到大部分SPARC芯片都不支持这样的操作，然后使用中断来实现的时候。在软件层面实现浮点操作比去响应这些中断要快。但是软实现的浮点操作比硬件加速的浮点操作慢好几个数量级——我们发现一些单元测试会慢20倍，而且这些并不是单纯的做long double运算的测试。这是一个牺牲性能来换取代码（在编译和正确性方面）可移植的例子。 参考其他可移植的语言很有指导意义。Java有与IEEE754的单/双精度浮点数对应的float和double类型（并且不像C++，Java标准对如何实现浮点数运算非常明确）。Java没有给程序员提供long double类型，大概是因为我上面提到的可移植性问题（尽管这个标准允许在中间计算过程中使用x87扩展精度的格式）。Python只有一个float类型，并且“通常用C语言的double实现”。因此，如果你的整体系统包含使用其他语言编写的组件，那你弃用long double可以避免数据交换中的问题。同样的道理也适用于在数据库中存储浮点数——例如PostgreSQL提供real和double，对应IEEE 754的单/双精度浮点数。\n最后，一个在x86 CPU上只用float和double的好处是，编译器可以利用上CPU的SSE单元，然后两次或四次（浮点）运算有机会并行完成。这时使用64位调用约定的把函数参数传到寄存器中，那之后就可以直接使用SSE寄存器了。反之，long double变量只能在x87浮点运算单元中使用，并且不会使用寄存器传参，从而让程序变慢了。\n结论 有些人可能会说，使用long double可以提高结果的精度。这可能是对的，但是无论一个固定精度的浮点数有多少有效位数，它都会有有效位数损失的情况（如果使用的算法不好的话）。使用扩展精度而不是双精度可能会在某些情况下避免这些问题，但是长期来看唯一的解决方法是使用更适合计算机的算法，或者设法检测有效位数损失，并且把结果替换成合适的值。\n在我看来，如果你想编写可移植的C++代码，使得它不仅可以在多个平台运行，并且在某些平台上没有很夸张的性能问题，你最好避开long duoble。这也是我们在Prelert做法——我们的C++代码不使用long duoble，并且在使用Boost的时候我们定义BOOST_MATH_NO_LONG_DOUBLE_MATH_FUNCTIONS这个宏，让Boost.Math也不使用。\n","date":"2022-07-24T01:19:33Z","permalink":"https://zyxin.xyz/blog/2022-07/ThePitfallOfLongDouble/","title":"长浮点数（long double）的陷阱"},{"content":"最近突发奇想，想到自己有几台电脑，性能都不错但是经常闲置，包括实验室的服务器也不是每时每刻都在充分利用资源，因此完全可以跑一些别的程序来利用。我最先想到的就是以前做电脑压力测试的Prime95程序，然后一搜发现这里面还是有不少门道的。本文介绍一下如何利用你家电脑闲置的性能,将其贡献给科学事业，并且在冬天的夜晚让它的散热成为一大取暖来源~哈哈哈哈\nGIMPS 我最先测试的程序是Prime95，Prime95是梅森素数搜索计划（Great Internet Mersenne Prime Search, GIMPS）的Windows客户端。这个计划旨在利用互联网的计算资源来寻找梅森素数。形如$2^p-1$（$p$为素数）的数被称为梅森数，如果这个梅森数也是素数那么就被称为梅森素数。梅森素数是目前寻找大素数最高效的目标，人类发现最大的质数前几名都来自于GIMPS发现的梅森素数。\n如果你不想知道很多信息，只想直接开冲，那么你只需要从GIMPS官网下载Prime95（Windows）/ mprime（Linux），解压后双击直接开跑就可以了。如果你希望了解这个程序具体在干什么，或者想青史留名找到新的梅森素数，那么请接着往下读这一节~\nPrimeNet 首先需要介绍一下GIMPS的分布式计算网络，名字叫PrimeNet。PrimeNet负责分发计算任务和收集计算结果。由于梅森素数的形式是$2^p-1$，因此PrimeNet中把$p$称为Exponent（指数），验证每个指数对应的梅森数是否为素数是独立的。目前PrimeNet中对于每个指数有如下几种计算任务，括号内为PrimeNet中的缩写：\nTrial Factor (TF): 暴力遍历素数，测试每个素数是否是当前梅森数的因数。 P-1 Test (PM1): Pollard $p-1$测试法，可以在一定范围内寻找到一个因数$q$，前提是$q-1$是高度复合的（也被称为smooth，意思是由很多很多小的质因数合成的合数） P+1 Test (PP1): Williams $p+1$测试法，跟P-1测试类似，但是寻找的因数$q$需满足$q+1$高度复合。 Lucas-Lehmer Test (LL): 一种验证梅森数是否为质数的算法，该算法虽然很简单，但是非常耗时。 Double Check (D): 由于计算机在运算过程中可能会非常罕见地产生差错（这也是为什么人们需要ECC内存），因此为了确保素性判断正确，PrimeNet会让另外一台计算机重新计算Lucas-Lehmer，但是使用不同的初始参数，以验证计算的正确性。 Probable Prime Test (PRP): 这个测试是一种Fermat测试，但是使用了一种改进的验证方法。该算法会在测试过程中生成一个无法仿造的证明文件，这个证明文件可以由另一台计算机很快验证，大大减少了运算量。（但是好像这个算法只能得到Probable Prime，最后的验证应该还是需要使用Lucas-Lehmer） Proof Verification (CERT): 即验证PRP生成的证明的任务 除了这些任务之外，PrimeNet还衍生出了因数分解的任务，即尝试对质数验证失败的梅森数进行完整因数分解，在这个过程中也有可能发现非常大的质数，被称为co-factor。因数分解任务有如下两种：\nElliptic Curve Factorization (ECM): 利用椭圆曲线分解法进行因数分解，可以寻找一定范围以内的因数 Probable Prime Cofactor Test (PRP-CF): 对于梅森数除去找到的因数还剩下的因数进行素性测试，这个剩下的数通常仍然非常大，因为因数分解的方法通常只能找到几十位的因数，再大的因数实在太难计算了。 目前PrimeNet中因数分解的任务只分配给指数为四千万以下的梅森数。另外，以上这些任务只是大类，实际上PrimeNet中的任务划分更细一点，比如TF会分为普通TF和TF-LMH，后者优先选择TF进展比较小的指数进行分解。 PrimeNet中目前验证一个梅森数的完整流程大概如下：\n1 TF 2~2^63 -\u0026gt; TF 2^63 ~ 2^64 -\u0026gt; ... -\u0026gt; TF到2^78左右 -\u0026gt; PM1 -\u0026gt; PRP 将验证分为这么多步的原因主要还是为了减少计算量，TF和PM1在测试小因数的时候比较快，而Lucas-Lehmer虽然可以直接测试梅森数的素性，但是用TF和PM1粗筛可以大大减少计算量。这里TF计算的上限和PM1测试的范围都是PrimeNet根据找到因数的概率和计算耗时之间权衡之后算出来的。\n在早期PRP证明的算法还没有出现的时候（2020年以前），完整流程实际上是TF -\u0026gt; PM1 -\u0026gt; LL -\u0026gt; DC，因此目前PrimeNet还有大量积攒的LL测试没有被双重验证果，因此目前发现的梅森素数M74207281、M77232917、M82589933的顺位还没有被确定。\nPrimeNet的整体进展可以在GIMPS官网的任务分配表中中查看，这个表中展示了每一个范围中指数的状态。\n最右边的一大列Available指的是还没有被认领的任务，右边第二列Assigned指的是已被认领的任务，左边Composite里面F指的是找到因数的梅森数、DC指的是验证过的LL/PRP测试为合数的梅森数，右边Status Unproven中LL/PRP这一列指的是LL测试还没有被验证的指数，ERR指的是LL计算中出现错误的，而NO-LL则是完成了P-1测试后还没有经过LL/PRP测试的指数。\n客户端 在了解了计算任务的种类之后，接下来就是选择下载合适的客户端了。GIMPS除了官方的Prime95之外还有不少第三方实现的客户端。如果你想用CPU跑的话，直接使用官方的Prime95/mprime客户端即可；如果你的电脑有GPU，那么你可以选择GPU客户端，比较常用的有mfaktc (NVIDIA) / mfakto (AMD) / gpuowl (通用)。我主要使用的是gpuowl，因为它的代码最近仍然有更新，编译方便，并且支持P-1和PRP测试，而mfaktc和mfakto只能进行TF。不过gpuowl在windows上不太好编译。还有一些其他的GPU客户端，具体可以参考GIMPS论坛的这个介绍贴。\n在使用客户端之前，首先可以在GIMPS官网上注册一个账户，这个账户即你在PrimeNet中的账户，在使用客户端的时候把用户名提供给客户端，这样可以让PrimeNet统计你的贡献。PrimeNet的贡献统计以GHz-days（GHD）为单位，每个任务的GHD数值通过一定的公式进行估算的，并不是直接统计你的CPU频率乘上你所花费的时间。据我的经验，如果你想拥有最高的GHD/day，使用CPU和GPU比较划算的都是TF任务。\n另外注册账户之后，你还可以选择一个Team加入，这样你的贡献值同样会被计算到Team中。目前我加入的GIMPSChina团队近年的贡献量排名第三，可喜可贺！\n关于客户端的使用上，各个客户端基本都是解压之后即可使用，或者编译后使用。使用Prime95客户端的话程序会自动下载新的计算任务，你只需要设置CPU和内存的占用情况即可。如果你要跑TF/DC/PRP任务，那么只需要设置线程数即可，如果要跑PM1，那么需要设置内存上限至少为1G，并且越高越好。内存的设置在菜单里Resource Limit一栏的Advanced项目里面。而用gpuowl的话需要手动申请任务，在Github主页上有说明具体的使用方法。注意新的PrimeNet账户在一段时间（两三天）内是没法提交手动申请任务的结果的，需要管理员审核后才能提交，原因是之前有人恶意提交错误结果，具体情况参见这个GIMPS论坛的帖子。\n其他素数寻找项目 GIMPS是最早的互联网寻找素数的项目，后来受GIMPS的影响产生了很多新的项目，例如SRBase，GPU72以及PrimeGrid。SRBase旨在寻找形如$k*b^n\\pm 1$的素数，其中$k$为偶数，$b$为基；GPU72旨在利用GPU扩大梅森数的分解范围（提高到10亿，PrimeNet目前只搜索到1亿）；PrimeGrid则是一系列质数寻找项目的集合。这些项目之间通常会相互分享因数分解的结果。另外，在PrimePages网站上有统计目前已知的各个形式的最大质数，在Mersenne.ca网站上有更详细的梅森数计算结果统计。\nBOINC 除了GIMPS之外另一个更广为人知的志愿科学计算项目则是伯克利的Berkeley Open Infrastructure for Network Computing (BOINC)。这一项目给科学计算提供了统一的计算分发框架，里面有不少大型合作项目，涵盖数学、物理、天文、生物等多方面。\n使用教程 参与BOINC的计算就更加简单了，首先你需要安装一个BOINC客户端，在官网上可以下载到。在安装完成之后，只需要在项目列表里面选择自己喜欢的项目即可参加。通常每个项目都有自己的网站，并且你需要在网站上注册账号，以便于该项目追踪你的贡献，这个步骤在你选择想参加的项目之后会提示你进行操作。参加项目之后，BOINC便会开始自动分配你可以参加的项目。\nBOINC客户端同样支持资源占用的限制，并且支持在电脑有操作的时候暂停计算任务，更加便于你利用电脑的空闲时间进行计算了。BOINC相关项目的贡献，除了每个网站自己的统计外，还可以在第三方网站（如Free-DC和BOINCStats）上查到。\nGridCoin 另外BOINC还有一个很吸引人的地方是，有一款加密货币叫GridCoin是专门设计用来回报BOINC参与者的。因此如果你参加了GridCoin的计算池，那么你为科学事业贡献的算力实际上也是在挖矿！算力和电力的无用消耗是我不喜欢加密货币，尤其是比特币的最大原因，而设计在BOINC之上的GridCoin则完美解决了这个问题，并且GridCoin基于Proof of Stake，而不是现在比特币和以太坊使用的Proof of Work，更加降低了额外的计算资源消耗。因此如果你愿意参与BOINC的话，可以考虑同时利用GridCoin来回馈自己。\n在使用方法上，如果你是首次参加GridCoin，那么你需要利用GridCoin的计算池来进行挖矿，这个模式被称为Pool Crunching，除了安装BOINC之外你还需要在BOINC客户端中选择GridCoin支持的项目管理器（我选择的是grcpool），这样你的计算贡献会被归到GridCoin计算池的名下，而这个计算池会根据你的贡献分配GridCoin。当你有了GridCoin之后你也可以选择独立进行计算而不依赖于计算池，这个被称为Solo Crunching，这个情况下你的计算贡献也会直接被各个项目统计到。具体的使用方法还请参考GridCoin官网\n在了解这些的过程中，我还发现了一个聚集了国内志愿计算爱好者的论坛——中国分布式计算论坛，这里面有很多BOINC和GIMPS的贡献者，他们会交流项目参与方法、项目更新等。看到有这么多人愿意给科学事业贡献自己的算力我还是感到很开心的，如果感兴趣的话欢迎加入这些科学计算项目~\n","date":"2021-11-20T00:00:00Z","image":"https://zyxin.xyz/blog/2021-11/UtilizeYourComputationPower/primenet-ranking.png","permalink":"https://zyxin.xyz/blog/2021-11/UtilizeYourComputationPower/","title":"冬日取暖最佳方式 — 利用闲置的计算资源"},{"content":"Termux是一款在Android上运行的终端模拟器，其中内含了一个非常轻量的Linux环境，并且使用apt做包管理器。最新的Termux已经不在Play Store上更新了，安装需要去Github或者官网。旧版本的Termux在使用apt的时候可能会碰到问题。\n近来因为买了Surface Duo，在手机上稍微折腾了一下Termux，尝试是否能把手机变成Linux级别的生产力工具。结论当然是不可以，一方面性能不够，另一方面Termux上的包还是太少了，不过还是记录一下一些环境设置方法，供之后查阅。\n另外，Termux支持通过proot包来安装完整的Linux系统，最有名的是TermuxArch。在安装完完整系统之后，理论上你的手机就已经变成完整的Linux电脑了！不过由于我并不需要那么多功能，我没有走这一条路线。\nssh客户端 在手机上使用ssh客户端还是非常实用的，这样可以随时随地监控各个电脑的情况，并且不怎么耗流量。在Termux里面安装ssh非常简单，直接\n1 pkg install openssh # or apt install openssh, pkg=apt in Termux 如果你像我一样主要通过SSH Key连接各主机，那么你可能需要安装Termux:API以便于从手机中拷入密钥到Termux中，还需要手动开一下ssh-agent服务。建议直接在.bashrc（可能需要新建）中加入以下内容\n1 2 eval \u0026#34;$(ssh-agent -s)\u0026#34; # ssh-add your_key 然后如果你在服务器上有像我一样配置Powerline的话（可参考我之前的美化terminal的博客），你可以安装Termux:Styling这个app，然后在Termux中就可以选择Nerd Font了，非常不错！\nRust环境配置 Termux的仓库中直接有提供rust，因此可以直接\n1 pkg install rustc-dev 这个命令会顺带装上Clang编译器。\nPython环境配置 我尝试的另一大内容就是在Termux里面搭建基本的Python环境。Termux只提供了Python的包，几乎没有提供其他任何包，因此需要手动安装。你可以直接选择安装Anaconda，但是目前由于兼容性的问题，Termux中无法运行很多给aarch64架构编译的文件，这个问题在之后也许会被Termux解决。\n首先是安装python，直接pkg install python即可。在我这次安装的时候，Python已经直接是3.10的版本了，很不错。然后用get-pip.py脚本可以安装上pip:\n1 2 3 pkg install wget wget bootstrap.pypa.io/get-pip.py python get-pip.py 有了pip之后纯Python的包就可以直接装了，而用到Python扩展的包（如numpy）则需要编译器和对应的依赖项。编译器我在之前装Rust的时候顺便装上了，也可以直接通过pkg安装Clang（Termux仓库里只有Clang没有GCC）。\n安装Numpy时如果系统里没有BLAS包，安装可以成功完成，但是会有警告，并且性能欠佳。这次我尝试给安装了一下OpenBLAS，过程还挺顺利的，命令如下\n1 2 3 4 5 6 7 wget https://github.com/xianyi/OpenBLAS/releases/download/v0.3.18/OpenBLAS-0.3.18.tar.gz # choose your version tar -xzf OpenBLAS-0.3.18.tar.gz cd OpenBLAS-0.3.18 pkg install perl binutils # install dependencies make -j4 make PREFIX=/data/data/com.termux/files/usr install 安装好OpenBLAS之后再pip install numpy，这时Numpy会自动找到OpenBLAS。在有了Numpy之后，许多依赖于Numpy的包也很容易能装上了（如Cython、Pandas，但是Scipy装不了，因为Scipy需要Lapack和gfortran，这意味着需要把GCC的工具链导进来，这里我就懒得弄了。如果有需要的话一位Github老哥自己搭建了一个apt仓库，可以从那里安装）\n之后我还尝试了安装Jupyter Notebook和matploblib / plotly\n1 2 3 4 5 6 7 8 # install jupyter notebook pkg install libzmq # dependency for jupyter notebook kernel pip install notebook # install pillow, and then matploblib / plotly pkg install libjpeg-turbo libtiff freetype libwebp tcl tk libraqm littlecms zstd LDFLAGS=-L/system/lib64 pip install pillow pip install matplotlib plotly 值得一提的是就如前文所说，Termux好像无法正常运行通常给aarch64编译的包，有可能是因为没有glibc，或者其他依赖项。因此在Termux中尽量使用官方仓库提供的包，保证没有问题，如果要用其他未提供的包则很有可能需要重新用Clang编译。这也是我尝试安装Anaconda和.Net Core但是都失败了的原因。\nTermux好像还支持X11，因此你可以在手机上运行GUI程序！简直牛逼！不过我也没有需求，所以没有试。要实现这个功能需要安装X11服务器，可选的有XServer XSDL和Termux团队正在开发的Termux:X11。用XServer XSDL运行TermuxArch可以参考这个教程。\n最后虽然我把需要环境弄得差不多了，甚至成功在手机上运行了Jupyter Notebook并且试着画了几张图，但是最后我其实还是发现，Termux最好的归宿还是SSH客户端，毕竟手机的性能限制摆在那里。不过这些工具（尤其是Python）在有时候想随手做点或者算点什么东西的时候还是非常有用的。仅供参考~\n","date":"2021-11-19T00:00:00Z","permalink":"https://zyxin.xyz/blog/2021-11/TermuxSetup/","title":"让你的手机变身Linux — Termux设置"},{"content":"近些年一直有听闻Rust的发展，相比其他新语言（如julia），我觉得Rust是切实解决了一些程序开发的痛点的，并且Rust比较适合作为底层软件开发的语言，我很感兴趣。Rust官方有一本Gitbook教程，因此我就直接通过阅读它来上手Rust了。\n本文记录一些我在看完这本书之后初步总结的一些Rust与我熟悉的Python/C++/C#之间的各方面的异同。如果你也有Python/C++/C#的编程经验，并且想上手Rust，那么这篇文章应该能帮助你概括性地了解Rust的特性。本文也是我对Python/C++/C#之间特性的一个对比总结，但是我对这些语言的了解也没有那么深，因此如有谬误还请指教。\n备注：\n本文中的代码仅为代码片段，对于Python之外的代码你可能需要将部分代码放在主函数中才能正确运行。 本文的代码格式以精简为主，没有按照语言的标准格式编写。 语法 赋值 在变量进行赋值的时候，内容的传递有三种模式：传引用、复制、移动。其中最后一种指的是旧内容被复制到新对象中，然后旧对象中的内容变为不可用。\nPython: 是传引用 C#: 引用类型是传引用、值类型是复制 C: 都是复制，但是是浅复制 C++: 默认是复制，但是可以通过std::move实现移动（需要C++11) Rust: 默认是移动。复制需要使用.clone() 初始化 这几种语言初始化一个对象的语法有不少相似之处，因此列举在这里供比较。 {% tabs Function Code Example %}\n1 2 3 4 5 6 7 8 9 10 11 ##### initialize class instance ##### class Point: def __init__(self, x, y): self.x = x self.y = y p = Point(1, 2) ##### intialize array ##### arr = [Point(1, 2)] * 10 # use list algorithmic operator arr = [Point(1, 2) for _ in range(10)] # use list comprehension 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 ///// initialize struct instance ///// typedef struct Point { double x, y; } Point_t; // declare and initialize Point_t p; p.x = 1; p.y = 2; // bracket initialization Point_t q = { 1, 2 }; Point_t r = { .x = 1, .y = 2}; // initialize on heap Point_t *s = (Point_t *)malloc(sizeof(Point_t)); s-\u0026gt;x = 1; s-\u0026gt;y = 2; ///// initialize array ///// Point_t arr[10]; // declare without initialization Point_t arr2[5] = { {.x = 1, .y = 2}, {.x = 3, .y = 4} }; // initializer, here the third value is uninitialized Point_t arr3[] = { {.x = 1, .y = 2} }; // the size of array is inferred to be 1 Point_t arr4[5] = { {.x = 1, .y = 2}, [1 ... 4] = {.x = 3, .y = 4} }; // range initialize 2nd ~ 5th item int arr_2d[3][3] = {1,2,3,4,5,6,7,8,9}; // you can even initialize 2D array with bracket initialization int arr2_2d[3][3] = {{1,2,3},{4,5,6},{7,8,9}}; // declare the array on heap with 5 items Point_t *arr5 = (Point_t *)malloc(5 * sizeof(Point_t)); free(arr5); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 ///// initialize class instance ///// class Point { public: double x, y; // C++ will create default constructors with no args, field args and initializer list }; // declare and initialize Point p; p.x = 1; p.y = 2; // direct initialize Point q(1, 2); // initializer Point r { 1, 2 }; // list initializer (C++11) Point s { .x = 1, .y = 2 }; // aggregate initializer (C++20) // initialize on heap Point *t = new Point(1, 2); Point *u = new Point{1, 2}; ///// initialize array ///// // C++ supports all initialization method from C, but you might need C++11/20 // declare the array on heap with 5 items Point* arr = new Point[5]{ {1, 2} }; // all initializer syntax can be used here delele[] arr; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 ///// initialize class instance ///// class Point { public double X { get; set; } public double Y { get; set; } Point() {} Point(double x, double y) { X = x; Y = y; } } // declare and initialize Point p = new Point(); p.x = 1; p.y = 2; // constructor Point q = new Point(1, 2); Point r = new Point { X = 1, Y = 2 }; // anonymous type var s = new { X = 1, Y = 2}; ///// initialize array ///// Point[] arr = new Point[3]; // new array with null values (or default value for struct type) Point[] arr2 = new Point[3] { p, q, r }; Point[,] arr2d = new Point[2, 2] { {p, q}, {r, r} }; // initialize 2d array var numbers = new Dictionary\u0026lt;int, string\u0026gt; // initialize object with indexers { [7] = \u0026#34;seven\u0026#34;, [9] = \u0026#34;nine\u0026#34;, [13] = \u0026#34;thirteen\u0026#34; }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ///// initialize struct instance ///// struct Point { x: f64, y: f64 } let p = Point { x: 1., y: 2. }; // rust don\u0026#39;t automatically cast the type let q = Point { x: 2., ..p }; // partial copy from another instance let x = 2.; let r = Point { x, y: 2. }; // using the variable with the same name in scope ///// initialize array ///// let _: [u8; 3] = [1, 2, 3]; let arr: [Point; 3] = [ p, q, r ]; {% endtabs %}\n只读 Python： 没有什么东西是只读的，你唯一能做的就是hack一些函数，让别人在修改的时候报错 C: 有const关键字，可以定义全局常量或者函数内常量 C++: 有const，constexpr（后者更接近C的const，需要C++11），成员函数可以单独控制只读性，相当于可以对成员函数的this参数加上const C#: 有readonly, const，前者修饰不变量而后者是编译器常量。C# 9引入了record，可以实现immutable。 Rust: 变量默认都是不可变的，可变需要添加关键字mut（这个名字可太迷惑了，默认不可变的东西是不是不应该叫变量），成员函数可以通过外置定义的第一个参数单独控制只读性(self\u0026amp; / mut self\u0026amp;)，这个逻辑类似C++ {% tabs Const Code Example %}\n1 2 # usually people follow certain style (like all uppercase) to name the constant variable SOME_CONSTANT = 1 1 const int SOME_CONSTANT = 1; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // constexpr is used for compile time constant constexpr int SOME_CONSTANT = 1; constexpr int constexpr_func() { return 1; } // const can be used to describe class members class Coords { void shift (const Coords \u0026amp;offset); double sum() const { return _x + _y; }; const double _x, _y; Coords(double x, double y) : _x(x), _y(y) {} // const field must be initialized using initializer list } // const variables are only able to call const member function const Coords coord; coord.sum(); // coord.shift() is illegal here 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // `const` is used for compile time constant const int SOME_CONSTANT = 1; class SomeType { public const int const_field = 1; // the value still need to be defined in compile time private readonly string const_field2; SomeType(string str_in) { const_field2 = str_in; } // readonly field must be initialized in declaration or constructor } // since C# 7.2, readonly can be used to declare immutable type public readonly struct Coords { public Coords(double x, double y) { X = x; Y = y; } public double X { get; init; } public double Y { get; init; } public readonly double Sum() { return X + Y; } // C# 8.0 } // alternatively readonly can be applied to properties individually public struct Coords { public Coords(double x, double y) { _x = x; Y = y; } private int _x; public double X { readonly get =\u0026gt; _x; } public readonly double Y { get; init; } // C# 9.0 } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // use `const` for compile time constant const SOME_CONSTANT: u32 = 1; let some_constant = 1; // immutable by default let some_constant = 2; // this will shadow the previous definition struct Coords { x: f64, y: f64} impl Coords { fn sum(\u0026amp;self) -\u0026gt; f64 { // the instance is also immutable in methods self.x * self.y } fn offset(\u0026amp;mut self, Coords offset) { self.x += offset.x; self.y += offset.y; } } {% endtabs %}\n全局变量、静态成员 静态成员可以看作从属于某个范围的全局变量\nPython: 支持全局变量，但是在全局范围以外默认不可变，可变需要使用global关键字 C: 支持全局变量 C++: 支持全局变量，并且支持namespace级别的，支持静态变量，并且支持函数内定义静态变量 C#: 不支持，可以通过类型的静态变量和静态构造函数实现 Rust: 支持，通过const或者static关键字。由于rust无法追踪静态变量的引用，因此使用静态变量需要在unsafe代码块中。 {% tabs Global Code Example %}\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # variables defined in global are global variables counter = 0 def some_func(): print(counter) # global vars are available in the current module def some_func_mod(): global counter # you need `global` keyword to modify counter += 1 class Player: def __init__(self, id): self._id = id counter = 0 # member defined in class is actually a static member @staticmethod def create_player(): player = Player(counter) counter += 1 return player 1 2 // variables defined in global are global variables int counter = 0; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 int counter = 0; // this is a global variable namespace sub { int sub_counter = 0; // this is a global variable, but here \u0026#34;global\u0026#34; is a namespace static int counter2 = 0; // rarely used, static here means the variable is local to this compliation unit (this source file) } class Player { int id = 0; // static members of a class static int counter = 0; static Player create_player() { return Player { counter++ }; } // static variable can be inside a function static Player create_player2() { static int counter2 = 0; return Player { counter2++ }; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // there is no global variable, you have to tie the variable to a class. // But note that const variable can be in global scope, and you don\u0026#39;t need to declare it as static static class Utility { static int counter = 0; static readonly int some_constant; static Utility() { some_constant = 1; // the static constructor can be used to assign value to static readonly object } } class Player { Player(int id) {} private static int counter = 0; public static Player create_player() { return new Player(counter++); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // you need static keyword to declare global/static variables static some_constant: i32 = 1; static mut counter: i32 = 0; struct Player(i32); fn create_player() -\u0026gt; Player { println!(\u0026#34;{}\u0026#34;, some_constant); // read constant static variable is safe unsafe { // read and write to mutable static variable is unsafe in rust counter += 1; } return Player(counter) } {% endtabs %}\n异常处理： Python：exception, try catch finally, raise C++: assert, static_assert, throw C: error code, assert C#: exception, try catch finally, throw Rust: Result 枚举和 panic! 空变量，空类型 Python: None，是个对象，类型为NoneType C: (void*)NULL 空指针，空类型void C++: nullptr 空指针, std::Optional\u0026lt;T\u0026gt;，空类型void C#: null 本质上是空指针, Nullable\u0026lt;T\u0026gt;, ?操作符支持，没有空类型 Rust: 不提供空类型，Option\u0026lt;T\u0026gt;，?操作符支持，有个单元类型（unit type）()可以看作空类型，用于填充类型参数，另外还有!类型（叫“从不”类型）专门指无返回值的函数或者表达式 别名 Python: 类本身也是对象，可以赋值给别的变量。而import .. as ..语法也可以实现别名 C: typedef, #define C++: typedef, using, #define C#: using Rust: type .. = .., use ... as 函数声明 Python: 支持默认参数，以列表、字典两种方式支持可变参数 C: 支持变长参数，不支持默认参数 C++: 支持变长参数、变长模板参数（variadic type param)，支持默认参数 C#: 支持默认参数、变长参数(params)，不支持变长形参 Rust: 不支持默认参数和变长参数，前者一般通过Option\u0026lt;T\u0026gt;实现，后者一般通过宏实现 ?语法糖 Python: 可以通过or变相实现 C/C++: 无 C#: ?可以用在引用类型上，或者Nullable\u0026lt;T\u0026gt;加值类型上，还有??操作符 Rust: 可以用在Option\u0026lt;T\u0026gt;和Result\u0026lt;T, E\u0026gt;上 Unicode 字符串 Python: 在Python 2里，bytes=str，都表示的是ANSI字符串，而Unicode字符串需要用unicode类型，常量需要用u\u0026quot;文字\u0026quot;。在Python 3里，bytes可以表示ASCII字符串，而str是支持Unicode了，\u0026quot;文字\u0026quot;直接就是UTF8字符串。 C: 甚至没有专门的字符串类型，只有char数组 C++: std::string并没有专门支持Unicode，它可以用来存储Unicode字符串，但是没有针对性的处理工具。声明UTF8字符串需要用u8\u0026quot;文字\u0026quot;格式的前缀。处理Unicode字符一般会选择ICU这个C++库。 C#：String是带有编码信息的，并且System.Encoding里面有String和byte[]相互转换的工具。 Rust: 最常用的String字符串是UTF8编码的（好像不支持UTF16？），并且支持Unicode字符的操作（如字符边界等），另外还有str类型是个slice类型。Rust还提供了CString来表示ANSI字符串。 宏 Python: 不支持 C: 仅支持#define系列和#if系列 C++: 支持的非常丰富，甚至有专门的库。。。 C#: 仅支持#if系列 Rust: 有三种宏，声明宏（Declarative macro），主要是进行匹配和展开，类似于C/C++用宏来枚举类型；过程宏（Procedural macro），可以解析语法树，从struct结构生成代码；类属性宏（Attribute-like macros），可以从任意代码生成任意代码；类函数宏（Function-like macro），通常用于解析一小段token 修饰器 Python: decorator C/C++: 无，一小部分功能可以通过宏实现 C#: Attribute Rust: 类属性宏 类型系统 Python: 有class，不过类也是对象，是一个用来生成其他对象的对象。 C: 只有struct（和union） C++: 有struct和class，但是struct只是一个成员默认为public的class，没有本质区别，是为了兼容C而存在的。 Rust: 只有struct（unsafe模式下有union） C#: struct、class、interface、enum、delegates。其中struct/enum是值类型、class/interface/delegates都是引用类型，在之间转换会有封箱和拆箱操作。 定义成员函数（method/member function） Python: 在class代码块里写，也可以动态给Python对象添加函数（过于牛逼，不过定义了__slot__的对象除外） C: 没有成员函数一说 C++: 在class代码内部写或者使用外部声明语法 C#: 在class代码块内部写，但是有个partial关键字非常给力，可以让一个类的代码块分成几个区域 Rust: 有个impl代码块，只有外部声明语法，并且如果是泛型的话也得标记上类型参数。在逻辑上更像是C的写法 强/弱类型 Python: 弱类型，没有类型检查，只有Python 3.5引入的类型标注。你可以使用mypy来实现类型标注检查，但是错误的类型并不会影响程序运行。 C: 强类型，所有变量和参数均需要声明类型 C++/Rust/C#: 强类型，在这些语言中，绝大部分情况下变量和参数都拥有固定的类型，但是他们也提供不同程度的类型推断。此外他们也支持均动态类型。 类型推断 Python: 动态类型，无需推断 C#: var关键字 C++: auto关键字 (C++11) C: 无 Rust: 默认推断，并且推荐能不写类型就不写，交给编译器，这无疑使代码更简洁了。 动态类型 动态类型一般仅在强类型中被提及，因为弱类型语言一般不进行类型检查，其指的是类型检查推迟到运行时。动态类型通常可以分为两种，一种是变体类型（Variant），指的是变量可以是几个类型中的任意一种；另一种是任意类型（Any Type），更接近动态类型的本身，指的是变量可以取任意类型。\nPython: 弱类型语言 C#: 支持，有dynamic关键字可以使类型检查在运行时进行（需要C# 4），通过System.Dynamic.ExpandoObject和System.Dynamic.DynamicObject类型实现动态成员，并且还支持匿名类型 C: 通过void*指针可以变相实现任意类型。 C++: 通过std::variant\u0026lt;...\u0026gt;和std::any\u0026lt;T\u0026gt;可以分别实现变体类型和任意类型（均需要C++17)，也可以通过reintepret_cast进行强制转换。 Rust: 通过Enum可以实现变体类型，通过trait object（dyn关键字+Box）可以部分实现任意类型。 这里的dynamic其实是指的dynamic dispatch（动态分发），也就是类型参数在运行时展开。静态分发就类似于C++的模板，而动态分发就更接近C#的运行时泛型。\n反射/内省 反射和内省的概念可能只有学过C#的人比较熟悉，它指的是在运行时获取类型的信息，例如所有的方法、所有的成员变量等等。\nPython: 通过__dict__接口，以及hasattr, getattr, setattr三剑客可以实现动态获取类成员。 C: 不支持，唯一相关的就是sizeof关键字，只能获取类型对象的大小。 C++: 除了sizeof以外还有typeid关键字，但是获取的type_info对象只有名字信息，仅用于比较。 C#: 通过Object这个基类所支持的GetType()方法可以获取类型信息，返回一个Type对象。这个对象包含了非常丰富的内容，可以获取名字、成员列表、嵌套类型信息等等 Rust: Any trait有get_type_id方法，类似于C++的typeid，仅用于类型比较。 面向对象 封装 Python: 除C扩展之外，几乎所有对象都是公开的，无法限制访问，只有一个约定俗成的_和__习惯（_开头的变量表示私有成员，形如__xxx__的变量表示特殊成员） C: 无访问控制，但是编译之后的library一般是无法修改的，因此可以通过选择头文件的内容来阻止访问部分代码。 C++: public/private/protected关键字可以指定成员，或者继承的基类的可见度。另外还有friend关键字指定特定的可见关系，C++还可以通过匿名命名空间实现模块的私有化。 C#: public/private/protected关键字类似于C++，但只能修饰类成员。另外还有internal关键字可以实现仅对同一个二进制内的代码公开的能力。 Rust: 默认模块、类型、成员均为private，有pub关键字使得祖先可以访问。与其他语言不同的是pub可以修饰模块，并且其公开性是仅对祖先模块的。 继承、多态 Python: 可以多继承，使用Mixin的写法是个常用的范式。 C++ 可以多继承，也有trait体系，还有virtual和override。菱形问题可以通过虚继承解决。 C#: 只能继承一个基类，可以继承多个接口。引用类型的基类都是object，而值类型是ValueType（虽然ValueType继承了object，但是编译器会有特别处理）。另外C#还有抽象类（abstract)，virtual, override, sealed。在C# 8之后支持接口的默认实现。 Rust: 没有继承，但是可以定义和实现trait（即接口），并且接口支持默认实现。 Rust 在书17.1中认为，用继承的方式实现多态已经越来越不主流了，实际在使用时我确实也发现自己的代码里需要使用继承的方法不多，有点同意这个观点，但是我也仍能想到使用继承的场景，尤其是在面向现实问题以及GUI相关的代码中。而在数据结构中其实使用trait系统会更方便（尤其是二叉树定义其node类型的时候）。当然我猜测Rust选择不引入继承系统的原因还可能是它可能会带来的overhead（如果要允许子类实现自己的方法被父类调用，那就必然会需要虚函数，而这会引入vtable产生内存开销）。 一个比较奇怪的设计是Rust的trait支持静态函数（associated function），直觉上来说接口不应该限制静态成员的设计，毕竟接口方法都是与类型实例相关的，C#的接口中就不允许添加静态成员\n泛型 Python: 动态类型不需要泛型 C# 有泛型，并且通过where支持类型限制，编译时不展开 C 无泛型，但是可以通过指针强制转换进行类型变换以支持动态类型 C++ 有模板，在编译时会展开，并且模板的功能远超一般的泛型。模板参数支持整数 Rust 有泛型，并且通过where支持类型限制，但是在编译时会展开。Rust 1.47正在测试模板参数支持整数。 函数式编程 函数对象和闭包 Python: 函数也是对象，想怎么玩都可以。Python的局部函数可以当作闭包使用 C: 仅支持函数指针 C#: 有匿名函数和lambda函数，还有Delegate/event，lambda函数是闭包，并且无需指定如何封装环境内变量 C++: 有lambda函数和std::function，lambda函数是闭包，并且可以细致地指定如何封装环境内的变量 Rust: 有闭包，可以赋值给Fn trait，支持局部函数但局部函数不是闭包。封装方式可以通过Fn/FnMut/FnOnce或者move关键字进行指定。普通的函数指针有fn类型 匿名函数仅仅指不需要指定函数名的函数，而closure是能够使用外部scope变量的函数，一般是匿名函数，但也可以不匿名。lambda函数即匿名函数，有可能是一个闭包\n{% tabs Function Code Example %}\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # normal function def add(a, b): return a + b func = add # function is also an object # closure, usually used in decorators def closure(): some_value = 2 def increase(x): return some_value + x return increase func = closure() # lambda function (which is a closure) prefix = \u0026#34;INFO:\u0026#34; log_handler = lambda x: print(prefix + x) 1 2 3 4 5 6 7 8 // normal function int add(int a, int b) { return a + b; } // function pointers int (*fn_ptr) (int, int) = \u0026amp;add; int (const *fn_cptr) (int, int) = \u0026amp;add; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // normal function int add(int a, int b) { return a + b; } // function pointers are also supported in C++ // note that the syntax can be much more complex in C++ than in C int (*fn_ptr) (int, int) = \u0026amp;add; int (const *fn_cptr) (int, int) = \u0026amp;add; // std::function is a safer pointer implementation // (since C++11, you can use boost::function before C++11) std::function\u0026lt;int (int, int)\u0026gt; func = add; // lambda function (which is a closure, since C++11) std::string prefix = \u0026#34;INFO:\u0026#34;; auto log_handler = [\u0026amp;prefix](std::string x) { std::cout \u0026lt;\u0026lt; prefix \u0026lt;\u0026lt; x; } std::function\u0026lt;void (std::string)\u0026gt; func2 = log_handler; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // normal function int add(int a, int b) { return a + b; } // delegates are function pointer types in C# public delegate int AddFunc (int a, int b); AddFunc func = add; System.Func\u0026lt;int, int, int\u0026gt; func2 = add; // there are also predefined delegates // C# also provides Event to handle a chain of functions // (usually used in GUI applications) public event AddFunc addEvents; addEvents += func; // lambda function in C#, note that the types of parameter and return value // are decided by the function type signature string prefix = \u0026#34;INFO:\u0026#34;; System.Func\u0026lt;string, void\u0026gt; log_handler = (x) =\u0026gt; Console.WriteLine(prefix + x); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // normal function fn add(a: i32, b: i32) -\u0026gt; i32 { a + b } // function pointer has type `fn` let func: fn(i32, i32) -\u0026gt; i32 = add; // define and return closure // You need to wrap closure with Box in order to return it since the size of closure is unknown for compiler fn closure() -\u0026gt; Box\u0026lt;dyn Fn(i32) -\u0026gt; i32\u0026gt; { let some_value = 2; let increase: Fn(i32) -\u0026gt; i32 = |x| some_value + x; Box::new(increase) } let func_boxed = closure(); {% endtabs %}\n模式匹配 Python: 3.10开始引入支持 C: 不支持 C++: 暂无语言内置支持，但是可以通过魔改模板实现，例如Mach7 C#: C# 7引入switch支持 Rust: 内置match支持 遍历器（iterator） 关于异步遍历参见后文异步一节\nPython: 内置iter(), generator类型, yield，Python 3.6之后支持async函数中使用yield C++: 没有语言支持，但是在STL里面定义了一套通用接口，有std::foreach，也有for(type value: collection)语句 C: 不支持 C#: IEnumerable, foreach, yield return。C# 8.0之后引入IAsyncEnumerable\u0026lt;T\u0026gt;，支持异步返回流（即在async函数中使用yield return)。(这个功能支持的比Python晚好多= =) Rust: 容器类型的iter()方法 元组（tuple） Python：内置tuple类型，不限长度，一个重要区别是python的tuple是不可变(immutable)的, Cython的ctuple C++: std::tuple，也不限长度，C++17支持解构语法？（structure binding） Rust: 内置tuple支持，tuple类型的签名例如(u32, u32)，长度虽然不限，但是有些语法只支持最长12个对象hhhh C#: 曾经对tuple的支持只有System.Tuple\u0026lt;T1, T2, ...\u0026gt;，由于C#不支持变长类型参数，因此这个Tuple类型变得相当冗余，而且也很麻烦。在C# 7之后引入了tuple的语法，之后使用起来就方便多了 不安全代码、C交互 Python: 由于Python的最常用解释器CPython就是基于C的，并提供了丰富且完整的C-API，因此Python对与C交互的支持非常好，这也是Python被常用为胶水语言的原因。调用C-ABI可以使用内置的ctypes库, 而如果想给C/C++代码写Python API，则可以用Cython、pybind11、boost.Python C#: C#是托管语言，可以使用unsafe编写操作指针的代码, 利用DLLImport（P/Invoke）可以调用C-ABI C++: C++本身是C的超集，几乎可以完美兼容C，也就是说C/C++的代码混合编译是没有问题的。另外在extern代码块中的函数和类不会被混淆（mangle），可以生成C-ABI Rust: 在Rust中使用unsafe代码块可以不进行引用检查, extern代码块可以避免函数签名被混淆（mangle） 并行和异步 由于Rust对变量生命周期的严格管理，在Rust中进行并行和异步会变得非常麻烦，Rust官方专门有一本独立的书介绍相关的异步内容，在这我就不细展开Rust的用例了，仅介绍大致的用法，留个印象。因为我也还没学会\n关于协程、线程、进程之间的区别可以参考我之前的这篇博客。\n异步和协程 我对Python和C#的异步都有一定的使用经验，对C++的也略有了解，不得不说还是C#的异步语法使用起来最舒服。这也是部分得益于托管语言带来的好处，像C/C++/Rust想要实现异步就需要非常麻烦的语法和生命周期管理。\nPython: Python 3.5引入了async，await关键字，并且有asyncio库实现各个层级的异步封装（封装过多反而导致使用起来很摸不着头脑） C: 没有内置支持 C++: \u0026lt;future\u0026gt;库提供了异步的初步支持，C++20引入co_await，终于在语言层面支持了程序流中插入异步块，不过真是太不elegant了，并且还只主要是给库的开发者用的。另外好像C++的协程默认都是单开线程的，而不像是其他语言可以进行单线程协程。 C#: 从C# 5.0引入了async，await关键字，应该是这些语言中引入最早的，也是支持最简明的，最容易上手的。C# 7.0后await的对象可以自定义类型了。 Rust: 有async, await关键字支持 {% tabs Async Code Example %}\n1 2 3 4 5 6 7 8 9 import asyncio # define and use async function async def io_task(): print(\u0026#34;fake io processing...\u0026#34;) await asyncio.sleep(1) # launch the task in the current thread asyncio.get_event_loop().run_until_complete(io_task()) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // before C++20 #include \u0026lt;future\u0026gt; #include \u0026lt;thread\u0026gt; bool io_task () { std::cout \u0026lt;\u0026lt; \u0026#34;fake io processing\\n\u0026#34;; std::this_thread::sleep_for(std::chrono::seconds(1)); return true; } std::future\u0026lt;bool\u0026gt; fut = std::async(io_task); // start a thread to run the task bool result = fut.get(); // wait for the result // co_await has been introduced in C++20, but it\u0026#39;s still not ready to use 1 2 3 4 5 6 7 8 9 10 11 12 using System.Threading.Tasks; async Task io_task() { // the return type for async functions is void / Task / Task\u0026lt;T\u0026gt;. For WinRT, you\u0026#39;ll need IAsyncOperation in place of Task Console.WriteLine(\u0026#34;fake io processing...\u0026#34;); await Task.Delay(1000); } io_task().Wait(); // start the coroutine and wait for its completion, very intuitive async void io_task_detached() { await io_task(); } io_task_detached(); // start the coroutine and don\u0026#39;t wait for it. 1 2 3 4 5 6 7 8 9 10 11 use std::time::Duration; use async_std::task; // async function has normal return types async fn io_task() { println!(\u0026#34;fake io processing...\u0026#34;) task::sleep(Duration::from_secs(1)).await; } // async block returns a Future\u0026lt;T\u0026gt; object task::block_on(async {io_task()}) {% endtabs %}\n线程 Python: 虽然Python提供了threading库，但是由于CPython全局锁的存在，实际上通常情况下同时只能执行一个线程，只有在进行IO操作的时候threading会非常游泳 C: 在POSIX系统上通常使用pthread库，而在MSVC下面则可以使用pthread_win32或者Windows API C++: \u0026lt;thread\u0026gt;库提供了线程的相关支持（需要C++11） C#: System.Threading提供了线程的相关支持 Rust: std::thread标准模块中提供了线程的相关支持，不过由于Rust对变量声明周期的管理，写代码时经常需要用到Mutex和Arc 进程 Python: 在os和subprocess库中提供了创建进程的函数。另外Python还在multiprocessing库中则是提供了非常方便的MPI接口，这是Python比其他语言都好用的地方，可能也算是对全局锁的补偿把。 C: 在POSIX系统上通常使用unistd.h中的fork，而在MSVC下可以使用Windows API C++: 标准库中并没有提供支持，可以用boost.process库来解决 C#: System.Diagnostics中的Process类提供了相关支持 Rust: std::process标准模块中提供了进程相关支持。 包管理器 为什么要专门拎出来这一点，是因为包管理是我放弃julia的最大理由。。。\nPython: pip挺不错，安装方便使用简单；conda功能更强大，更方便支持带C扩展的包，但是性能差 C/C++: 一般都依赖Linux的包管理器。在Mac上有brew，而在Windows上只到最近vcpkg的出现才算勉强有了可用的包管理。总体而言还是没有好用的包管理器，甚至编译体系都有好几种（conf/make, autoconf, CMake, Qt的qmake, Boost的b2, Visual Studio的nmake, \u0026hellip;），这也是C++挺劝退的点。 C#: nuget，算不上好用但好在有宇宙第一IDE——VS的支持。 Rust: cargo，目前的体验都挺友好的~设计上比较像npm 常用数据结构 下表总结了各个语言中常用数据结构的对应关系（非严格对应，他们的实现上或多或少有点区别）\nPython C++ C# Rust list vector List Vec SortedDict map SortedDictionary BTreeMap dict unordered_map Dictionary HashMap SortedSet set SortedSet BTreeSet set unordered_set Set HashSet - function Action/Func Fn/FnMut/FnOnce - list LinkedList LinkedList deque deque Queue VecDeque heapify make_heap PriorityQueue BinaryHeap - unique_ptr - Box - smart_ptr - Rc 另外，C++ std::const_cast 可以在 Rust 中用Cell\u0026lt;T\u0026gt;和RefCell\u0026lt;T\u0026gt;起到类似效果(对应引用类型和指针类型？) Rust特有的特性 在别的语言里面没有的概念，以及Rust独特的语法特性如下\n引用检查（Borrow checker） 生命周期（Lifetime）声明 {}代码块和if、else、break也都是表达式，而非语句 功能强大的宏系统 总而言之，语法设计上最优雅的我觉得还是C#和Python，功能和性能最强大的还是C++，最简单和底层的还是C，但是Rust至少有望替代C，这也是我为什么学习这些语言的原因。Rust有一些语法，虽然套用了同一个格式，但是却有很多是编译器特殊支持的（最常见的就是跟Trait相关的，如Box），这就使得Rust有时候很不优雅，关于这一点可以看TUNA的讲座。\n本文仅为我读完Rust官方入门教材之后的总结，之后有实战经验了我可能会再写一些心得吧~\n另外在总结本文的时候还发现了一个对比Kotlin和C#的网页，挺有意思的，贴在这供参考\n","date":"2021-10-29T00:00:00Z","permalink":"https://zyxin.xyz/blog/2021-10/FirstGlanceOnRust/","title":"初识Rust - 从一个Python/C++/C#程序员的角度对比Rust"},{"content":"最近几年一直有新的编程语言变火，也不断的有新概念的出现。我一直有打算了解各种新的编程语言，并且如果有前景的话多学一门语言也是挺好的。因此本文总结我在了解一些流行的现代语言的过程中，记下来他们的各种特点。如果你也有兴趣尝试新的语言，那么希望这个文章可以帮到你~\n关于语言的流行度可以参考TIOBE排名、Github排名和Stack Overflow排名。本文也不会详细介绍每个语言的特性，因为每种语言都用非常多的特性，而且很多也都还在不断开发中。正因如此，本文的评价也仅限用与写下本博客的时候。\n本文主要关注通用程序语言，对于一些领域专用语言（Domain-Specific Language）如SQL就不比较了，因为他们是你需要的时候你就会用，你不需要的话也不需要学。\n关于编程语言的演变，下面是一个很精炼的图（来源点我），如果想要更完整的演变关系的话可以参考维基的程序语言编年表（按年代和按年份，推荐后面那个！），或者参考这个网站。\n现代编程语言的特性 在介绍语言之前，首先还是要介绍以下各种编程语言的概念，不然会埋没很多语言的优秀属性。语言详细特性的比较可以参考维基百科的比较，这里的介绍也都是粗略的简介，如果你有兴趣的话可以搜一下这些关键词了解了解~\n面向对象(Object-Oriented)：如果有学过程序设计课程的话应该对这个是有了解的。面向对象主要指的是程序是围绕“类”(Class)来编写的。类包含了某一种对象的定义和方法，并且在此之上定义了继承关系，以便于简化代码。 动态/静态类型(Dynamic/Static Type)：静态类型指的是编程语言中所有变量都必须明确指定的类型，而动态类型语言则不需要指定变量类型。这两个特点是在灵活性和程序安全性之间做的权衡。这两个特性也被称为强/弱类型。在弱类型语言中，有**鸭子类型(Duck-typing)**的概念，也就是我们不关心变量具体是什么类型，只要它提供了指定的接口就可以了。 元编程(Meta-Programming)/泛型(Generic Type)：元编程指的是可以通过代码生成代码，最典型的例子就是C++的模板。而泛型在用法上很像元编程，但是它并不会显式地生成代码，而是可以看作支持带有“类型参数”的代码。 命令式(Imperative)/声明式(Declarative)/函数式(Functional)：命令式语言中，你需要一步步指定程序做什么；声明式语言中，你告诉语言你想要达到什么目的；函数式语言中，函数是一等公民，函数本身定义了你想达到什么目标，而程序通过不停地调用函数来实现，并且函数通常可以被存在变量里。 并行(Parallelism)：并行指的是程序支持多个代码块同时执行。具体的并行三种方法可以参考我之前的博客《进程、线程与协程》 数据科学：一些语言是针对数据科学设计的，他们主要的特点是有对高精度数值类型和多维张量的内置支持。 测试驱动(Test-driven Development)/契约式(Design by Contract)：这两个概念其实是不同的编程逻辑，测试驱动指的是程序最终的目的是通过一定的测试，而契约式编程则是指编写时，程序本身需要满足一定的条件关系。对测试和契约的支持虽然不是必须的，但是在现代大型程序中却是能大大提高程序编写效率和安全性的。 虚拟机/中间语言(Intermediate Language)：不少语言都通过虚拟机来完成跨平台的实现，编程语言的虚拟机会将语言特定的中间码翻译成机器码。其代表有JVM、CLR、LLVM。 垃圾回收(Garbage Collection, GC)：垃圾回收是不少语言运行时内置的功能，在有这个功能的语言中你不用操心变量的生命周期，因为对象的销毁由垃圾回收器帮你实现了。 下面开始介绍我对各个主流现代编程语言的一句话评价，这些语言主要选择自上文提到的排行榜。知乎有个类似的贴子，但是主要都是段子。\n一(N)句话描述为什么选择这门语言 C: YYDS，是这里面最接近汇编的语言，性能好且依赖少，C语言的ABI能够被绝大多数语言调用。 CoffeeScript: 加糖版Javascript C++: 最强大的语言之一，完整的面向对象和元编程支持，兼容C C#: 语法糖超级多，最近微软拥抱开源使得编程资源也变多，比Java快 D: 目标是替代C++，有很多现代语言特性的支持，如契约编程 Dart: 谷歌背书的取代的Javascript的语言，但是也就仅此而已了 Elixir: 基于ErlangVM的函数式语言，设计上借鉴Ruby Erlang: 有个软实时，可预期的GC，高容错，有精心设计的并行接口（Green threads） F#: C#的函数式版本 Fortran: 古老的语言，但运行非常快，甚至快过C Go: 编译巨快，独立无依赖的可执行文件，内置有完整的协程支持 Groovy: Apache开发的动态类型版Java，对标Ruby Hack: 由Facebook支持的PHP方言 Haskell: 函数式语言代表作，有很多语法概念都是从Haskell走出来的 Java: 在服务器后端应用特别广的语言，有垃圾收集，包特别多 Javascript: 前后端都非常流行的语言，语言灵活，被浏览器支持，也有非常多的包 Julia: 面向科学计算的语言，运行速度快，内置支持多维张量，有望替代Fortran Kotlin: JetBrains开发的加语法糖的Java，而且都是很现代的语法糖，可以编译为Java或者Js Matlab: 针对工程师和科学家的语言，工具包非常全，Simulink暂无敌手 Objective-C: 有啥优点吗？ Perl: 适合用作脚本语言或者胶水语言，字符串处理方便 PHP: 可以嵌入HTML，灵活，语法简单，针对服务器端 Python: 非常灵活，所有东西都是对象（包括类、函数），可读性强，与C/C++兼容好，包非常丰富 R: 针对统计科学家的语言，包也很全 Ruby: 链式调用、语法糖、跟Python一样的灵活性 Rust: 语法保证的内存安全、无垃圾回收、也就意味着运行很快 Scala: 相比于Kotlin，像是JVM上的C++，而Kotlin像是JVM上的C# Swift: 苹果开发来用以替代Obj-C的语言，定位上类似Java Typescript: 强类型版的Javascript Vala: 目标是替代C/C++在Linux的GUI编程中的地位，可以编译成C代码，因此性能不错 Visual Basic: 微软曾经在很多软件中都内置支持 一(N)句话描述为什么劝退这门语言 C: 功能过于简陋，需要用结构体和指针实现面向对象，不安全 CoffeeScript: 感觉没有核心竞争力，更多的人会用Typescript C++: 模板编译难以纠错，编译也很慢，语法糖靠各种模板和标准库实现，不优雅， C#: .NetStandard标准混乱，API经常变且不向后兼容 D: 没有好爹，没有生态，混乱的GC Dart: 感觉不如选择Typescript Elixir: 除了基于ErlangVM以外没有突出的特性 Erlang: 灵活性不够，没有好爹 F#: 没人用哈哈哈哈，要么都去用C#了 Fortran: 老式语法，没有什么现代语言特性 Go: 功能少，没有泛型、不许有未使用的变量和模块、强制{不换行 Groovy: 如果不限于JVM平台的话有更好的选择 Hack: 本来PHP就要没人用了哈哈哈 Haskell: 学它像是搞工程的人去学理论数学，包也不多 Java: 语法繁琐落后，不如C#写着优美，也不如C#性能好 Javascript: 单线程，语言过于不严格，参见下面著名的三位一体图 Julia: 超级难用的包管理器，语法也很蛋疼，且暂不适合做通用开发 Kotlin: 编译慢，此外没有特别大的缺点，不过如果不限于JVM平台的话有很多其他的选择 Matlab: 语言本身是Mathworks的专利，并且使用一定要装Matlab软件，大部分功能都可以用Python和Julia实现了 Objective-C: 只有苹果开发曾经在用，可读性差 Perl: 晦涩难懂，过于灵活，性能也不行，感觉不如用Python PHP: 单线程，仅适用于Web开发，通用性和社区活跃程度不如JS Python: 性能差，单线程（GIL） R: 比Matlab语法还蛋疼 Rust: 编译器太严格、字符串操作很蛋疼 Ruby: 目前主要是后端工程师使用，性能差 Scala: 比Kotlin难上手，与Java互操作性也较差 Swift: 如果不是开发iOS和OSX没必要用 Typescript: 如果不是Web开发没必要用 Vala: 主要用户是Gnome和ElementaryOS，生态还不是很完善 Visual Basic: 如果没有历史包袱就不要用了 拓展阅读 为啥Erlang没有像Go、Scala语言那样崛起 ","date":"2021-08-05T00:00:00Z","permalink":"https://zyxin.xyz/blog/2021-08/OneLinePerProgrammingLanguage/","title":"一句话选择现代编程语言"},{"content":"在我的收藏里面，音乐是占大头的。我非常喜欢尝试各种风格的音乐，也非常喜欢日本音乐圈的多样性，因此收集了很多。在这过程中也了解到了一些音频格式的内容~我也自己做过一个benchmark，比较不同音频编码的性能区别，如果有兴趣的话可以自己尝试一下~。\n我个人喜欢收藏无损音乐，目的不仅仅是因为高音质，而是无损意味着“无损”，音质与CD或者其他音源是完全一致的（当然，这个一致性音频编码本身并不能保证音源的完整性，但是如果有其他的辅助信息如EAC log，或者AccurateRip测试结果就完全可以保证了）。在这个情况下我把无损压成有损，就能保证这个有损是达到了预期的音质。如果是网上直接下载有损的话，一是很难确定这个有损有没有经过二次压缩，造成额外音质损失，二是有损也最好不要再转换格式了，同样是因为音质损失，这就造成了额外的不便。\n本文就介绍一下我了解的与音频编码相关的知识，以及各种常用音频编码格式的比较。更全面的格式对比可以参考Wikipedia页面。另外需要指明的是，本文的介绍基于音乐收藏和本地播放的目的，与流媒体的需求不同，后者追求稳定的码率、低延迟甚至是低能耗。\n音频信号调制 如果学过信号处理的读者可能已经了解本章内容了，可以跳过这节~\n在物理世界中，声音本质上是一种物体震动产生的波，如果要将物理世界中的波存储为数字世界可以存储的格式，则需要进行信号采样（模数转换）和信号调制。波形信号调制主要有两种方法，一种是脉冲编码调制（pulse-code modulation，PCM），一种则是脉冲密度调制（pulse-density modulation，PDM）。简而言之PCM就是通过数字信号的幅度和频率来分别表示模拟信号的幅度和频率，而PDM则通过数字信号的频率和幅度来分别表示模拟信号的幅度和频率（反过来了）。它们对应的音频存储格式是WAV和DSD（Direct Stream Digital），WAV由于编码简单是最广为使用的音频格式，而DSD由于技术和专利的限制则非常罕见，并且音频编辑比WAV复杂很多，因此只有在索尼的SACD上和一些高清音乐网站可以见到。\nPCM的音质在频率上受限于其采样率，根据Nyquist采样定理，两倍以上的采样率可以真实还原出原波形，所以考虑到人耳的听力最高到20kHz，通常PCM音频的采样率都在40kHz以上（如常见的44.1kHz和48kHz）；在振幅上受限于其采样位深。因此采样率低会导致声音高频被裁掉，而采样位深低会导致振幅分辨率下降，音频的动态范围下降，这两者共同导致音频的失真。而PDM由于我没学过，就不评价其音质了。\n在不同的采样方式之间是可能会产生额外失真的。高音质采样到低音质采样就不用说了，反过来也是可能的，如非整数倍地改变采样率（如44.1kHz到48kHz），PCM和PDM的转换。位深由于对应的是二进制的位数，非整数倍提高位深不会产生失真。\n有损（Lossy）编码 首先是有损编码，有损编码的音乐比较好找，因为（天国的）虾米、网易云、Spotify等网站都可以下到，现在很多平台都提供比较高音质的试听了。但是在曾经的年代，高音质有损编码也是比较难找的，以及现在放在手机上听歌我还是会转换成有损音质。\n不同的有损格式对于“损失”音频的哪一部分、哪一频段是不一样的，他们适合的场景也不一样，比如有的格式设计之初的目的就睡尽量保留人声质量。如果真要比较哪种格式、哪种编码器的音质最好的话，只有A/B测试才是最可靠的，然而A/B测试也会受到被测对象的主观影响，所以如果想选择一个音质最好的编码器的话，可以自行A/B测试来做判断。\n有损音频的音质可以通过码率（birate）直接进行优劣判断。音频的码率指的是每秒文件能够提供的信息量，以CD音质为例，普通CD一般采样率是44.1kHz（理论能够还原频率高达22kHz的波形），采样深度16bit，双声道，那么原始码率就是44100*16*2=1141.2kbps，注意这里的kbps是kilo bits per second。普通能下载到的有损音乐通常是MP3格式（虽然这年头很少有人再下载音乐了），在我高中那会，从QQ音乐等平台上上下载的MP3基本都是128kbps，只有虾米下载的是192kbps甚至320kbps，因此我还是非常喜欢虾米的。\n码率是一个瞬时概念，对于音频编码（甚至视频编码）而言，码率是随时可能变化的。编码器通常提供两种码率控制方法：恒定比特率（Constant BiRate，CBR）和可变比特率（Variable BiRate，VBR）。选择CBR或者VBR需要试场景而定，CBR适合稳定的媒体串流，避免网络波动产生播放不畅，而VBR由于给了编码器更多空间根据媒体内容调节码率，通常而言可以达到更好的质量，适合本地存储回放。\n一种客观的音质测试方式是直接计算编码后音频与原音频信号相差了多少。根据我的测试，有损音频的质量基本和码率成正比（见下图，如果用信号损失的对数值来看的话几乎是线性正比）。而如果使用根据人听力敏感度加权之后的频谱，那么可以看出在低码率时（如96kbps），AAC的音质较好，这正是AAC设计的目标，即在通话音质（一般就是96kbps）下能够有很好的表现。而在高码率时（如320kbps）WavPack和MP3 CBR的表现更好，因此很多人说MP3格式应该被淘汰，但320k的MP3的音质还是非常好的。\n简而言之，我的结论是在同等码率下各种有损格式的音质都差不多，更应该关注的是如何找到高码率的音源。下面介绍几个主流的有损音频编码格式。（我个人非常喜欢用WavPack的有损模式，但是这个很非主流）\nMP3 MP3的名字来源于其最开始是作为MPEG-1标准中的第三种音频格式，它应该是（至少在中国）最广为流传的音频编码格式了。而在支持MP3的编码器中，lame是其中最常用的。MP3的编码特性是它会根据码率的设置进行低通滤波，320kbps CBR时滤波在20kHz左右比较接近CD音质的22kHz了，而192kbps CBR滤波则在16kHz左右，128kbps在12KHz左右。因此不同码率MP3的听感区别是非常明显的，通俗来讲音质越差的MP3越像是把喇叭蒙在鼓里的声音，各个频段的特点可以参考我之前的博客。\nlame编码器虽然2012年之后就几乎没有怎么更新了，但是它应该仍然是所有提供mp3的音乐平台使用的主要编码器。它支持CBR、VBR和独有的的ABR。CBR可以指定码率，VBR无法直接指定码率，而通过指定参数-V来间接实现码率调整，而ABR则是在可变码率的同时支持指定一个目标平均码率。\nMP3虽然是个很古老的格式，并且有不少为人诟病的缺点，但是因为高码率MP3的音质确实不错，而且MP3的硬件支持非常到位，因此到现在仍然是非常流行的音频格式。\nAAC AAC全名为Advanced Audio Coding，AAC设计目标是成为MP3的后继者。虽然维基上说AAC在同等码率下能够得到比MP3更好的音质，但根据我的测试结果这个结论只在相对较低码率的时候成立。不过AAC设计的定位应该就是针对流媒体，以及现在的蓝牙音频，这些地方音频的码率都是受限的，所以也不能说错。AAC比MP3支持更多的采样率、通道数，在视频编码时其实用的非常多，但是其实它不是针对音乐收藏而设计的。\nAAC音频文件的后缀名通常是m4a和mp4。这两者都是MPEG-4标准定义的流媒体容器后缀名，其中前者专门针对音频，而后者则是音频和视频都可以用。关于容器是什么，我会在之后的视频编码器博客中详细介绍。\nAAC音频编码器除了万能的ffmpeg以外，还有以下这些专门针对AAC的编码器\nNeroAAC：质量最好，但是是商用编码器，不开源。 QuickTime AAC：由苹果设计、应用在QuickTime和后来的iTunes中、口碑不错。有第三方开源的实现（qaac）。 FAAC：Free AAC，开源，但是感觉用的人不多 总的而言，AAC的特性非常多，也是一个经过深思熟虑后设计的编码器，但由于是针对流媒体设计的，对音频收藏来说并没有什么吸引力。\n无损（Lossless）编码 无损编码即经过编码压缩之后不会损失信息的编码方式。如果仅仅是为了压缩而言的话，通用的文件压缩理论上也是可以用作音频编码的，但是通用压缩的效率肯定不如专门设计的音频压缩高，并且需要先解压才能播放。无损编码没有音质之差，它们的主要指标则是编码解码耗时，压缩率、对音频格式的支持以及其他附加功能。对音频格式的支持包括多声道（如5.1）、高采样率和位深（如常见的Hi-Res格式96kHz/24bit）、对DSD的支持等。\n下面介绍一些常用的无损格式（其中我选择的就是WavPack）。\nFLAC FLAC名为Free Lossless Audio Codec，虽然听起来非常老土和山寨，但应该是目前各平台最通用的格式，像是MP3在有损编码里的地位。FLAC开源、性能好、解码快、硬件支持好、压缩率也不错，无脑选flac一般没什么问题。FLAC是MPEG支持的格式，很多高质量的DVD和BD压缩出来的视频里都会用FLAC作为音频编码。因此通常情况下FLAC编码音频文件的后缀名是.flac，但有时你也能看到.m4a的后缀名。\nAPE/TAK APE（Monkey\u0026rsquo;s Audio）和TAK（Tom\u0026rsquo;s lossless Audio Kompressor）都是能够提供非常高压缩率的编码器，但是他们俩都是闭源的。在电驴（VeryCD）时代用APE的人非常多，可能就是由于其较高的压缩率吧，但是APE的编码和解码相当慢。TAK的编码解码都很快，估计是利用了多线程或者AVX加速。另外还有一款编码器叫OptimFrog，能够提供最高的压缩率，但是编码和解码都奇慢无比，更像是个Proof of concept的作品，而且还不开源，实际使用就不要考虑了。\nWavPack 这里隆重推荐我现在使用的WavPack。它开源、功能丰富、支持各种采样率位深和通道数，甚至支持DSD的编码，这个特性是别无二家了。\n不过最吸引我的功能其实是支持混合编码（见后文）。WavPack由于其开源的特点，同样被各大音乐软件所支持，甚至ffmpeg和MKV视频容器都是支持WavPack的，不过MPEG-4仍然不支持比较遗憾。WavPack在硬件上支持可能没有FLAC广，但是WavPack的源码中同样包含了用汇编直接编写的几个核心函数，因此编解码的性能也是非常好的。\n根据我的使用经验，WavPack有损音质好，无损体积小，编码也快，总之除了FLAC之外找WavPack就没错了！\n混合（Hybrid）编码 除了有损无损之外还有一种编码方式是混合编码，它指的是编码器在生成有损压缩音频后还生成一个修正文件（Correction File）。当修正文件和本体音频同时存在时原始音频可以被无损还原。这个编码方式的好处是你可以同时拥有大体积的高音质文件和小体积的低音质文件，非常适合我这样的收藏党，文件本体放在云上，然后小体积的有损部分可以经常下载下来听。有损部分也可以用作demo，如果听了demo之后喜欢上这首音乐了再去下载修正文件提高音质。\n支持混合编码的主要有三种音频格式：LossyWav，WavPack和OptimFrog，其中最后一种非常难用，而且好像和LossyWAV一样不支持无损播放，即需要先解码再播放才能达到无损音质。\nLossyWAV LossyWAV其实不算是一个完整的音频编码器，而是一个预处理软件。LossyWAV只能处理原始的PCM音频，然后生成的也是PCM音频，之后还需要使用其他的（无损）编码器来进行压缩。它的原理是分析原始音频，然后对其进行某种形式的变换使得音频更容易被压缩，从而降低生成的音频文件平均码率。由于这个变换是不可逆的，因此它也是有损压缩，但是LossyWAV支持生成修正文件，因此它可以看作一种混合编码方式。\n经过以上描述，相信大家可以看出来编码过程非常麻烦，如果想要生成混合模式下的音频文件和修正文件，需要先从原始PCM音频生成有损PCM和修正PCM，然后再分别通过其他方式编码器将它们分别压缩，而无损解码的过程则是把他们反过来。因此LossyWAV在编解码速度和文件体积上都完全没有优势，并且这个原理也意味着LossyWav不支持无损播放。在能够选择WavPack的情况下还是不要用LossyWAV了。\nWavPack WavPack内置对混合模式的支持，而且WavPack支持无损播放。这意味着只要播放器能够找到修正文件，那么播放器就能直接以无损音质播放音乐而不需要额外解码。这个特性对我来说就是killer！另外从前文图表可以看出，WavPack在有损模式下也能够达到很好的音质水平，甚至在特定码率下比MP3和AAC都要好。唯一遗憾的地方是混合模式下WavPack音频总体的压缩率是比较低的，通常会比无损模式下的体积要高出5%左右。不过这个年头存储空间越来越不值钱了，所以这个问题也完全可以忽略。\n总而言之我完全找不到理由不使用WavPack，再次向大家推荐这个编码器！\n本文介绍了在ACG音乐收藏的过程中我了解到的音频编码知识，而在下一篇博客我还会介绍视频编码的内容~\n参考资料：\nDSD vs PCM 我自己搭的codec对比benchmark 维基百科对音频格式的对比页面 ","date":"2021-07-20T00:00:00Z","permalink":"https://zyxin.xyz/blog/2021-07/ACGNAudioFormats/","title":"ACGN收藏 - 音频编码与格式"},{"content":"这篇博客也是拖了很久了，简直是蹭热度都蹭不到热的。。。去年年底有一帮数学家和喜欢数学的人（Numberphile）发起了一个Youtube系列，叫#MegaFavNumbers，也就是介绍自己最喜欢的大于一百万的数字。虽然没有要求这个数字是整数，但是Numberphile一般只关注整数（甚至仅自然数）。如果没有这个限制的话，那物理化学上就有很多常数了，例如某视频评论区有人提到阿伏伽德罗常数23333\n如果让我来选的话我还真想不太出来，毕竟没学多少数学，顶多会选$2^{32}$这种程序员知道的数字，或者已知最大的质数、孪生质数云云。这个题目真的是很有意思了，很多有特殊性质的数字或者是某数列的第一个数都会比较小，很少会有一个非常大并且独一无二的数字，因此看了3Blue1Brown的视频之后我顿时就来了兴趣，准备写下这篇博客介绍以下各博主选择的数字，又了解一些平常不知道的冷知识~哈哈。我大致将这些数字分了个类，不过不是很严格。\n某特殊数列中第一个超过1M的 3 628 800 by @Peter Pike：第一个超过1M的阶乘。作者讲了一堆和阶乘有关的可视化，但是数字本身其实比较直观了。 1069+69 by @Kevin Du：$10^x+x$数列中第个3质数（前两个是$10^1+1$，$10^9+9$），即OEIS数列A089379的第三个数 （不是很知道为什么没有选$10^9+9$ ┑(￣Д ￣)┍） ≈1.1698e45 by @Stand-up Maths：满足$\\tan( p )\u0026gt;p$的第一个质数p，即OEIS数列A249836中的第一个质数。 $C^{104}_{39}$ by @Zoe Griffiths：在杨辉三角里出现超过5次的数中，大于1M的第一个数。神奇的是前一个数是24310，然后突然就变得很大了！ 640 3203 by @Richard E. BORCHERDS：$\\approx e^{\\pi\\sqrt{163}}-744$。取这个数的原因是它与$e^{\\pi\\sqrt{67}}-744$和$e^{\\pi\\sqrt{93}}-744$都神奇地非常接近一个整数，其背后的原因跟椭圆模函数$1/q+744+196884q+21493760q^2+\u0026hellip;$有关。这个数由传奇印度数学家Srinivasa Ramanujan发现，也被称为Ramanujan常数，计算这个数需要支持任意精度浮点运算的计算器。 23 240 4006 = 720 72010 by jan Misali：即六进制表示的720720。720720是接近1M的超级合数（令$d(n)$表示$n$的因数个数，$f_\\epsilon(n)=d(n)/n^\\epsilon$，超级合数则是满足$\\forall k\\in\\mathbb{Z}^+$, $k\u0026lt; n, d(n)\u0026gt;d(k), f_\\epsilon(n)\\geq f_\\epsilon(k)$的数$n$），即OEIS数列A002201中接近1M的一个很满足强迫症的数。博主为了让它超过1M换成了6进制哈哈哈哈。 某特殊数列最后一个数 73 939 133 by @Flammable Maths: 最大的可右截断素数（right truncatable prime），即OEIS数列最后一个数。 ≈1.151322e38 by @Normalized Nerd：十进制下最后一个水仙花数，即OEIS数列A005188最后一个数。 $3\\times2^{402653209}-1$ by @timpa\u0026rsquo;s videos: 从4开始的Goodstein序列的最大一个数，即OEIS数列A056193中最大数。 某猜想的第一个正例或者反例 906 150 257 by @SparksMaths：Pólya猜想的最小反例。这里有个知乎回答提到了这个例子。 666 030 256, 696 630 544 by @singingbanana：偶亲和数猜想：“偶数亲和数之和为9的倍数”的第一个反例。（亲和数对：A的所有真因数之和等于B，B的所有真因数之和等于A） 569 936 821 221 962 380 720 by @Numberphile：一个著名猜想的任意整数可以写成三个整数的三次方之和，其中$3=x^3+y^3+z^3$的解除了(1,1,1)，(4,4,-5)外找到的第三个解中的正数即为博主选择的数。 ≈8.42443e51 by @WillsWei：使得$n^{17}+9$和$(n+1)^{17}+9$不互质的第一个$n$。 来自非数学领域的数 1 094 795 585 by @LiveOverflow：0x41414141，即ASCII码表示的AAAA，被视作缓存溢出的标志 ≈1.01971e1400 by @The Comamba: $k\\cdot 256^{211}+99$，其中k是一段破解DVD加密的代码的二进制表示。由于这段代码不合法，一个程序员用这个数把它加密成一个质数然后上传到了一个质数网站，也是很有想法了！ 6.187e34 by @Tom Rocks Maths: $1/l_p$，$l_p$代表普朗克长度。普朗克提出世界不是连续的，因此普朗克常数就可以用来用整数表达这个世界！ 1 056 006 by @Eddie Woo：悉尼歌剧院房顶的瓷砖数，surprise！哈哈哈哈！ 1 597 463 007 by @Rodrigo Aldana: 快速开方算法中的magic常数0x5f3795df 其他 ≈4.3252e19 by @David Dijon 和 @Philip Hintze: 魔方的组合可能数。 302 575 350 by @blackpenredpen：买到Mega Million彩票的可能性。 12 345 679 by @TyYann：也是个很有名的数字了，12345679$\\times$11 = 111111111。作者因为小时候的回忆而选择了它。 ≈8.08e53 by @3Blue1Brown：“魔群”（Monster Group）的大小。魔群是“散在单群”（Sporadic Simple Groups）中最大的群。推荐看完整原视频，解释这个概念也是非常麻烦了。。。另外知乎这也有个很棒的回答。这个数是我觉得这系列里面最有意思的，一个数学中应该是非常基础的概念里面竟然会有这么大的尺寸，非常神奇！ 时间有限，这里只总结了这么多。有一类数字没有加进来，就是专门生成大数字的运算符，所产生的最小数字。。。因为不好打出来所以没放。这个合作系列一共有200多个视频，如果有兴趣的话可以去Youtube列表里面查看~另外对有兴趣探寻这些数字游戏的人，我也推荐Project Euler，里面有很多找数字的题目，同时满足了对数字的好奇心和编程练习~\n参考链接 Youtube #MegaFavNumbers 数学史上有哪些看似成立的算式形式猜想，最终被某个大数证明不成立？ - 知乎 Law of Small Numbers 数学中的“怪兽群”是什么概念 Project Euler Patterns That Eventually Fail ","date":"2021-07-11T00:00:00Z","permalink":"https://zyxin.xyz/blog/2021-07/MegaFavNumbers/","title":"MegaFavNumbers - 最喜爱的百万数字"},{"content":"很久没写博客了，这次想总结一下自己在ACGN收藏这条道路上越走越远，到底都走了哪些弯路哈哈哈哈 （博客画风突变）。这一篇算是一个开篇稿吧，想写的内容有挺多的，一些比较短的内容会放在这一篇底下。\nACGN即Animation、Comics、Games、Novel，不知道这个年头还有多少人用这个词，但是这个词确实描述了我的兴趣爱好。虽然ACGN从名字上来看没有特定的文化限制，但是一般都是指源自日本的（日本的文化输出是不得不服啊），尤其是Animation这个词，通常在ACG里面的A其实指的是Anime（Animation的日式发音缩写），特指日本动漫。鄙人虽然喜欢看（日本）动漫小说等，算的上半个二刺螈，但是ACGN产业本身也是良莠不齐的文化产品，其中有很多优秀的产品，也不乏令人无语的奇葩。\n个人认为日本ACGN的吸引力不仅仅在于产品制作精良，更在于其涉猎内容的广泛以及表达形式的多样，再加上各式产业的紧密衔接，让人很容易进这个坑里。我从初中入宅以来也接触了很多ACGN的内容，不过主要是看动漫去了，小说漫画看了个别，而日式游戏基本只接触过俩：雀龙门和东方系列。但真正让我入坑收藏的其实是从东方接触到的同人音乐，同人音乐的世界包罗万象，而又大多是限量发售，因此就勾起了我的收藏欲。之后渐渐的不仅收藏同人音乐，也去收藏起ACGN的产品了。\n以前作为一个高中生，实在是没有什么存储资源存那么多的内容，不过现在好很多了，但是却也没有精力去整这些东西了。更悲催的是大二硬盘被偷了一次，导致我一半的收藏没了，也导致我很长一段时间再也没有收藏的欲望了。。。（于是落下了很多坑，悔不当初）\n之后的几篇博文想介绍以下几个内容，虽是由我收藏的爱好衍生出来的一些技术，但也可以适用于很多其他的场合，因此有想把他们写下来的动力：\n文件管理 音频压制 音乐整理与播放器 视频压制 网页打包 这篇就写到这里了，希望这个博客的坑最后也能填完orz。。\n","date":"2021-07-10T00:00:00Z","permalink":"https://zyxin.xyz/blog/2021-07/ACGNCollection/","title":"ACGN 收藏者的自我修养"},{"content":"对于ACGN收藏来说，文件管理是一个基础任务，毕竟收藏的文件内容多种多样，例如光盘镜像、压制后的音频视频、小册子扫描、字幕甚至小游戏等。把文件按一定结构整理是必要的，我也专门为整理音乐写了一些小工具，不过整理文件的格式因人而异，也没有特别的难度，因此不需要特别描述我是怎么做的。我觉得值得一提的内容是如何对文件进行定期存档和备份，这也是我在硬盘被偷之后立马开始对收藏的文件进行的操作。备份有一个3-2-1的原则：3份备份，2份本地，1份云端，下面会介绍一些本地的备份和云端备份的方法以及我的选择。\n离线备份 离线备份就是把文件资料整理并存储到另一个设备上，需要考虑的功能有加密、压缩、增量更新、去重、冗余等。如果是最基本的备份，如果只想直接备份，不考虑加密压缩等的话，著名的rsync是个不错的选择，它可以同步两个目录（可以是挂载FTP的目录），并且有算法来进行去重以减少二进制的传输。\n对我而言最大的需求是有冗余（指恢复记录，Recovery Record）和分卷，因为之前有在光盘上存一部分的音乐，而最后有几个压缩包已经无法恢复了，光这一条一卡几乎没剩下几条选项，可以参考维基百科。内置支持恢复记录的格式最著名且常用的有WinRAR（虽然不开源），另外剩下的里面开源的只有DAR，FreeArc。FreeArc已经10年没更新了，并且代码是毛子用Haskell写的，注释都是俄语。。因此就不考虑了。如果考虑外部支持的话最常用的就是Par2标准。下面对比几种（文件级别）方案的区别\n如果有多盘的话那么RAID就是不二选择了。不过选择文件系统以及组RAID或者NAS都是比较折腾，而且多数情况下需要Linux，我现在平时还是难免用Windows当主力，换成Linux做备份还是麻烦，因此本文就不介绍支持备份功能的文件系统了。如有兴趣可以自行了解ZFS、Btrfs或者XFS+LVM。这方面还有有很多博文可以参考（如这一篇ZFS和Btrfs的比较，以及这一篇如何从Btrfs恢复数据）\nWinRAR WinRAR除了不开源之外其实没有任何大毛病，它的解压部分也是开源的，因此不用担心以前的rar压缩包以后会打不开。主要的缺陷是WinRAR对增量更新几乎没有支持，最多通过文件flag来实现，因此不必指望RAR做增量更新了。如果只是想把收藏做个镜像，那WinRAR就很方便了，有不错的压缩和加密，而且内置支持分卷和恢复记录，这两个功能到2021年仍然是独一家。\nDAR + Par2 DAR是一个设计来替代Tar的文档格式，内置对Par2的支持，并且支持增量更新，对大量数据的备份其实挺友好的。PAR2是个给文件生成外部恢复记录的标准，可以生成一些恢复记录文件，当数据主体文件有一些损坏的时候，可以使用PAR2文件进行恢复，并且PAR2文件本身也是能够允许一部分损坏的。这个方案其实功能上来说很不错，但是由于是针对Linux设计的，对Windows支持用cygwin太不友好了。此外DAR的软件支持也不是很全，不知道为什么没有流行起来。\n7zip + Par2 如果不限打包软件（不要求对Par2的直接支持和增量更新）的话7zip应该是当前评价最高的压缩软件了。7zip + Par2是个不错的选择，不过设置Par2的参数就有一些麻烦了。这个方案相比WinRAR的优势仅仅在于7zip和Par2都是开源的。7zip有个额外的坏处是它的slice每个分区不能独立打开，rar的话每个slice包都有对应的文件可以解压。Par2相比WinRAR的修复好处在于它可以progressively提供冗余，就是下载的冗余文件不够的话可以下载更多冗余文件来进行修复，弱势是它不能处理32767以上个文件，因此必定需要跟某个archive格式一起使用。\n7zip + SeqBox 除了冗余数据之外，另一种保护对象是磁盘系统的文件头。SeqBox是一个用来保护单一文件在磁盘文件系统损坏的情况下仍能恢复数据的通用工具，其工作原理是将文件分割成尺寸小于硬盘扇区（sector）大小的块，每个文件块有独立的包含文件UID的文件头，这样哪怕分区表损坏，指定文件还是可以通过一次全盘扫描恢复出来。而BlockyArchive则是基于此之上的改进版，给每个文件块加上了冗余码，使得文件本身的损坏也可以得到恢复。这个方法对数据长期冷存储应该是很有用的。不过它会产生不小的额外存储开销，并且对应的功能其实更适合通过文件系统本身来解决，例如之前提到的著名的ZFS和Btrfs。\n在线备份 由于在线存储服务商通常都会提供数据完整性check以及数据冗余存储的功能，因此对recovery record的需求没有那么大（百度网盘除外！！！辣鸡网盘下载经常文件损坏）。有许多软件支持数据同步和备份，同步比如Google Drive自带的sync，Onedrive或者rclone，他们的缺陷是没有加密、压缩，并且支持的snapshot功能有限。相比于本地备份，在线备份更关注的可能就是文件体积了，因为文件体积可能直接会影响收费策略，而冗余和备份通常会有云服务商来保证，因此去重对于在线备份来说是更重要的。\n更针对性的备份软件则对这些都有支持，在这个网站有一个开源软件的list。这些软件通常支持将数据备份到另一个目录、NAS或者网盘，并且定期执行增量备份。由于Windows或者Mac目前还是不可避免地成为主力系统，因此只考虑支持Windows、Mac的情况下，再加上有GUI，可选项有Duplicati，Duplicacy，UrBackup和BlobBackup。这些软件有些是针对系统备份设计的，但其实我对系统备份没有什么需求，毕竟重装系统也没有很麻烦。Duplicacy有开源CLI，但GUI是收费的，性能很好。UrBackup的UI都很简陋，而且感觉更新不勤。BlockBackup是个定位简洁的产品，看下来Duplicati和Duplicacy还是个不错的选择，Duplicati支持的后端更多，而Duplicacy的性能更好并且更稳定。关于这些选择有不少比较，例如Duplicati的论坛里，Duplicacy作者的benchmark，可供参考。目前我的选择是Duplicacy，因为稳定并且高效。但Duplicacy由于算法特性，产生的文件块比较小，因此对于大数量的小文件备份不是很友好，如果之后要做日常文件备份的话可能还是会考虑Duplicati。\n这里提以下去重（Deduplication）和增量（Incremental）/减量（Decremental）/差分（Differential）备份的区别，通常增量备份仅仅会保留完整的新文件而可以跳过没有改动的文件（类似Git的模式），对文件中不同的部分一般不做处理，但在这种情况下如果有大文件进行了内容修改，则会产生大量的浪费，因此有专门的去重算法来针对文件整体内容进行去重，其本质上就是将所有文件看作一个大文件，然后通过特定的方法拆分（通常是使用Rolling hash）来达到快速查重的效果。这样的一个比较大的问题就是文件会被分成很多小块（通常只有几个MB），因此对于文件传输来说其实很低效（例如上传到网盘、拷入备用磁盘等），并且将文件分块太细也会带来一定的性能和容量损失。在文件内容大部分为大文件，并且不会内部进行小修改的时候，这样的操作其实比较浪费时间。\n这里提到的在线备份工具都可以把本地磁盘看作一个备份目的地，因此也可以用作离线备份。另外离线备份也可以通过同步工具（如rclone）变成在线备份。上文提到的离线备份一般不能做到multi-version（除了ZFS），不过对于比如我这个音乐收集的任务来说，历史记录不是非常重要，因此也是个可行的方案。\n网站归档 还有一个比较另类的需求，我不仅想备份自己的文件，还想备份别人的文件网站。\n很多同人社团的网站有很多信息，如Discography、世界观设定、Stuff List甚至一些正常的blog等，但是这些内容都不是持久的，很多同人社团停止活动之后网站也没了，因此也想备份他们的网站。这个需求通常可以通过知名网站Internet Archive完成，但是这个网站因为是公益性质的，一些多媒体资源并不一定有保存下来，还是自己搭建网站爬虫会比较可靠，Internet Archive可以作为补充。\n网站爬取以前是通过IDM（Internet Download Manager）可以实现，但是IDM不免费因此后面也没有用了。而单页的存档方式之前很流行的一个格式是Firefox的maff，不过Firefox也不再支持这个格式了。现在的计划是下载单独的网页用Save Page WE这个插件来完成，基本可以原封不动地备份一个网页，而对于备份整个网站，计划之后搭建一个自己的ArchiveBox。\n","date":"2021-07-10T00:00:00Z","permalink":"https://zyxin.xyz/blog/2021-07/ACGNFileManagement/","title":"ACGN收藏 - 文件管理"},{"content":"最近买了一些新的耳机，但是买完总感觉自己被收智商税了，于是就查查查了好多资料。这篇文章介绍我理解下音频发烧友的一些词汇是什么意思，如果你不烧耳机音响，但是想了解这个群体的，这个文章也能作为一个入门参考～Hifi领域有很多词汇我也没懂的，我也写在文章里了，如果有老烧路过请指教一二。我尝试用我学过的知识来客观解释音频领域的知识，我没上过信号处理，相关课程只上过自动控制和离散控制。\n发烧到底追求的是什么 刚好今天有看到一个Youtube视频讲到，为什么音乐人并不care那些高端的音频设备。视频内容本身的观点是：一方面音乐人更关注的是音乐本身能不能打动人，另一方面是音乐人很多也没有那么多闲钱哈哈哈。以及底下的评论有很多人说自己是pro musician，然后疯狂喷audiophile追求的东西是虚无飘渺的。我承认烧音频领域有很多玄学都是脑放（脑补出来的），但是做耳机解码之类的厂家也是有很多pro audo engineer，不能否认这里面也是有很多技术门道的。根据这一帮自称pro musician的发言，我估计他们也没有多牛，他们的观点也有幸存者偏差在里面，并且本身不同级别不同类型的音乐也有不同的需求，因此这些评论也就看看就好。不过有一点我是同意的，听音乐最重要的还是音乐本身，对音质的追求不应放于对音乐本身的追求之上。\n再打个比方，对音质的追求和对画质的追求其实是相似的，好的（照片）画质能让我们看清楚世界更多的细节，好的音质能让我们更真切地感受到被乐器包围的感觉。音频处理和视频处理也有很多相似的地方，因为他们都经常被看作信号来处理，后文我也会经常拿画质来打比方。\n什么是好的音质 在找到了自己喜欢的音乐之后，我们当然会希望手里的设备能更好的还原音乐本身，能听到每一点细节。因此对音质好的标准在我看来（我相信也是大多数人的观点），指的是耳朵听到的声音感觉和你站在录音的地方听到的声音感觉非常相似。由此可见在现场听，在乐器和人声面前听才能获得完美的音质，这是音质的金标准。当然这个也不是那么统一的，例如我并不觉得在歌手演唱会听到的音乐会比手机放出来的好听，因为演唱会非常嘈杂并且音响素质也不见得很好；但如果是在音乐厅听交响乐，我可以拍胸脯保证听到的声音远超电子设备播放出来的。又比如我还听很多电子音乐，里面很多音色都是直接合成出来的，那就无法通过这样的标准来定义了，这种情况下最好的音质可以定义成你听到的声音和音乐人以及调音师想让你听到的声音一致。\n上面提到的音质是可以客观定义和测量的，但是另一部分人追求的音质则是他听到的声音符不符合他的口味，例如有些人喜欢温润的女声，有些人喜欢低沉的bass，这些其实都是主观的喜好。这才是发烧友的精髓——定制，就像搞机械键盘什么的，定制和折腾才是发烧友的精髓。不过我对这样的音质并没有什么追求，因为他们通常都可以通过简单的Eq（调整Equilizer）来解决。\n听到的声音的几个指标 通常对于音频发烧友来说，音质好不好是个比较笼统的词汇，因为音质好大抵是相似的，而音质差则各有各的差法。为了区分这些方面，audiophile们利用以及发明了很多与音质有关的词汇，我把比较常见的以及他们的意思列在下面了\n声音基本概念 (声音的本质是声波) Loudness / 响度 声波的振幅，通常会取势能来计算平均振幅 Tone / 音调 （简单）声波的频率，真实的声音通常会是多个频率的叠加 Timbre / 音色 声波的形状，人通过音色区分声音的来源 音频信号 (如何表征一个音频信号) Spectrogram / 频谱 频谱描述信号在各个频率上的幅度，一般通过Fourier变换计算，由于Fourier变换是可逆的，因此频谱可以唯一地对应一段声音 Frequency (Response) / 频率(响应) 频率响应描述输入信号和输出信号在频域上的差异 Phase / 相位 相位本身指周期信号中信号在周期的哪个位置，但是相位本身很少用，用的更多的是相位差。我们常用的是将相位差推广到非周期信号，然后用来描述多个声道之间的信号时间差 可以量化的词汇 （客观描述音质） Bass / 低频 20Hz-20kHz的低频部分 Mid / 中频 20Hz-20kHz的中间部分 Treble / 高频 20-20kHz的高频部分 Imaging / 声像 声音的定位准不准，与信号相位有关。可参考Rtings的测量方法 Sound Stage / 声场 感受到的空间大小，听起来音源越分散，声场越大。这个主要是针对耳机还原音箱声场的感觉，具体解释参考豆瓣这篇文章，测量方法参考Rtings的测试流程。 Dynamic Range / 动态范围 在同一段声音里同时表现幅度很大和很小的信号的能力，可以参考图像的HDR技术。 Transient / 瞬态 这个词我是抱有疑问的，虽然控制器确实有响应时间这个参数，但是用在声音信号上感觉并不算很合适。好像一般通过追踪方波输入来看耳机的瞬态响应。 Signal to Noise Ratio (SNR) / 信噪比 字面意思，信号对噪声的比。这个噪音通常是音频电路的底噪。 Total Harmonic Distortion (THD) / 总谐波失真 输入一个纯净正弦信号，输出里这个信号的谐波就是谐波失真。 Intermodulation Distortion (IMD) / 互调失真 输出两个频率的信号，测输出信号的失真 Crosstalk / 串扰 多通道之间的信号干扰 玄学词汇 （主观描述音质） Fidelity / Resolution / 解析力 这个词可能指的是低失真？有时候感觉也指超高频的频率响应。被各种厂家的广告用烂了，没有统一的解释 Punchy / 力度 通常指的是低频非常重 Congested / 拥挤 / Shouty 大概指的是声场小，或者是中高频gain太高 Sharp / 锐 一般是在频谱的某一小段中高频上有刺突 Clean / Clarity / 通透 / 纯净 应该都指的是中高频比较突出 Sound quality / 音质 虽然这里我们客观地讨论了什么是好音质，但是在audiophile社区里面这个词并不都是这么定义的 Tonality / 调性 这个词我着实没弄懂，本身是用来形容乐曲的谱调的，但是用来形容音质我也摸不找头脑 Layered / 层次感 这虽然我知道是什么意思，以及能听出来区别，但是觉得这个词很模糊。我猜测它与声像和声场都有关。 其中低中高频的区别这里贴一张引自crinacle的图1\n人能听出多大差别 在定义了什么是好音质以后，还有个问题是人能听出来多大的音质差别？首先一个基本常识是人的听力范围是在20Hz-20kHz之间（也有说16Hz-20kHz的），这是目前通用的标准，包括音频的采样率定在44100Hz也是参考了这个数据。另外在这个知乎回答里面，答主引用了这些数据：\n人耳所能感知到的纯单音变化最小幅度为0.3dB 人耳在最敏感的500Hz~2kHz段所能感知到的频率变化一般是0.2% 人耳所能感知的低次谐波失真变化最小量一般在1%上下\n以上这些数据可以作为参考，但是它们并不能作为硬性指标，例如说音频信号超过20kHz的部分就是完全没有意义的，我认为是不科学的。一是因为以上都是统计数据，不能否认现实世界有“金耳朵”的存在（不过至少我不是），二是以上数据来源于科学实验，其实验过程与我们听音乐的时候可能并不相同，有可能会导致音频敏感度的差别。不过至少这些数据让我们有一个大概的概念，如果一个音频设备带来的提升远小于这些数，那么极大概率你是听不出他们带来的区别的。\n发烧友字典 Hifi界另外一些让人摸不着头脑的地方就是，各种各样的词汇，以及这些词汇似乎指向的东西有时候也很不明确。。。这里把我自己学到的记一下。\n音乐播放器系统组成 我们这里不考虑录音室的系统组成，而只考虑用户的系统组成。\n音源 好像音源又叫前端？整那么邪乎干啥。。。音源有CD机、电脑、唱片机（俗称转盘turntable？），因为现在都是数字音乐了，因此重要的就是源文件的音质。音频格式有很多说法，首先分PCM和DSD两种，PCM是时域采样而DSD是频域采样。PCM又有很多指标，例如位深指音频每个采样的精度（通常是16bit，HiRes则有24bit以上），采样率指采样的频率，根据Nyquist-Shannon采样定律，频率高于20kHz理论上就能做到无损采样。然后音乐文件的格式又分有损和无损，有损格式如果比特率足够高还行，如果很低那就会非常严重地影响音质。然后音源会输出到数字界面。\n数字界面 虽然机油送我了一个数字界面，但是我并不能听出区别，以及我到现在也不是很清楚这个界面是干什么的。根据我知乎看到的资料，数字界面是把USB信号转换成DAC芯片能够直接读取的信号。外置数字界面的好处一个是时钟（可能）比内置更加精确，另一个是给没有USB或者火线（IEEE-1394协议）接口的DAC提供输入。这里就涉及另一个玄学的概念，叫时钟抖动（Jitter）。由于数字信号的采样（指PCM）是恒定频率的，因此如果数字线路的时钟频率不稳定，是会非常影响DAC转换结果的。抖动可以来源于时钟本身（如晶振），也可能来源于数字信号传输的接口芯片。不过就像知乎另一个回答说的，一般这种抖动都非常非常细微，我并不认为这对信号能有太多影响，并且我确实也听不出来。想感受一下多玄学的可以再看看耳机大家庭的文章。。。\n解码器（Digital-Analog Converter，DAC） DAC就是数模转换器，用来将数字信号转成模拟信号。这个过程我觉得挺重要的，因为数模转换（模数转换）带来的信号损失还是很明显的。从控制理论里的零阶保持（ZOH）来理解的话，转换过程会影响信号的相位和高频。DAC的质量在整个音频管道中还是比较重要的。另外一个特性是DAC支持的格式，现在主流的hifi解码都支持高位深和DSD的音频了。\n放大器（Amplifier，Amp） 用于音箱的一般称功放（功率放大器），用于耳机的一般称耳放。放大器的作用就是把解码出来的模拟信号放大到合适的音量。很多设备如手机，甚至一些DAC都把功放集成进去了。独立的放大器设备有两个好处，一个的更好的电磁隔离，更少的底噪，另一个是可以提供更大的功率储备，用来推特别难推的耳机（如低阻低灵敏度的耳机），在极端状态下可以减少失真。\n耳放还分两种：电子管耳放（胆机），晶体管耳放（石机）。我没听过胆机，但都说胆机声音温润，估计说到底就是胆机削低了高频。因此如果纯音质角度看，选一个低失真的耳放就可以了。\n功放有时分前级后级，据我查到的资料说，前级是low-pass filter，用来处理低频，然后后级整体放大？这里我也不懂了，搜到各种不一样的说法，我觉得我还是别管这玩意了。（知乎参考在此）\n接口 再讲一下不同音频设备之间的连接接口，数字的接口一般就是USB和S/PDIF了，模拟信号主要有TRS，TRRS，XLR等等，可以参考这篇文章。这些接口本身没什么差别，虽然说有人对这个很在意，甚至还有人对墙上插座的接口很讲究，但是我觉得这都是玄学= =（就是不科学）\n回放设备 就是音箱或者耳机，这玩意也是有各种产品。音箱分有源音箱和无源音箱，有源就是内置了放大器的。耳机则分入耳（In-ear, IEM），和头戴式耳机（On-ear/Over-ear）。具体这就不展开了。\n耳机相关 单元 Balanced Armerture / BA / 动铁：平衡铁通过磁场变化，带动振膜运动。 Dynamic Driver / DD / 动圈：磁场直接驱动线圈，带动振膜运动。 Planar Magnetic / 平板：磁场直接驱动金属板运动。 Piezoelectric Ceramic / 压电陶瓷单元：压电晶体带动振膜变形发声。 Electrostatic / EST / 静电：电场带动振膜运动。 (可以参见Linus的视频) 线材 首先要说明的是，音频线材对声音的影响微乎其微。线材影响声音的原理是不同线材有不同的阻抗、容抗和感抗曲线（主要是阻抗和容抗），因此可能会微微影响低阻耳机的频率响应。另外，说线材能提升音质的基本就是扯淡。参见该知乎回答。\nTPC: 电解铜 OFC: 无氧铜 OCC: 单结晶无氧铜 5N/6N/7N：（铜）纯度，几个N就有几个9。 Litz/Litz2：绕线方式，参考Litz官网。并不知道不同绕线方法对感抗有没有什么影响。。 现在的线材基本都是无氧铜。个人认为为了好看和功能换线可以，为了换口味换线可以，为了增加屏蔽层减少外部信号噪音可以，但是为了“提升音质”就纯粹是智商税了。另外上面提到的都是传递模拟信号的线材，对那种audio-grade的USB线我是打死都不信有什么区别的，数字信号对这么点阻抗的变化根本不可能有什么反应。 耳塞/耳垫 耳塞(Tip)和耳垫(Pad)可以影响声音在进入耳朵之前的回响，因此也是会改变声音的。耳垫的影响比较大，耳塞我觉得比较小。不过同样的，我认为不同的耳塞耳垫都是相当于给耳机加了EQ，因此不必追求高音质的耳垫。有一点例外，如果耳塞耳垫有漏音的话，会严重影响音质，这种情况下就需要更换了。\n这大概就是我对audiophile各种知识的笔记了。在了解这么多之后，我还是觉得，选一个小巧、功能多、性能还过得去的DAC和amp，然后选个音质够用的耳机就行了，不用再换了。音质这玩意到最后音质提升的性价比实在太低了，还是找更多好听的音乐来的实在。\nGraphs 101: How to Read Headphone Measurements\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2020-12-16T00:00:00Z","permalink":"https://zyxin.xyz/blog/2020-12/AudiophileIntroduction/","title":"“音频发烧友” / “Audiophile” 入门及杂谈"},{"content":"进来给实验室的服务器上装了个Minecraft服务器，给大家闲来无事上来种种菜，顺便体验一下新版本的特性。之前最高只玩过1.8，现在虽然更新到1.16了，但是听说很多Mod都还是只支持到1.12，所以就搭了1.12的服务器。基岩版的MC（Win10自带的那个）虽然性能很好，但是由于不购买就没法玩，所以考虑到大家肯定最开始都不想买，以及那个开服好像很麻烦，就还是搭了Java的服务器。\n一分钟上手Minecraft开服 以前玩Minecraft的时候都觉得开服务器好麻烦，要知道各种各样的配置方法，因此很佩服服主管理这些东西。直到有一天我搜到了这个：docker-minecraft-server，瞬间感觉一键开服不是梦了！这个repo把Minecraft的服务器版本以及Bukkit/Spigot服务器端Mod框架（可以理解成服务器上的Forge）都嵌进去了，简直不要太方便。数据也是从host的硬盘里mount进去的，因此如果你的服务器要转移或者备份也很方便。有了这个，开服只需要一行命令（假设你服务器上有docker）\n1 docker run -d -p 25565:25565 --name mc -e EULA=TRUE itzg/minecraft-server 由于可以设置的环境变量非常多，因此我后来把配置都写到了docker-compose文件里面，这样修改设置后启动服务器就更简单了～目前我的设置如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 version: \u0026#39;3.8\u0026#39; services: minecraft: image: itzg/minecraft-server ports: - \u0026#34;25565:25565\u0026#34; volumes: - \u0026#34;/home/jacobz/Minecraft/docker-data:/data\u0026#34; environment: MEMORY: 4G EULA: \u0026#34;TRUE\u0026#34; VERSION: 1.12.2 ENABLE_AUTOPAUSE: \u0026#34;TRUE\u0026#34; # OVERRIDE_SERVER_PROPERTIES: \u0026#34;TRUE\u0026#34; MAX_TICK_TIME: \u0026#34;-1\u0026#34; ONLINE_MODE: \u0026#34;FALSE\u0026#34; TZ: US/Eastern DIFFICULTY: easy TYPE: BUKKIT OPS: cmpute restart: always 侦测器单片BUD 在服务器上玩了几天，最终还是想搭一个自动农场来解决温饱问题。再不去骗村民的情况下，最方便的食物我觉得就是南瓜饼了，它的原料（鸡蛋、糖、南瓜）都是非常好自动化的。因此我就想着顺便琢磨一下有侦测器之后自动农场有没有什么更方便的方法。甘蔗机在我以前甘蔗机的博文里面有写到，侦测器搭甘蔗机的效率不如传统的BUD，因此主要可以改动的就是在南瓜机上了。感觉应该不是很难，因此我本地琢磨了一会，弄出来两种利用侦测器的单片BUD：\n上置型 下置型 1 2 3 4 5 6 7 8 9 10 11 12 {% minecraft 侧视图 %} |----活塞+沙子版本|- |rd-$|sand|rr-$e1|st|- |obs-n|pi-n|ts-$|rd-$|- |O|pi-w|rd-$|st|- |st|st|st|st|- |----粘性活塞版本|- |rd-$|st|rr-$e1|st|- |obs-n|sp-n|ts-$|rd-$|- |O|pi-w|rd-$|st|- |st|st|st|st|- {% endminecraft %} \u0026lt;/td\u0026gt;\u0026lt;td\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 {% minecraft 侧视图 %} |----活塞+沙子版本|- | |rd-$ |pi-e|O |- |rd-$|ts-$ | |obs-s|- |st |rr-$w1|sand|rd-$ |- |st |st |pi-n|st |- |----粘性活塞版本|- | |rd-$ |pi-e|O |- |rd-$|ts-$ | |obs-s|- |st |rr-$w1|st |rd-$ |- |st |st |sp-n|st |- {% endminecraft %} \u0026lt;/td\u0026gt;\u0026lt;tr\u0026gt; 上图中O代表检测更新的地方，可以看见上置型的结构比下置的要稍微精简一点点，并且由于南瓜只能生成在泥土上，因此我最后使用了上置型的方法搭了自动南瓜机。对比我之前传统BUD的南瓜机方案，只需要把这个结构横着堆叠一下就行，在南瓜机上面有了侦测器确实可以大大减小粘性活塞的使用。不过由于这个结构比之前的方案宽度多了一格，因此没一层可能只能容纳两排南瓜了，因此如果要更密集的堆叠可能需要考虑改进这个结构。\n","date":"2020-12-16T00:00:00Z","permalink":"https://zyxin.xyz/blog/2020-12/MCBud112/","title":"Minecraft 1.12建服及侦测器BUD"},{"content":"之前碰到过很多终端工具可以显示非常好看的进度条，或者显示丰富的颜色，甚至还有的直接可以在终端通过字符绘制UI（a.k.a. TUI），我一直都很好奇是怎么做到的。之后又知道了curses这个Python库和它的一些高层封装（例如asciimatics），然后最终在Stack Overflow里面查到了这些都是通过特殊的终端控制符来实现的。本文就介绍这些终端控制符的使用方法，他们很适合用来写一个简单无依赖的TUI。如果需要更复杂和全面的TUI功能，还是最好使用封装好的库。\nASCII 控制符 在最开始接触编程的时候，如果你学的是C，那你一定很熟悉\\n，这就是一个”换行“的转义字符，代表终端光标令起一行。有时你还会碰到\\r，这是”回车“。“回车”这个名字来源于打字机时代，在使用打字机的时候，如果你需要新起一行，那么需要的操作是：转动滚筒把纸往外抽一行，再把字车（相当与打印机的打印头）移到最左端。这两个操作的名字分别是“换行”和“回车”。因此严格来说另起一行的字符串应该是\\r\\n，这也是Windows的标准，而在Unix中则简化成\\n会自动执行回车。\n换行和回车是两个非常常用的控制字符，也是定义在了ASCII表中的控制字符。在ASCII表中还定义了其他的控制字符，列在下面了。\nASCII名字 ASCII码 printf风格转义 用途 BEL 铃声 0x07 \\a 哔一下（执不执行取决于终端） BS 退格 0x08 \\b *光标回退一格 ESC 退出 0x1B \\e 可代表按下ESC键，不是C标准 FF 换页 0x0C \\f 光标移到新一页 LF 换行 0x0A \\n 光标下移一行 CR 回车 0x0D \\r 光标回到行首 HT 水平制表 0x09 \\t 标记水平制表位（Tab键） VT 垂直制表 0x0B \\v 标记垂直制表位 NUL 空值 0x00 \\0 代表啥也没有，C里面终结字符串 - - **\\c 终止输出，基本不被支持了 *光标这里泛指各类终端的指示当前文本位置的东西，在打字机上叫“type guide”，在显示屏上里面叫“光标 cursor”，而在有些场合也叫指针。 **这个用法貌似只在一些终端中有，我也不确定它是否有对应一个字符。在GNU的文档里有简短解释。\nANSI/VT100 控制符（串） 很多终端都支持彩色文字的输出，而彩色文字的表达方式通常都参考ANSI的色彩标准。而ANSI用来实现色彩显示的转义表还定义了指针控制和设备管理的功能。\n这一类控制符实际上是个字符串，所以应该叫控制串？他们都由\u0026lt;ESC\u0026gt;字符开头，也就是0x1B。所以我推测实际上ESC的双关（退出/转义）也被用到了这里哈哈。以下内容大部分来自 ANSI/VT100 Terminal Control Escape Sequences 表格，详细解释可以参考这个表格以及维基的页面。链接都放在引用部分。\n0x1B在一些终端中会用^[代表，因此如果你看到了^[[那通常也都是通过这种方法转义的字符序列。\n我把这个表中能用于bash的字符都拎出来放在下面了。以下表中的转义序列名称都是我自己翻译的，我不知道有没有统一的中文翻译hhh。\n终端设备相关 名称 转义字符串 查询设备码 \u0026lt;ESC\u0026gt;[c 报告设备码 \u0026lt;ESC\u0026gt;[{code}0c 查询光标位置 \u0026lt;ESC\u0026gt;[6n 报告光标位置 \u0026lt;ESC\u0026gt;[{ROW};{COLUMN}R 重置设备 \u0026lt;ESC\u0026gt;c 可以在你的终端里输入printf \u0026quot;\\x1b[c\u0026quot;，看看会输出什么\n光标控制 名称 转义字符串 设置指针位置 \u0026lt;ESC\u0026gt;[{ROW};{COLUMN}H 指针上移 \u0026lt;ESC\u0026gt;[{COUNT}A 指针下移 \u0026lt;ESC\u0026gt;[{COUNT}B 指针前移（右移） \u0026lt;ESC\u0026gt;[{COUNT}C 指针后移（左移） \u0026lt;ESC\u0026gt;[{COUNT}D 保存指针位置 \u0026lt;ESC\u0026gt;[s 复原指针位置（到保存位置） \u0026lt;ESC\u0026gt;[u 保存指针位置和属性 \u0026lt;ESC\u0026gt;7 复原指针位置和属性 \u0026lt;ESC\u0026gt;8 滚动 名称 转义字符串 启用滚动 \u0026lt;ESC\u0026gt;[r 启用指定行之间滚动 \u0026lt;ESC\u0026gt;[{START};{END}r 向下滚动一行 \u0026lt;ESC\u0026gt;D 向上滚动一行 \u0026lt;ESC\u0026gt;M 制表 名称 转义字符串 设置对齐位 \u0026lt;ESC\u0026gt;H 清楚对齐位 \u0026lt;ESC\u0026gt;[g 清楚所有对齐位 \u0026lt;ESC\u0026gt;[3g 清除 名称 转义字符串 清除文字到行末 \u0026lt;ESC\u0026gt;[K 清除文字到行首 \u0026lt;ESC\u0026gt;[1K 清除整行 \u0026lt;ESC\u0026gt;[2K 清除文字到屏幕底 \u0026lt;ESC\u0026gt;[J 清除文字到屏幕顶 \u0026lt;ESC\u0026gt;[1J 清屏 \u0026lt;ESC\u0026gt;[2J 定义 设置文字绑定: \u0026lt;ESC\u0026gt;[{key};\u0026quot;{string}\u0026quot;p 显示颜色属性 设置光标属性: \u0026lt;ESC\u0026gt;[{attr1};...;{attrn}m 属性代码 属性效果 属性代码 属性效果 属性代码 属性效果 0 重置 30 前景黑 40 背景黑 1 亮 31 前景红 41 背景红 2 暗 32 前景绿 42 背景绿 4 下划线 33 前景黄 43 背景黄 5 闪烁 34 前景蓝 44 背景蓝 7 反向 35 前景紫 45 背景紫 8 隐藏 36 前景青 46 背景青 37 前景白 47 背景白 参考资料 ASCII转义符\nWiki Escape sequences in C Bing ASCII table printf Linux man page ANSI转移符\nANSI/VT100 Terminal Control Escape Sequences Wiki ANSI escape code ","date":"2020-05-10T00:00:00Z","permalink":"https://zyxin.xyz/blog/2020-05/TerminalControlCharacters/","title":"终端的特殊控制符"},{"content":"近来由于项目需要，接触了一下一直没去了解过的Python异步语法，发现和之前我熟悉的C#有很多不同。在深入Python的异步逻辑之后，由于Python在语法上保留了很多语言机制的细节（比如成员函数的self参数），我反而对C#的异步有了更深的了解。这里就来重新梳理一下各种并行方法的区别，以及他们在C#和Python上实现的区别。（这里只讨论单机的并行机制。）\n总的来说，并行机制主要有进程(Process)、线程(Thread)和协程(Coroutine)，其并行实现的开销依次递减，但是他们对每个任务的鲁棒性也是依次递减的。进程是操作系统资源分配的最小单元，线程则是能够被CPU并行处理的最小单元，而协程则是目前实现“并行”的最简单方法。一个进程中可以有多个线程，而一个线程中可以有多个协程。他们具体在特性上有以下区别\n进程 线程 协程 独立内存堆 √ × × 独立处理器（可硬件并行） √ √ × 独立上下文 √ √ × 独立栈、寄存器状态 √ √ √ 进程 进程是系统层面实现并行的机制了，进程管理是现代操作系统的一大核心之一。进程之间互不影响，操作系统会保证一个程序崩溃了，其他程序以及系统内核不会崩溃。操作系统还会提供其他的进程管理功能，例如进程调度、设置进程优先级等等。不同语言底层对进程接口的实现实际上都是对系统接口的封装。\n一些概念 与进程相关的概念通常都是操作系统课程的必修知识哈哈：\n进程间通信(Inter-process communiation, IPC)：故名思意。常用手段有管道、共享内存、信号量(Semaphore)、消息队列等。 管道(Pipe)：管道大概是进程间通信的最常用方式？分命名管道和匿名管道, 进程双方均可往其中读写数据。 远程过程调用(Remote procedure call): 远程过程调用通过特定的消息序列化手段，可以实现进程间通信，其使用形式是把一个“远程”的函数在本地进行执行。 进程锁：如果为了避免多个进程访问同一个资源的冲突的话，就会用到进程锁，其实现方法有管道、信号量、以及文件锁等。 文件锁：文件锁是实现进程互斥的一种常用手段，只需要建立空文件句柄并锁上就可了~并且文件锁还能做到权限控制，非常方便~ C# C#中对进程控制的模块主要通过System.Diagnostics.Process实现，可以实现建立进程、管理进程等，还可以指定具体的内存映射参数，如虚拟内存的页大小。而对管道的支持则是在Process类中有一部分，以及在System.IO.Pipe里面有更全面的接口。我觉得这样的命名空间分类是挺合理的，Process类的API其实只能用来进行程序调用和系统诊断，而Pipe则由于它和Stream的概念比较符合，因此归在IO空间下是合适的。\nPython Python中对进程的控制以及通信方法的实现都在multiprocess包里，它的一些具体使用方法可以参考另一篇之前的博文。值得一提的是，Python中还针对Unix系统提供了fcntl, posix等库专门用来调用系统底层API，这些API有部分是和进程有关的。相关内容还是查阅对应的资料会比较清楚~\n线程 线程是进程中细化的并行机制，线程的实现也需要用到操作系统的接口，不过线程的创建的管理基本都是在进程内部完成的。由于线程之间不独立内存空间，因此在C++这种能够随意操作内存的语言中，一个线程崩了，这个进程也大概率就崩了。但是在C#和Python中，由于有比较完善的Exception机制，并且没有什么机会直接操作内存，一般线程崩了主进程还是能接着跑的。多线程想必应该是大家用的最多的并行方法了~\n一些概念 在线程里面又有一些新的概念\n线程池(Thread pool)：线程池与内存池相似，都是为了避免频繁新建和销毁线程(or 内存)而造成额外的开销 线程锁：线程锁与进程锁相似，是为了避免线程间访问同样的资源而产生冲突（例如race condition）。线程间产生访问冲突非常常见，因此程序员掌握线程锁的使用是非常必要的。线程锁在C++中的\u0026lt;mutex\u0026gt;有非常全面的实现。这里面锁的类型具有代表性，分为条件锁、自旋锁等等，具体区别可以参考这篇博客。C++的多线程非常令人头大\u0026hellip;这里就不展开了。 事件(Event)：在多线程体系中，事件是一种常用于线程同步的机制，如果线程需要在运行过程中等待其他线程的运行，就可以使用事件机制。 C# C#中与线程相关的模块在System.Threading空间下。System.Threading.Thread提供了线程实现的类，使用delegate即可创建线程对象。这个空间底下也提供了SpinLock、Semaphore、Mutex等线程锁，以及AutoResetEvent实现了事件机制。System.Threading.ThreadPool则提供了线程池的实现。另外需要指出的是C#提供了lock关键字，只需对冲突的对象使用lock锁上，那么在其对应的上下文中就能够避免冲突。\nPython Python中与线程相关的对象在threading模块中，其中Thread类提供了线程实现，Lock, Semaphore提供了线程锁，Event实现了事件机制。Python中可以使用with lock:这样的块实现与C#lock相似的语法，但是这个地方的lock仍然需要自己声明，不如C#和Java中的lock用着方便。\n总体而言C#和Python对多线程机制的支持都比较全面，然而CPython有一个臭名昭著的全局锁GIL，使得其多线程效率大幅下降。因此在很多Python库中，大家宁愿使用multiprocess多进程来进行并行（即便需要处理进程间通信的问题），也不愿使用threading来完成并行任务。这一点上不得不说Python辣鸡！\n协程 协程应该是21世纪才用的比较多的技术了，并且这个概念应该是在Go里面提的最多。在前文我提到协程是并行时打了引号，这是因为协程本质上还是同一个时刻只能干一件事，没法利用硬件并行，因此我们形容协程都是用“异步”(Asychronized)而不是“并行”(Parallel)。异步是与同步相对的，只要程序能一会干点这个，一会干点那个，不按顺序来，那就可以称作异步了。协程的广泛应用是由于近些年大型服务器的负载越来越大，并发需求越来越高（同时剁手的人越来越多），多任务切换的开销越来越不可忽视，因此协程这个开销最小的方法就被广泛应用了。协程实际上不是一个比线程更小的概念，而是另一类概念（并行/串行 vs 异步/同步)。协程的特点是一个任务能够跑到一半就暂停，然后把状态存起来，等到需要的东西备齐了以后再把状态复原接着跑；至于暂停之前和之后是不是在同一个线程上跑、有没有跟别的任务一块跑并不重要。因此实际上协程是回调(Callback)机制的一个封装升级。\n实际上不依赖于系统线程的并行技术不止协程一种： A Fiber is a lightweight thread that uses cooperative multitasking instead of preemptive multitasking. A running fiber must explicitly \u0026ldquo;yield\u0026rdquo; to allow another fiber to run, which makes their implementation much easier than kernel or user threads.\nA Coroutine is a component that generalizes a subroutine to allow multiple entry points for suspending and resuming execution at certain locations. Unlike subroutines, coroutines can exit by calling other coroutines, which may later return to the point where they were invoked in the original coroutine.\nA Green Thread is a thread that is scheduled by a virtual machine (VM) instead of natively by the underlying operating system. Green threads emulate multithreaded environments without relying on any native OS capabilities, and they are managed in user space instead of kernel space, enabling them to work in environments that do not have native thread support.\n― Robert Harvey, @StackExchange\n一些概念 事件循环(Event loop)：事件循环是一种非常简单的实现异步的机制，简而言之就是维护一个队列，然后把队列里的任务挨个执行，而任务随时随地可以被添加进队列。 异步执行/等待(async/await)：这两个关键词在多个语言中都有出现。async用来修饰函数，说明这个函数可以异步执行；await用来等待异步函数的结束，如果没有结束就把当前任务搁着。 C# C#中没有协程的概念，C#在5.0版本中引入的async/await关键字提供了异步执行的接口。据我所知C#应该是最早一批引入这个概念的语言了，并且C#里面async和await的使用非常顺滑~。C#的async/await调度与Go一样，都是通过线程池实现，因此性能也非常不错。C#中与async/await有关的接口在System.Threading.Tasks下，里面的Task类型是对能够await的对象的封装。\nC#中也有用到Event loop来实现异步的地方，一般是在UI相关的函数中，例如整个C#里面的event机制都是通过事件循环来实现的。使用事件循环来完成与UI相关的异步应该是非常标准的做法了，例如Qt里面也有QEventLoop来实现UI的异步回调。与Event loop相关的是Dispatcher机制，Dispatcher可以将指定任务加进事件循环中执行，例如在WPF中可以用Window的Dispatcher在其他线程中将任务加进UI主线程。\n另外需要指出的是C#还可以通过yield关键词实现异步，yield return可能是C#最早的异步机制了，不过功能有限，只能与IEnumerable合作使用。C#中有一些协程的库（如Unity里的）就是使用yield机制来实现的。具体怎么使用yield还请去学习C#的语法~\nPython Python对异步的支持就来的比较晚了，直到PEP 492才正式加入了对async关键字的支持，放在了asyncio模块中。Python对这对关键词的实现又很辣鸡了，采用的是Event loop机制来实现（可能是因为多线程性能太差了吧= =）。最让人蛋疼是为了执行异步函数你还需要自己开event loop，如果你之前开过一个了，那你还需要把之前那个loop找回来，然后dispatch进去，这是何其难受！。。\nPython中只要对象有__await__、__aiter__或者__aenter__就可以分别支持await、async for和async with的代码块。Python还设计了三个相关概念：Coroutine代表异步对象、Task代表异步执行计划、Future代表异步执行结果。。何必呢？？？像C#用一个Task代表全部不行吗？再配合event loop的接口，就产生了create_task、run_coroutine_threadsafe、run_until_complete、run_in_executor等我总是搞不清区别的函数。。。我爱C#！\n以上是我对C#和Python中异步机制的总结，我对各语言底层的了解并不深，如有错漏还请指点~\n","date":"2019-11-07T00:00:00Z","permalink":"https://zyxin.xyz/blog/2019-11/ParallelismInPythonAndCsharp/","title":"进程、线程与协程 (C# vs Python)"},{"content":"这次来介绍一下Cython中的特殊函数定义，Cython相比Python本身的特殊函数之外还增加了一些新的函数，用来满足对C特性的支持，其中有些内容还经常令人混淆。关于Python中特殊变量和特殊函数名的内容，请参考Python官方文档。\ndef, cdef和cpdef 首先最开始需要分清的便是Cython中的三种函数类型。def定义的对象（包括变量、函数、类型）都是普通的Python对象，是Python可以直接调用的，因此其参数都只能是Python类型或对象；cdef定义的对象则是C/C++层面的，可以直接用C/C++对象作为参数，因此不能被普通Python代码调用，这样减少了很多overhead因此可以提高运行效率。另外尽管cdef的函数不是Python对象，无法当作变量使用，但还是可以获取函数指针的。而cpdef则是同时兼具两方面特性，其本质是用cdef定义函数后再用def定义一个函数封装，使得在Cython中调用时可以调用高效的cdef版本，而在Python中调用的是与Python兼容的def版本。\n__init__和__cinit__ 在理清了上面几个关键字后另一个经常令人疑惑的点便是__init__和__cinit__的区别。__cinit__和__dealloc__都是Cython特有的特殊函数。官方文档在其用法上解释的并不清楚，只是说__cinit__可以用来进行C/C++级别的初始化。实际上，使用__cinit__的重要原因是源于其特性：__cinit__会像C++一样自动执行基类的__cinit__，因此它保证会在构造时被执行一次（且只被执行一次）。由于Python中的__init__函数默认不会调用基类的__init__，因此如果想保证类型中的cdef成员被初始化，避免可能的堆栈问题（如指针没有初始化），那么就可以选择使用__cinit__。如果理解了这一点就可以知道，什么时候需要使用__cinit__了。\n但是使用__cinit__的时候有很多限制需要了解：\n__cinit__有时会带来额外的开销，这篇博客中有一些分析。 __cinit__的参数声明和__init__必须一致，因为会同时被调用。因此通常__cinit__的参数中会留下*kargs和**kvargs。Stackoverflow上也有人问过这个情况。 __cinit__中如果要用malloc分配内存，记得在__dealloc__中销毁。__dealloc__相当于C++版本的__del__ __cinit__和__init__一样也只能使用def声明，不能用__cdef__和__cpdef__。具体原因我并不清楚。 运算符重载 其他大多数的特殊函数定义和用法几乎和Python相同，但是需要特别指出的是运算符重载的部分。以加法为例，在Python中加法a + b的实现方式是：\n如果a中定义了__add__，那么调用a.__add__(b) 如果a中没有定义，而b中定义了__radd__，那么调用b.__radd(a) 而在Python的C扩展类里（包含Cython和pybind11的实现），其实现方式是寻找接受a和b类型的__add__重载，也就是说本质上在C扩展类中定义的__add__都是__add__的重载，这也是与C++的operator重载理念一致，只不过这个__add__仍然需要定义在类里。在Cython文档中给出的运算符列表里，参数里带self的函数都是按照Python中的方法实现的，self不能指定类型；而以x, y这种形式为参数的则是按照C扩展类执行方式的函数，x和y都可以指定类型。\n另外Cython还定义了一个特殊的运算符函数__richcmp__，这个是Python中没有的，不过其功能只是把比较符号（\u0026gt;,\u0026lt;,=）的实现合并了，与Python的__eq__、__lt__等函数没有本质区别。这在官方文档中也有说明\n__getbuffer__ Cython中有两个版本的Buffer协议，一种是提案PEP-3118定义的，另一种是Python官方定义之前Cython自己的定义方式。其中前者在之前介绍Cython封装的文章中已有介绍，就不多赘述。其相关的特殊函数是__getbuffer__和__releasebuffer__，这两个函数也都是Cython特有的。而后者比较难用，已经被标记为depricated废弃了，也不介绍了。\n属性（property） Cython中还提供了一套非常方便的属性定义方法。原本在Python中定义属性非常但疼，例如下面的代码定义了名为length的属性，使得你可以通过square.length的方法访问它\n1 2 3 4 5 6 7 8 9 10 class Square: @property def length(self): return self._length @length.setter def length(self, value): self._length = value @length.deleter def length(self): self._length = 0 而在Cython中定义属性就更简单了，它除了支持上面的方法外还有另一种更加直观的定义方式（虽然这个方式也已经被标记为depricated了）：\n1 2 3 4 5 6 7 8 cdef class Square: property length: def __get__(self): return self._length def __set__(self, value): self._length = value def __del__(self): self._length = 0 Cython的类型还有各种其他的奇奇怪怪的小特性，在Cython的这两篇文档里有详细介绍：Extension Types, Special Methods of Extension Types，仅供参考～\n","date":"2019-08-28T00:00:00Z","permalink":"https://zyxin.xyz/blog/2019-08/CythonFunctions/","title":"Cython中的特殊函数"},{"content":"Cython提供了很多方法来搭建C/C++内存和Python对象间的桥梁，但是官方的教程只介绍了一些基础的方法。这篇文章就介绍一下我在各个场合学到和用到的Cython封装（多维）数组的技巧。一般而言这个桥梁会分为两部分，Python与Cython和Cython与C/C++。其中Python中的数组主要形式是list、array.array和numpy.ndarray；Cython中的数组形式有[:,:,:]（Memoryview/Buffer）和cython.view.array；C/C++的数组形式有**（指针）、vector和Eigen::Vector/Matrix。\n本篇介绍的主要内容也来自于Cython的文档：Typed Memoryviews。\n在这里也先介绍一下Cython中的这几个概念：\nMemoryview：这是cython提供的一种语法糖，相当于提供了C中int[][][]形式数组的类型。由于Memoryview可以兼容Python的Buffer协议，因此我把他们放在了一起。Memoryview需要指定元素的类型，这个类型必须是内置数值类型或者C结构体。 cython.view.array：这是Cython提供的一个多维数组类型，与numpy.ndarray非常相似了。 这两个东西也是可以相互转换的，例如 1 2 3 4 5 6 7 8 from cython.view cimport array as cvarray # Cython array to Memoryview cyarr = cvarray(shape=(3, 3, 3), itemsize=sizeof(int), format=\u0026#34;i\u0026#34;) cdef int [:, :, :] cyarr_view = cyarr # Memoryview to Cython array cdef cvarray back = cyarr_view Python与Cython数组相互转换 Python与Cython之间的转换基本上都由Cython的Memoryview提供了接口，实际上直接赋值就可以。例如官方给出的这段例子：\n1 2 3 4 5 6 7 8 9 10 from cpython cimport array as cparray import numpy as np # Memoryview on a NumPy array narr = np.arange(27, dtype=np.dtype(\u0026#34;i\u0026#34;)).reshape((3, 3, 3)) cdef int [:, :, :] narr_view = narr # Memoryview on a CPython array parr = cparray.array(\u0026#39;i\u0026#39;, range(3)) cdef int [:] parr_view = parr 顺带一提，list对象由于本身不代表一段连续内存，因此需要先转换为array或ndarray再赋值给Memoryview。反过来由于Numpy支持Buffer协议，因此Memoryview和Cython的cython.view.array都可以直接转换为numpy.ndarray，然后转换为array和list：\n1 2 3 4 5 6 from cpython cimport array as cparray import numpy as np parr = cparray.array(\u0026#39;i\u0026#39;, range(3)) cdef int [:] parr_view = parr narr = np.array(parr_view) # explicit version: np.array(parr_view, copy=False) 以上这些代码中的等式都没有发生内存拷贝。\nCython数组与C/C++数组相互转换 Cython的Memoryview同样承担了大量与C/C++数组进行转换的功能，不过Memoryview只支持一种转换方法，就是与raw指针的相互转换：\n1 2 3 4 5 6 7 8 from libc.stdlib cimport malloc cdef double* data = \u0026lt;double*\u0026gt;malloc(sizeof(double) * 4) # Convert pointer to Memoryview cdef double[:] view = \u0026lt;double[:2,:2]\u0026gt;data # Convert Memoryview to pointer data = \u0026amp;view[0,0] 以上代码的等式中也没有发生内存拷贝。\n这里需要指出的是，由于指针本身只是一段内存的代表，因此在转换时制定类型和长度（如\u0026lt;double[4]\u0026gt;），并且需要保证指针指向的数组是C型连续的（多维数组中最后一维的内存是连续的）。如果要将vector和Eigen::Matrix转换为Memoryview，那么也同样需要获取其内存指针（vector::data和Eigen::Matrix::data）。另外，通过指针转换出来的Memoryview没有引用计数，因此如果你的指针是某个Cython类的成员，那么不要使用指针转换，而使用Buffer协议的方式进行传递。\n其他直接转换的方法 除了上面提到的方法之外还有一些直接转换的方法，但是这些方法往往不会做类型和尺寸检查，以及很重要的内存连续性检查（Memoryview会区分C型内存和Fortran型内存），因此使用时需要谨慎。\ncdef vector[int] data; cdef list view = data：Cython提供了list和vector直接转换的接口 cdef np.ndarray[double] data; cdef double* view = \u0026lt;double*\u0026gt; data.data cdef np.ndarray[double, ndim=2] data; cdef double* view = \u0026amp;data[0,0] cdef array.array data; cdef double* view = data.data.as_doubles[0]：利用了Cython中的API 非内置类型的转换 在实际应用过程中还会碰到由复杂元素构成的数组（例如PCL里面的PointXYZ、SLAM里会用到的Quaternion），这时就有将复杂类型（通常是自定义struct）在Python和C/C++之间转换的需求。这时可以选择利用Cython提供的MemoryView，也可以利用Python的Buffer协议直接将C++对象传递给Python。\n使用Buffer协议的方法请直接参考Cython文档，使用Memoryview的例子如下：\n1 2 3 4 5 6 7 8 9 10 from libc.stdlib cimport malloc import numpy as np cdef struct buf: int size int count cdef buf[:] data = \u0026lt;buf[:2]\u0026gt;malloc(sizeof(buf)*2) print(np.array(data).dtype) # [(\u0026#39;size\u0026#39;, \u0026#39;\u0026lt;i4\u0026#39;), (\u0026#39;count\u0026#39;, \u0026#39;\u0026lt;i4\u0026#39;)] ","date":"2019-08-28T00:00:00Z","permalink":"https://zyxin.xyz/blog/2019-08/CythonArray/","title":"在Cython中操作数组"},{"content":"用Cython也用了很有一段时间了，这次就介绍一下它的最重要功能——使用Cython来封装C/C++代码。最基本的封装方法可以参见Cython文档中的相关页面：Interfacing with External C Code和Using C++ in Cython，本文介绍主要是比较重要和常用的Cython/C++交互特性，而自定义Python拓展类（而不是封装现有C++）的一些操作可以参考官方教程。\n封装C++代码时，最重要的关键词就是extern，在定义函数时使用这个关键字就说明该声明是外部的，而使用cdef extern from语句就能指定声明对应的头文件。例如如果要封装函数func，对应的Cython语句是\n1 2 cdef extern from \u0026#34;func.c\u0026#34;: void func(int arg) 文件结构 首先讲一下Cython的文件结构。如果你之有一个小模块需要封装的话你可以把所有代码写到同一个pyx里进行编译，否则的话你就可以利用Cython的目录结构来管理多个层次的代码。Cython的文件一共有三种：pyx，pxi（注意与pyi区分）和pxd（注意与pyd区分）。\n.pyx是Cython的源文件，类似于.cpp文件在C++中的地位，而对应.h头文件地位的则是pyi。在Cython中添加import 'header.pyi'的语句就会将header.pyi文件中的内容原封不动地直接插入当前位置，这与C++的#include语句的作用是相同的。而pxd则是另一套符号化的逻辑，.pxd文件中只能声明函数、声明类型、不能有函数和类型的定义内容（除了inline函数外），而在cimport了pxd的定义之后当前代码便引入了对应的函数或者类型签名。这个工作方式则更符合C++中头文件的实际用途。定义了pxd后就可以在多个Cython文件之间共享同一个类型了。\n不过既然涉及了include语法，就必然要指定类似于C++的引用路径了。pxi和pxd文件的引用路径可以在cythonize过程中手动指定，而pxd由于是符号化的还可以通过新建__init__.pxd的方式来实现类似于Python的引用方法。只要在Cython搜索目录下的文件夹中包含__init__.pxd文件，Cython就会认为这是一个Cython库，之后就可以用cimport语句通过与Python中import相类似的语法将对应模块文件（.pxd文件）引用进来。当然，pxd文件也可以通过命令参数直接导入。关于如何组织这些文件以及头文件之间的关系，读者可以参考我写的PCL封装库和Cython的相关文档。\n函数在pxd中的定义不能显式指定默认参数，而是必须用*代替，例如cdef void func(a=0)在pxd中声明的话需要改为cdef void func(a=*)。\n类型封装 Cython对C++的类型提供了基本可用的封装语法。为什么说基本可用，是因为Cython目前对模板的支持还非常有限，因此实际上可以说Cython只支持到C++98的程度。不过尽管如此，Cython已经能够完成大多数代码的封装需求了。Cython对class的支持通过cdef cppclass \u0026lt;class-name\u0026gt;来实现，这里cppclass关键词是为了和Cython的class关键词进行区分。Cython中class关键词代表的是和Python一致的PyObject对象，代表的是Python类型，而cppclass则指代C++原生类型，由于Cython文件中无法直接编写C++代码，因此cdef cppclass语句通常在cdef extern from的语法块中，用来封装现有的C++类型。另外一点需要注意的地方是Cython提供封装enum和struct的语法，但是针对的是C中的enum和struct，而非C++中的enum class和struct（C++中struct和class几乎没有区别）。如果要封装C++版本的enum和struct可以直接使用cppclass关键词。以下是封装C++类型的一个例子：\n1 2 3 cdef extern from \u0026#34;test.h\u0026#34;: cdef cppclass Test: void print() 别名与 namespace 关键字 由于Cython最后生成的是全局的C代码，因此在引用C++类时需要明确声明类型含命名空间的全称，这里就需要用到别名的机制。Cython允许从.h文件中导入声明的时候给类型和方法改名字，具体用法如下\n1 2 3 4 5 cdef extern from \u0026#34;\u0026lt;header-name\u0026gt;\u0026#34;: cdef void \u0026lt;new-function-name\u0026gt; \u0026#34;\u0026lt;origin-function-name\u0026gt;\u0026#34;: pass cdef cppclass \u0026lt;new-class-name\u0026gt; \u0026#34;\u0026lt;origin-class-name\u0026gt;\u0026#34;: pass 简而言之就是在方法或者类型名称后添加引号，引号里写上原本C++中的名字。这个机制有很多tricky的用法，它可以用来声明带命名空间的方法和类型、可以用来重命名C++中的运算符、可以用来直接声明实例化的模板类型、甚至可以用来把C++常量声明成类型用于模板参数（这种操作可以参考eigency库中的代码）。\n其中针对第一种用法，为了简化带有命名空间对象的声明，Cython加入了namespace关键字。在cdef语句中添加namespace从句可以使得Cython编译器默认给其包含的语句块中所有的类型加上对应的命名空间，例如\n1 2 3 cdef extern from \u0026#34;test.h\u0026#34; namespace \u0026#34;ns\u0026#34;: cdef cppclass Test: pass 与以下代码是等价的\n1 2 3 cdef extern from \u0026#34;test.h\u0026#34;: cdef cppclass Test \u0026#34;ns::Test\u0026#34;: pass 模板支持 这个特性在之前介绍Cython类型的文章中也有提到过，这里补充一下它的一些特性。Cython对C++模板的支持通过[]符号实现，以下是Cython中对vector的封装代码可供参考\n1 2 3 4 5 cdef extern from \u0026#34;\u0026lt;vector\u0026gt;\u0026#34; namespace \u0026#34;std\u0026#34; nogil: cdef cppclass vector[T,ALLOCATOR=*]: ctypedef T value_type ctypedef ALLOCATOR allocator_type ... 其中vector[T,ALLOCATOR=*]对应的就是C++中的vector\u0026lt;T, ALLOCATOR\u0026gt;符号。模板参数在Cython中同样可以有复数个，也可以有默认值，似乎现在也支持常数作为模板参数，不过我没有尝试过，而据说老版本是不支持常数模板参数的。\n之前有提到Cython中对模板的支持是阉割过的，主要特征有以下几点：\nCython不支持模板参数的类型声明访问。例如上面的vector类型声明中不能使用ctypedef allocator_type.size_type size_type这样的语法，而这样的类型推断在C++中是有很多的。 Cython不支持模板构造函数中包含新的模板参数 不过Cython一直在改进对模板的支持，因此以后也很有可能会得到改进。 Buffer协议 Cython还针对性地支持了Python的Buffer协议，用来传递一块结构化的内存，这个协议的标准被记录在了提案PEP-3118中。这个协议通过__getbuffer__和__releasebuffer__两个Cython自定义的特殊函数实现，通过这个方式Cython代码就可以将C++内存转化为Python识别的内存。因为Numpy支持将支持Buffer协议的对象转换为ndarray，因此这个Buffer协议的通常用法是将一个C++对象变成Numpy的矩阵。具体的使用案例也可以参照我的pcl封装库中的对应代码。\n本文介绍了Cython中操作C/C++对象的方法，不过仅仅介绍了一些进阶用法。如果是新手的话还是先参照之前提到两篇文档学习基本的函数、类型封装方法吧～\n","date":"2019-08-27T00:00:00Z","permalink":"https://zyxin.xyz/blog/2019-08/CythonInterop/","title":"Cython与C/C++的交互"},{"content":"Python作为一门胶水语言，它与C/C++之间的兼容性（Interoperability）我认为是它相比其他动态语言脱颖而出的最大原因。Python原生支持的是与C语言的接口，Python的发行版自带有Python.h头文件，里面提供了在C中调用Python和反过来在Python中调用C的接口定义。但是C++就不一样了，虽然C++ ⇔ C ⇔ Python的通道是可行的，但是想要完整兼容C++的特性的话需要很多额外的重复代码（boilerplate）。因此相应针对Python/C++绑定的库也就应运而生了，我所了解的库主要有四个：Boost.Python，Cython，pybind11，SWIG。虽然网上也有不少比较三者的页面，但是我觉得都不够详细，这篇博客就介绍一下我基于使用这几个库的经验比较。\n上面说到的这些库我基本都有接触过，其中用过的有pybind11和Cython，分别用在了我正在写的CGAL和PCL的绑定上。另外二者则是在其他库的代码中有读过（如Caffe和CGAL的官方绑定）。总的来说，Boost.Python和pybind11主要用于给现有C++代码提供Python绑定，并且不用学习新的语法;SWIG提供一个给C++代码编写多种语言绑定的框架，它本质上是一种代码生成器，基于SWIG自定义的语法;Cython则是基于Python的C/C++代码封装器，其本质也是代码生成器，但是Cython的语法是Python的超集，也就是说Python的代码可以零成本移植到Cython中。\nBoost.Python vs pybind11 Boost.Python是一个Boost框架中封装C++代码的工具，通过宏定义和元编程来简化Python的API调用，消灭bolierplate。Boost.Python还提供对Numpy底层API的封装，因此适用性很强，能满足Python绑定的绝大多数需求。而pybind11则是受Boost.Python启发的一套类似的API，其目标是提供Header-only的易用的Python接口。由于pybind11脱胎于Boost，因此它们的接口非常相似，例如最简单的封装一个函数，Boost.Python代码如下\n1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;boost/python.hpp\u0026gt; int add(int i, int j) { return i + j; } BOOST_PYTHON_MODULE(example) { using namespace boost::python; def(\u0026#34;add\u0026#34;, add); } 而对应的pybind11代码则是\n1 2 3 4 5 6 7 8 9 #include \u0026lt;pybind11/pybind11.h\u0026gt; int add(int i, int j) { return i + j; } PYBIND11_MODULE(example, m) { m.def(\u0026#34;add\u0026#34;, \u0026amp;add); } 因此熟练掌握这两者之一的开发者能很快上手另一个库的使用。他们的编译方式也是相似的，只需添加一个工程，写好对应的封装代码，然后利用他们的CMake模块进行编译，生成的动态链接库只要文件名正确就可以直接从Python进行import了。他们二者的区别主要有以下几个方面：\npybind11是Header-only的，因此只需把它的头文件添加到include目录就算安装好了。而Boost.Python则是需要先编译安装才能使用，需要处理其依赖。 pybind11的社区更加活跃，Boost.Python则受限于Boost的更新周期，回应反馈可能会比较慢。 pybind11的易用性更好，文档齐全且友善，由于没有依赖问题，编译方便上手也快。 Boost.Python兼容旧特性的C++，也兼容Boost自定义的类型（如smartptr），因此如果需要封装的代码是基于Boost的，那可能Boost.Python会比pybind11合适。pybind11针对的环境则是C++1x，并且只支持标准C++库。 Boost.Python对Numpy的支持比较完备，例如Boost.Python支持自定义numpy.dtype，而pybind11对Numpy的支持主要基于Python的buffer协议。 因此基本上如果封装不基于Boost的库的话可以先考虑pybind11，而如果是封装基于Boost的库（如PCL），或者深度操作Numpy，那还是直接上Boost.Python吧～ Boost.Python/pybind11 vs Cython 这两者的选用其实差别非常大，因为他们的代码逻辑都是不同的。而具体选择哪个库就纯粹是根据需求出发了。他们的区别如下（以下pybind11同时也代表了Boost.Python）\npybind11基于C++，更适合C++工程师。Cython则是基于Python，写习惯的Python的人上手更快，并且能同时方便地兼容Python和C++。 Cython相比pybind11的环境配置更加简单，用户只需通过pip安装Cython就可以利用Cython的功能了，也无需配置路径。 Cython封装C++类会比Boost.Python更加繁杂，你需要先定义C++类，再封装成Python类。相当于Cython还多一步翻译头文件的工作。 Cython支持模板（虽然是阉割版本）！这是Cython独家的一个killer特性，不过是与第3点相关联的。如果你已经翻译好了现有的模板代码，那么用户就可以用Python的语法来自行展开模板了！pybind11需要在编译的时候实例化模板，因此一般只封装常用的实例，或者穷举所有实例化可能（这会导致生成的封装库尺寸爆炸） pybind11封装重载函数比Cython要方便太多！Cython封装重载函数的话一般需要定义大量的可选参数和类型判断。 Cython封装继承类就更加麻烦了，不仅要处理方法重载，还要复制继承关系，十分繁复。 Cython无法利用上C++的宏定义，这对支持条件编译非常不利，很多时候还需要自己利用Cython的条件语句翻译一套条件编译的逻辑。 Cython似乎在封装上比pybind11性能好，参见pybind11#1227和pybind#2005。如果你的代码需要经常调用封装后的函数，那么选择Cython性能更好。 以前很多人使用Cython的原因是Cython可以很方便地加速Python代码，但是numba.jit的出现则让这个功能实际上成了鸡肋，因此Cython最近的使用率也是越来越低了。如果没有很强的对保留模板灵活性的需求，或者不是封装目标不是基于C语言的，那还是选择pybind11来的方便。如果封装接口只是一小部分需求的话也还是用Cython会更加一致，我在自己的PCL绑定项目中使用Cython的原因是有大量基于Python的扩展代码，因此使用Cython还是能更方便。\nSWIG SWIG是个很神奇的东西，他能够将C++代码封装成Python/C#/Java/Ruby等多种语言，但是也正因为这个灵活性，它对C++的高级特性的支持就比较辣鸡了。在CGAL官方的绑定库中可以看到有不少代码需要针对Python和Java打补丁，因此如果没有多语言的需求的话SWIG应该是下下策了。这应该也是SWIG一直没啥发展的原因吧～\n总而言之，如果有多语言绑定的需求可以选择SWIG，如果有以下需求可以选择Cython，其他情况选择pybind11即可\n需要保留模板参数，让用户可以自行选择用什么类型展开，或者目标用户有继续使用和拓展C++ API的需求时，用Cython便于用户使用 有大量的封装函数调用时，Cython的性能最好 绑定的对象是C语言写的API或者不涉及面向对象的话，那么用Cython写封装会更方便（不用处理编译的问题） 本文介绍了Boost.Python/pybin11/Cython/SWIG之间的特性与区别，而具体用法则是一笔带过。如果大家对其中的某工具感兴趣的话可以直接去官网看教程～也欢迎参考我的Cython系列博客，以及我的一些Github项目如pcl.py，cgal.py。\n","date":"2019-08-11T00:00:00Z","permalink":"https://zyxin.xyz/blog/2019-08/GluePythonCpp/","title":"如何选择Python与C++之间的胶水"},{"content":"最近在研究ROS节点（ROS Node）的参数设置方式，由于系统比较复杂，并且会变得更加复杂，因此需要一个统一的参数设置方式。这里就比较一下四种参数获取方案的区别～\n命令行/文件输入 由于ROS节点本身也只是普通的可执行程序，因此它可以正常地从启动参数中读取参数，另外也可以从配置文件中读取参数。这两种方法都是常规程序读取参数的方法。从命令行中读取参数有C++的Boost.Program_options库和Python的argparse的库，用来解析命令行参数输入，支持可选参数、重复参数、参数分组等等。而从文件输入的话，常见的设置格式有json，yaml，toml甚至ini等等。从这些文件中读取比较灵活，但是无法利用ROS框架，并且需要自行统一格式。\n参数服务器 ROS中很有名的支持参数设置的结构是参数服务器，参数服务器是一个包含在master结点里的集中式字典结构，在ROS的Wiki上有介绍：中文|英文。参数服务器也可以从文件中读取参数，文件格式是yaml，读取的方式是在.launch文件中添加\u0026lt;rosparam\u0026gt;标签，并指定键值或者文件路径。\nrosparam rosparam是操作参数服务器的一套工具，你可以从程序中调用rosparam的API，或者使用命令行工具对指定参数进行动态更改。命令行的用法参见ROS Wiki\nrosrun rosrun和roslaunch都是运行ROS模块的工具，其中rosrun只能运行单个节点，而roslaunch则支持更加复杂的启动体系。用rosrun进行参数服务器的设置的方式是在启动参数中添加key:=value。\nroslaunch 用roslaunch进行参数服务器的设置的方式是在文件中添加\u0026lt;param\u0026gt;标签。和实质上功能相似，前者设置的是单个参数，而后者针对的是一套参数。另外roslaunch还支持从命令行读取参数，格式也是key:=value，读取进来后存入的是标签，而如果要使用这类参数的话需要使用roslaunch的$(arg key)语法。具体的roslaunch`语法参见ROS Wiki。\ndynamic_reconfigure ROS中还提供了另一种机制叫dynamic_reconfigure也可以用来动态设置参数。它与参数服务器的区别在于它的参数更新是基于回调机制，而参数服务器实际上是轮询机制。ROS程序会主动询问参数服务器以获取参数，而dynamic_reconfigure则是动态地告知ROS程序参数更新事件。dynamic_reconfigure的使用方法是定义.cfg文件，并在其中通过Python程序定义可动态设置的参数。cfg文件在CMakeLists.txt中需要注册，注册语法及顺序参见CMakeLists.txt的Wiki和.cfg文件的Wiki。个人感觉实际上dynamic_reconfigure实现的效果和自己定义ROS服务来更新参数是相似的。\n最后总结下来的话ROS参数服务器还是最常用的，但是参数服务器的名称同样也有命名空间的限制，也分私有参数和公有参数等等。。这两个的区别我其实现在还没有搞清楚= =\n","date":"2019-08-02T00:00:00Z","permalink":"https://zyxin.xyz/blog/2019-08/ROSParameter/","title":"ROS参数设置方法总结"},{"content":"最近我已经将KDE Neon作为主力系统之一了，Plasma桌面真的是太好用了！于是给家里的主机也装上了Neon，这篇文章就记录一下安装配置和美化的过程啦～\n系统安装及Boot设置 双系统安装 安装Neon还是非常简单的，直接从官网下载系统镜像，烧进U盘正常安装即可。不过由于我选择的是与Windows双系统安装，因此需要手动分区。这里要纠正一下之前[安装双系统博文中的分区方式](https://zyxin.xyz/blog/2018-09/LinuxDualSystem/。现在的Linux系统实际上只需要给根目录/分区就可以了，/home分区以前建议单独分区的原因是为了便于系统的更改，这样在修改系统分区之后（如重装系统）还能保留/home底下的文件，但其实现在很多系统已经能做到重装并保留/home分区了，这时对于我这小硬盘的笔记本来说反而导致空间利用不灵活。而交换分区/swap也是没有必要的，交换分区的存在类似于Windows下的虚拟内存，用硬盘的一部分来虚拟内存，避免内存不足的情况。新Linux可以利用交换文件完成类似功能，因此不必专门给/swap分区。（不过我猜专门给它分个区可能能提高性能？）。最后最关键的是不要给/boot分区了,/boot分区是为了保证boot文件区不被占满，以致无法正常启动。利用EFI方式启动的系统只需要有efi分区即可，而且多个系统可以利用同一个EFI分区。因此只需告诉安装器使用EFI分区作为启动分区，关于EFI的详细信息请看后文~\n分区的时候还看到了之前的系统里有标记为msr的分区，是Windows的预留分区，好像具体没啥用。这里贴一篇考据文章。\nrEFind设置 安装完系统后我还准备安装rEFind来替代默认的bootloader——GRUB(GRUB实在是太丑了\u0026hellip;)。由于Windows10禁掉了启动其他系统的入口，因此之前只能用GRUB。rEFind是一个更加强大的启动器，并且可自定义的部分也多～rEFind是基于UEFI的启动器，相比GRUB能支持更多的功能，甚至可以在启动阶段就加载一些驱动，这就使得rEFind可以有高清的界面哈哈哈～关于UEFI与传统BIOS的区别可以参考Manjaro论坛的这篇帖子和知乎的这篇帖子。UEFI和BIOS都是主板ROM程序启动后调用的bootloader类型，当bootloader通过UEFI或者BIOS过程加载之后就会启动系统内核。而UEFI相比BIOS可以支持更大的bootloader和并行启动，是现在大部分系统采用的启动方式～\nrEFind在Ubuntu下安装非常方便～直接用apt安装即可。安装完重启就会发现默认进入的已经是rEFind界面了～不过默认的界面主题非常丑，也有很多多余的启动项，因此还需要稍微设置一下～设置教程网上有很多了，主题在官网和搜索引擎也都可以搜到，这里就不赘述。我的设置文件可以在Github找到～我保留了GRUB的chainload入口，避免rEFind崩了进不去系统，然后另外添加了一个直接启动Linux内核的入口。最后界面效果如下，还是很赏心悦目的～\n{% asset_img refind.jpg rEFInd界面照片 %}\n安装完成以后就接着参考之前的文章继续设置就可以了。其中最必要的两个操作是把系统时间调成local-rtc避免与Windows冲突，以及把Plasma环境中鼠标单击的行为从打开改为选择。。。\n输入法安装 Neon安装完后默认是没有输入法的，不过反正中文输入法都是要安装fcitx的，还避免了使用ibus的冲突～fcitx的安装参考这篇文章即可，其中fcitx-qt-impanel这个包可以让fcitx的状态显示在任务栏里～最近好像fcitx在开发新版本(fcitx5)，不过目前还只有Arch linux有包可以直接用，因此也就没折腾了。\n安装完成之后还需要让fcitx框架跟随系统在后台启动，在Ubuntu底下修改的文件是.xprofile，而KDE桌面环境不会加载.xprofile，而是加载.xsessionrc，修改方式参见Arch Wiki，最后好像还需要加fcitx \u0026amp;来确保启动= =\n折腾这些玩意的过程中发现Arch Wiki真是个好东西啊～KDE桌面的大部分问题都可以搜到解答～ .xinitrc, .xprofile，.xsession这些设置文件我真的是被搞蒙了。。这里有一篇帖子和一篇回答梳理了他们的关系，可供参考～ rclone配置 另一个必装的好东西是rclone，之前在远程桌面设置的文章中有提到。由于KDE内置的GoogleDrive和OneDrive连接不太好使，还是用rclone来访问网盘吧= =。在设置好rclone之后可以通过自定义服务的方式让rclone在系统启动时自动挂载网盘到指定路径，然后在Dolphin（KDE的文件管理器）里面将这两个位置添加到左侧目录就可以啦～这样就可以直接从文件管理器访问了～具体的配置文件可以参考我的Github。\n如果自定义服务添加到的位置是系统服务位置，那么可能会碰到权限问题，这里有解决方法 关于systemd的服务设置可以参考Arch Wiki 主题设置美化 Plasma主题设置 KDE Plasma最大的优点就是流畅以及好看！不折腾一下主题真的是对不起这么好的环境了～我大概主要进行了以下修改\n风格选择Breeze Dark， 透明度设置为70%左右 图标使用Papirus Dark 使用透明桌面主题Breeze Transparent Dark Firefox浏览器去掉titlebar，主题设为Dark 添加全局菜单添加到底部 注意默认的Firefox去掉titlebar的话对全局菜单的Plasmoid支持有问题\nfcitx主题选择Dark 在桌面特效中选择喜欢的窗口动画，调节窗口透明度～ 剩下的换壁纸、配色主题什么的都来一遍就可以了～最后的桌面效果见标题图，还是很顺眼的～\n其他小工具 窗口附着缩放 这个KWin脚本名叫Sticky Window Snapping，真的是神器！可以让附着在一块的窗口同时进行尺寸调整！这个功能相当于Windows分屏功能的升级版，这酸爽谁用谁知道啊！～下载地址见KDE商城，使用效果在官网有动图可以参考～还有个类似的脚本可以做到让窗口严格按照网格排列，不过相比之下就显然鸡肋很多了。\n这些功能的Windows替代品可以参见少数派的文章，不过貌似没有免费的软件可以做到Tilting\nRedshift（红移） 红移是Linux底下提供“护眼模式”的软件，有点类似f.lux，这个对我们这个天天盯电脑的还是很有用啦～安装直接apt install redshift plasma-applet-redshift-control即可，第二个软件是Redshift的Plasma插件，可以在任务栏通过它来调节红移，非常方便～安装完后应该就可以通过Plasma挂件来设置红移了，如果不能自动识别地理位置的话参考Arch Wiki中描述的geoclue工具\n其他还有一些KDE下非常好用的软件，也一并列在这里了～以后用多了再专门开个文章～\nKdenlive / Audacity：免费的视频/音频剪辑软件，基本够用了～ Meld：文件比较器 Remmina / KRDC：远程桌面的客户端，后者是KDE自家的，感觉比Remmina还是差点 VLC：视频播放器，可以部分替代PotPlayer Peek / Kazam：录屏软件 Flameshot：截屏软件 Gimp：图片编辑软件，堪比Photoshop Krfb / Xrdp：远程桌面的服务器 DeaDBeeF：音乐播放器，对cue和utf的支持非常好，可以部分替代fb2k KDE Partition Manager：KDE版GParted，功能差不多而且界面美观～ fzf / ripgrep：模糊搜索工具 Golden Dict：强大的词典框架 KGet / aria2：下载器 youtube-dl：视频下载器（Python） WPS / OnlyOffice：办公套装 ","date":"2019-07-31T00:00:00Z","image":"https://zyxin.xyz/blog/2019-07/ConfigureKdeNeon/neon.png","permalink":"https://zyxin.xyz/blog/2019-07/ConfigureKdeNeon/","title":"折腾 KDE Neon 的配置"},{"content":"最近由于工作需要，和终端命令行打交道的时间越来越多了，最近便查了一下美化命令行的方法，记录在此以供查阅～另外还推荐一个网站terminalsare.sexy，提供了很多与terminal美化相关的软件。\n命令提示符（Prompt）美化 相信不少朋友也见过如下图所示美化过的命令提示符 这个效果的实现方式是通过安装名为Powerline的扩展程序。Powerline是一套可拓展的状态栏提示工具，可以给各种Terminal Emulator和Vim等工具增加状态栏的提示，并且十分好用～\nPowerline有很多版本，有直接通过shell配置脚本实现的，也有通过独立程序进行显示的（如下列所示）。我选择的是原版powerline，安装方便，适用软件多，并且可以自行扩展。\npowerline: 这应该是最初的也是最全的powerline，基于Python powerline-shell: 这是针对美化shell的版本，同样基于Python，配置比上面的简单 powerline-go: 用go语言写的版本，运行更快 bash-powerline: 用bash编写的用于bash的powerline 原版powerline的安装非常简单，用pip安装即可：(sudo) pip install powerline-status。安装完以后根据官网的教程更改对应的配置文件即可～我只对bash进行了美化，因为bash是最常用的shell。使用bash的话建议按照教程里的指示，在命令行配置文件中开启daemon来提高加载速度。另外一个小技巧是，由于Python2的启动速度比Python3快，因此推荐用Python2来安装powerline。\n安装好powerline后下一步是自定义，这部分内容在powerline的文档里也有描述，不过它的文档写的不太好。。参考powerline安装目录下的配置文件（如果用系统pip安装的话位置是在/usr/local/lib/python2.7/dist-packages/powerline/config_files下），在用户配置目录下~/.config/powerline新建对应的配置文件，然后修改相应的条目即可自定义配置了～比较实用的一项修改是将shell的默认theme改为default_leftonly，不增加这个改动的话不会有git状态的显示。。（并不知道是什么原理）\n如果使用原生Ubuntu或者VSCode内置terminal的话还可能会遇到提示符乱码的原因，这是由于powerline使用了非常规的符号，因此需要安装额外的字体。一般会选择安装NerdFont，这是一系列打上符号补丁的字体，其中我个人比较喜欢的字体是DejaVu Mono Nerd～这些字体还可以在programmingfonts在线预览，挑选喜欢的后将Terminal默认字体更改即可。（注：ubuntu下的查看字体列表命令是fc-list）\ntmux安装及美化 tmux是非常著名的Terminal Multiplexer，也就是终端多开程序。很多命令行模拟器其实已经支持多标签页了，如gnome terminal和Konsole，多开的功能其实也已经得到满足了。（顺带一题，ubuntu下新开terminal窗口的默认快捷键是Ctrl+Alt+T，新开标签页的默认快捷键是Ctrl+Shift+T。）。但还需要tmux是因为需要tmux的session管理功能，这个对远程访问的时候非常有用。有时希望在服务器远端跑一个训练，开上以后就不想管了，那这时如果使用ssh的话就得一直把远程的session开着，或者运行命令后移到后台，但这时停止程序就蛋疼了。另外如果想远程开几个terminal的话也很麻烦，要开好几个ssh的窗口。有了tmux就简单了，你可以用tmux多开然后一次性detach多个session，之后再attach回来进行管理，tmux支持多个程序显示在同一个terminal里，也就不用开很多个ssh了！总之用上tmux后感觉还是很爽的，只不过tmux有一定的学习成本。\ntmux安装也很简单，ubuntu下的话直接使用apt安装即可。另外还可以安装tmuxinator来简化tmux的一些流程。上面用到的powershell也是支持tmux的，可以美化tmux的状态栏。具体安装方法参见powerline文档。另外tmux的操作方法可以去搜cheatsheet～这也有一篇博文介绍了tmux的基本操作，可以参考～\n历史记录搜索 著名的fish有个颇受称赞的功能是历史命令自动补全（见下图），在zsh里面也有对应的插件可以实现这个功能（zsh-autosuggestions）。但是bash由于比较辣鸡，无法支持这样的功能，因此只能另寻它法了。。 比较有名的方法是使用一个模糊搜索的软件fzf。这个软件提供文件、程序和命令历史的搜索，有点类似于windows下的Listary。如果配置在shell中的话可以在按下快捷键后出现一个搜索框，搜索历史命令。这个虽然没有fish的自动补全好用，但是也非常方便了～安装fzf推荐通过文档中的方法使用git安装。安装过程中会提示你是否绑定终端快捷键，选择yes后在终端按下Ctrl+R就可以弹出搜索框了，非常方便～如果直接运行fzf命令的话就会进入完整的搜索界面，可以搜索文件，具体的使用方法还是参考官方文档了～\nPowershell美化 由于Powershell不是传统的sh体系，因此目前powerline还没有官方支持powershell。这里先mark几个博客，设置好了再更新上来～\nhttps://github.com/JanDeDobbeleer/oh-my-posh https://blog.walterlv.com/post/beautify-powershell-like-zsh.html#%E5%AE%89%E8%A3%85-oh-my-posh https://gist.github.com/jchandra74/5b0c94385175c7a8d1cb39bc5157365e https://dev.to/myleftshoe/comment/8b58 https://www.reddit.com/r/archlinux/comments/45lkyj/is_new_always_better_urxvt_vs_xterm_tmux_vs/ ","date":"2019-07-13T00:00:00Z","permalink":"https://zyxin.xyz/blog/2019-07/BeautifyTerminal/","title":"终端（Terminal）美化与扩展"},{"content":"在学习线性系统以及SLAM的过程中碰到了很多矩阵的求导与积分运算，但是几乎没有系统地学习过这些知识。矩阵可以构成环，因此也有很多运算性质和推广。最近大佬发给我一本《Matrix Cookbook》，非常系统地列举了进阶矩阵运算的法则，这里贴在博客上以供参考～\n目录 基础内容 求导 逆 复矩阵 求解与分解 统计与概率 多元概率分布 高斯 特殊矩阵 函数与运算符 来源 这本书可以Technical University of Denmark资料网站下到。如果链接失效了，可以直接从此处下载。\n","date":"2019-06-06T00:00:00Z","permalink":"https://zyxin.xyz/blog/2019-06/MatrixAlgebra/","title":"矩阵代数 — Matrix Algebra"},{"content":"由于最近工作一直在使用ROS，因此也一直在用Ubuntu。之前为了稳定性使用的是Ubuntu 16.04 LTS，而这个版本默认的桌面环境是Unity，实在是不好使，它也颇为人诟病。后来尝试了Ubuntu 18.04 LTS安装ROS Melodic，发现ROS也挺稳定的，因此18.04也用了一段时间，但是最后还是觉得不太爽，于是最终还是决定好好体验一下各种Linux选一个自己顺手的。\n这篇博客里不会贴系统的截图，因为这些在网上都可以找到，而且桌面的好看与否很大程度上取决于个人的喜好和配置结果。最好的比较方法还是自己装一个系统尝试一下\n至于如何尝试linux，我在Windows中使用的是Hyper-V。可以非常方便地安装各种镜像，动态分配资源，最方便的是vhdx硬盘格式可以直接mount到宿主机里。Hyper-V使用一些性能较差的Linux桌面环境时会比较卡，这个时候可以开启RemoteFX GPU（参考官方说明）。注意在Win10 1809之后，Hyper-V管理器界面不提供RemoteFX的开关了，需要用Powershell命令手动开启。\nLinux Distro 所谓的Linux发行版，对应的是一个专有的英文单词distro。个人理解，Linux Distro就是一套Linux Kernel加上外围一些必要的软件包。之前我一直不理解发行版的意思，直到学会了Python使用上Anaconda之后，才知道发行版指的就是核心程序+预装的全家桶，这个全家桶通常包含包管理器（Package manager，简称PM。如Ubuntu的apt、Anaconda的conda）、内置软件（如Linux桌面环境、Anaconda预装的Scipy）以及一套系统逻辑。\nLinux发行版中很重要的一点便是系统的PM，这个管理器还决定了系统的更新逻辑。而不同发行版之间最大的区别，在我看来就是PM（以及软件仓库repository），因此PM的特性与相性最终会决定我是否选择这套发行版。\n常见的桌面Linux发行版有如下这些，我可以大概描述一下他们的特点（以PM为线索）：\napt: Debian、Ubuntu系 依赖树严格，能保证软件之间正确的依赖关系 Debian和Ubuntu的软件库数量庞大，但是确实由于保守的包更新政策，它们的包比较老 apt的命令行使用非常直观 在国内，默认的仓库源下载很慢，但是国内有很多开源镜像可以使用 pacman: Arch 滚动更新是Arch最大的特点 pacman没有严格的依赖树，而是类似于快照的概念，更新软件时整个软件池都会进行变动（个人理解） pacman命令行参数是字母表，不便于记忆 Arch的官方软件仓库中软件较少，但是Arch有庞大的AUR体系，因此能够尝试到很多小软件和新版本，不过也要承担小白鼠的风险 yum/dnf: Fedora、CentOS、Redhat等 使用方法和apt相似 软件仓库中的数量没有Debian和Arch多 包管理方便，中规中据，而且下载速度不慢 zypper: OpenSUSE 由于OpenSUSE是真的比较小众，因此我也没有去尝试，就不妄自评论了 emerge: Gentoo 同上，没尝试过 严格来说，上面的这些都是包分发器，而安装软件的是包安装器（dpkg,rpm等），不过前者才是我们最经常打交道的。关于这些PM以及其软件管理哲学的分析，可以参见这个知乎问题。而关于这些包管理器的一篇介绍可以参见这篇博文。 Arch Linux的wiki上也有一篇关于发行版之间的对比，这里我要吹一下Arch的wiki真的良心，还有中文版！ DistroWatch是一个收集了大量Linux distro的网站，可以在上面看一下流行度排名和一些评测 Linux各发行版的演化历史可以参见Wiki的历史图或者DistroWatch的图表\n桌面环境 桌面环境是最终选择哪一个发行版的决定者。选择Ubuntu、Arch等只能给你决定好大方向，而最后在众多系统中作出选择的标准之一便是桌面环境。常见的桌面环境有Gnome、KDE Plasma、XFCE、LXQt等。现在众多的发行版的主要区别其实也就是PM和桌面环境的区别：\nUbuntu 16.04: Ubuntu + Unity Ubuntu 18.04: Ubuntu + Gnome KUbuntu: Ubuntu + KDE XUbuntu: Ubuntu + XFCE MX Linux: Debian + XFCE Linux Mint: Ubuntu + Cinammon/Gnome Manjaro: Arch + KDE Deepin: Debian + Deepin \u0026hellip; 而这些桌面环境的特点，个人感觉如下：\nGnome(w/ gdm): 基于GTK开发，默认界面比较好看，但是灵活程度不够。虽然有Gnome Tweak，但是插件很少 KDE Plasma(w/ sddm): 基于QT开发，非常灵活，而且Plasma5默认就非常好看！占用资源也比Gnome小。 Unity(w/ lightdm): 别说了，换吧 Xfce: 听人说很不错，但是我认为比较丑 LXQt(w/ sddm): 适合低配环境，也不太好看 个人选择 Arch?: 在我了解Linux distro的过程中，在各种论坛、知乎问题上都有人安利Arch linux。Arch虽好，而且可以体验更新的快感，但是我本身没有太多的时间去折腾系统，或者追寻潮流，因此还是更倾向于Debian体系。同时由于我有使用ROS的需求，因此Ubuntu还是我的第一选择。\n商业主导 or 社区主导: 有人说Ubuntu由于是Canonical家的产品，会有商业倾向，服从公司利益。这个情况确实存在，但是就体验上来说和Arch、Fedora等等社区主导的系统并没有太多区别，因此这个并不会是决定我选择的因素。\nGnome or KDE: 相比于GTK，我更喜欢Qt这套框架。另外KDE也有别人上传的很多插件和桌面（在KDE store上)，非常棒，因此我最后选择的是KDE～\n综上所述，我最后决定使用KDE Neon作为平常使用的发行版，双系统安装Ubuntu 18.04作为开发系统。之后会写一篇博客来介绍KDE的折腾记录～\n","date":"2019-04-26T15:22:02Z","permalink":"https://zyxin.xyz/blog/2019-04/LinuxDistroSelection/","title":"转投Linux发行版"},{"content":"年后给实验室装了一台小服务器，安装了Ubuntu系统，这篇博客记录一下给Ubuntu配置远程访问的设置过程。\n虽然服务器是一台GPU服务器，但是出于简便考虑没有在服务器上安装虚拟化环境，有需要安装LXD或者Docker的朋友可以参考这几篇博客：实验室GPU服务器共享方案、搭建多人共用的GPU服务器、为实验室建立公用GPU服务器、搭建实验室公共GPU服务器\nSSH设置 远程连接最方便并且最稳定的就是SSH了，安装好SSH之后就基本可以远程操作服务器。SSH的安装非常简单，Ubuntu下通过apt安装即可：\n1 sudo apt install openssh-server 安装完重启后，SSH服务就会自动运行了。客户端方面，Ubuntu默认提供SSH支持，而Windows在1809之后也内置了OpenSSH，在系统附加功能中打开开关后，通过cmd即可调用。如果系统版本较老则可以使用XShell。\nSFTP设置 - 利用rclone 上面安装命令会顺带安装上SFTP客户端。SFTP可以看作加密的FTP协议，可以用来远程访问服务器的文件。SFTP现在已经受到广泛的支持，例如Android上的Solid Explorer就内置了SFTP访问功能。\n这里介绍一个可以把远程文件挂载到本地的软件——rclone。安装rclone可以从官网下载二进制文件直接拷贝安装，或者下载打包好的deb文件，也可以使用snap进行安装。安装完成之后使用rclone config添加SFTP服务器，然后就可以rclone mount进行挂载。此外还可以使用RcloneBrowser等GUI进行更加直接的操作。\nTip: 如果你是在Ubuntu上安装RcloneBrowser的话，可以通过修改/usr/share/applications/rclone-browser.desktop文件来修改图标。（原来的图标实在太丑了）\n远程桌面设置 远程桌面的设置就比较麻烦了，这里的远程桌面服务选择xrdp，关于xrdp，vnc等等服务的比较网上都有。由于最开始安装的是Gnome Ubuntu16.04，因此遇到了很多坑，最后配完远程桌面时显卡驱动崩了，因此最后换到了Ubuntu18.04。因此如果需要远程桌面的朋友可以考虑升级到Ubuntu18.04。\n为了使用上Gnome桌面，最初参考的是一篇在Ubuntu16.04上配置xrdp访问Unity桌面的博客，最后安装完确实是可以完成访问的，并且如果碰到远程登陆之后提示需要新建color profile的话可以通过这个博客解决。但最后由于安装完xserver-xorg后显卡驱动崩了，换用了18.04。\n在18.04下安装xrdp就简单多了，xrdp版本较新，也不需要安装tigervnc。具体教程还是参考了这篇博客，大概步骤就是\n安装xrdp和xserver-xorg。需要先安装的xserver-xorg的原因参见这篇博客。 1 2 apt install xserver-xorg-core xsrever-xorg-input-all apt install xrdp 如果你安装了Nvidia驱动的话NV还提供定制版的nvidia-xserver-xorg，也可以通过apt直接安装。安装NV驱动和安装xrdp最好连续进行，避免安装完其他东西之后回头来发现要重装（亲身教训= =）\n添加echo [session] \u0026gt; ~/.xsession到/etc/xrdp/startwm.sh文件里。这里的[session]内容需要从/usr/share/xsessions里的桌面环境文件中拷贝出来，例如如果想远程桌面环境运行Gnome3，那么就把[session]替换成gnome-session --session=gnome（这行命令就是从/usr/share/xsessions/gnome.desktop文件中提取出来的） 修复一些小问题。例如上文提到的color profile问题可以通过这篇很详细的博客提到的方法进行解决。 然后在使用xrdp的时候你可能会碰到一些问题，这里记录一些常见问题的解决方法\n远程用户在home路径下会挂在一个叫thinclient_drives的文件夹: 在/etc/xrdp/sesman.ini中的Chansrv部分里将FuseMountName改为别的名字（例如.thinclient_drives）。这个文件夹的作用是实现远程文件拷贝的功能。 X11 Forwarding X11转发是Linux的一种实现远程图形界面的方法，它基于X11窗口协议，类似于Windows对远程GDI的实现。设置好X11以后便可以在ssh中运行远程带有图形界面的程序了～它相比xrdp更好配置，但是使用范围没有xrdp广，因为它只支持程序级别的图形界面，而不是桌面级别的。其设置方法也很简单，在服务器端的/etc/ssh/sshd_config中将X11Forwarding选项设为yes即可。在客户端则取决于平台，在Linux平台由于系统界面就是基于X11的（Wayland除外），因此直接使用ssh -X命令连接服务器就能支持X11转发，而在Windows上则需要额外安装X11服务器，著名的有Vcxsrv, X410等。这里推荐使用MobaXTerm，这个SSH客户端自带X11服务器，开箱可用，并且性能不错！\n静态IP 如果想要稳定地连接服务器，还需要给服务器配置静态IP。由于我是在大学校园内，静态IP需要申请。我们的网管要求关闭SSH的远程root登陆，以及关闭不必要的服务，此外还推荐服务器用户使用rsakey登陆SSH。这些要求有利于保护服务器安全，因此也推荐在有需要的情况下完成这些操作。\n以上就是给Ubuntu服务器配置远程桌面的主要步骤，步骤不多但是比较花时间。文中提到的几个博客的网站有提供不少的Linux设置教程，可以供读者参考。\n其他参考阅读：\n含Nvidia驱动的远程环境配置 一些xrdp原理的解释 ","date":"2019-04-02T20:47:07Z","permalink":"https://zyxin.xyz/blog/2019-04/LinuxRemoteSetup/","title":"给Linux（Ubuntu 16.04/18.04）配置远程访问环境"},{"content":"搭了一台主机之后由于随身带的Surface性能不够，自然产生了远程桌面的需求。这也是便携办公的一种不错的解决方法：随身带着一个上网本，需要办公时远程连接到主机即可~Windows平台的远程桌面软件除了Windows自带的以外还有Chrome远程桌面、TeamViewer等软件。不过Windows远程体验最好的还是系统内置的客户端~本文介绍一下Windows自带远程桌面的配置与使用。\n远程桌面的使用 先介绍一下远程桌面的使用，现在假设你已经有一台设置好的远程主机。Windows很早开始就有系统内置的远程桌面客户端，在开始菜单中搜索“Remote Desktop Connection”或者“远程桌面连接”即可。在弹出的窗口中，“计算机”一栏填写远程主机的IP地址或者域名。如果出现连接不上的情况可以先Ping一下远程主机检查网络问题。\nWindows远程桌面不仅支持Windows平台，还支持其他主流平台（MacOS）以及移动平台（iOS、Android）等等，在相应的引用商店搜索“Microsoft Remote Desktop”引用即可，连接方式也很简单，输入地址或域名，在必要的情况下输入用户名密码即可。连接上远程桌面后，系统分辨率和DPI会自动调整，你还可以在设置中将声卡、USB等设备投射到远程桌面上。\n远程桌面服务的搭设 远程桌面的使用非常简单，但是服务器的搭建就没那么容易了。基本原理是主机需要向客户端开放远程桌面协议（Remote Desktop Protocal）所需的3389接口，并且在本地开启远程桌面服务，然后通过RDP进行连接。因此设置主要有两个步骤：\n打开服务：在Windows10中只需在设置-\u0026gt;系统-\u0026gt;远程桌面选项卡中开启远程连接的开关即可，而在早期Windows中可能需要通过本地策略管理器开启远程连接的服务。 端口设置：在打开服务之后主机的3389端口就已经开放，但是要使得客户端能连接到主机还需要完成路由设置。如果你的主机是在IPv4局域网中，而你想通过外网远程连接这个主机，你需要在局域网网关上设置端口转发（NAT Forwarding），将外部的3389端口映射到主机的3389端口。为了方便端口转发，你可能还需要给主机设置静态局域网IP，以避免重新设置转发的必要~ 在完成以上两步后就可以尝试通过客户端连接主机了~ 多用户远程桌面 Windows个人版本系统默认只支持单一用户与单一会话，意思是用户A与用户B不能同时远程连接这个主机。多用户的支持名义上只有Windows Server才提供，但其实Windows内核是支持多用户的，只是被锁住了，因此就有相应的破解方法啦~\nGithub上的开源工具RDPWrap可以激活RDP的多用户多会话支持，使用也非常简单，下载Release压缩包之后运行install.bat即可安装，其他文件的使用方法也有在Readme中有描述~\n以上便是Windows远程桌面的设置方法了~有两点小提醒：\n3389端口曾经是远程攻击的重要缺口之一，虽然目前Windows的防御做的已经很好了，但如果不适用远程服务的时候还是把3389端口关闭比较保险。 RDPWarp本身是不被微软承认的，虽然貌似它本身没有违反Windows的使用条例，但仍建议不要在商用服务器上使用。 参考资料： 微软官方说明 ","date":"2019-01-28T00:00:00Z","permalink":"https://zyxin.xyz/blog/2019-01/WindowsRemoteDesktop/","title":"Windows远程桌面设置"},{"content":"由于最近的几个项目都有接触到Cython的使用，也积累了一些Cython的经验，于是决定把续上（蜜汁发现刚好过了一年。。），将Cython的一些用法记录下来。这一些文章可以作为一些学习的参考，不过kick-start的话还是去看看之前的博文以及官方的例子吧~\nCython对C/C++内置类型的支持 Cython在类型设置上和C/C++是十分相似的，不仅默认支持基本C类型int、float、unsigned long等等以及他们的指针类型，还支持C的struct、union、enum以及C++的cppclass（即C++中的类）。需要注意的是在Cython中，定义C/C++对象都需要使用cdef关键字，或者使用cpdef关键字定义一个Python封装过的对象。另外Cython还通过ctypedef支持C/C++形式的typedef。下面是一些定义变量的例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 cdef int i, j, k # i,j,k是C中的int类型 cdef float f, g[42], *h cdef struct Grail: # C形式的结构体 int age float volume cdef Grail *gp # 结构体指针，注意不是cdef struct Grail cdef enum CheeseState: # C++形式的枚举类 hard = 1 soft = 2 runny = 3 cdef enum: # C形式的匿名枚举 tons_of_spam = 3 size_t和Py_ssize_t也是受Cython语言支持的类型。如果想使用uint32_t形式的类型，则需要添加from libc.stdint cimport uint32_t形式的语句。 这些变量的作用域定义与Python是相同的，但是cdef定义的对象是不能import到Python代码中的，而cpdef定义的对象则可以。 Cython对Python内置类型的支持 尽管Cython兼容Python的语法，但是我们还可以通过cdef来使得Python对象具有静态类型，以提高运行效率。Cython在除了支持Python内置的list、dict、tuple外，还支持直接声明Python的基本类型，这需要通过from cpython cimport int形式的语句来实现。此外有一类特殊的类型是ctuple，能够直接定义tuple中元素的类型与数量，有些类似于C# 7中的语法，例子如下：\n1 2 3 4 5 6 7 cdef dict sd # 直接定义内置类型，实际是PyDict对象 from cpython cimport int as pyint cdef pyint big_a # PyInt对象 from libcpp cimport bool cdef (int, unsigned long, bool) table # ctuple对象 Cython的类型映射 在将Python的基本类型对象与C/C++的基本类型对象进行相互赋值的过程中，Cython会进行自动的类型转换，可识别的转换规则有：\nC types From Python types To Python types [unsigned] char, [unsigned] short, int, long int, long int unsigned int, unsigned long, [unsigned] long long int, long long float, double, long double int, long, float float char*1 str/bytes str/bytes C array2 iterable list struct union dict 如果自动类型转换不被支持、或者自动转换类型不是所需类型的话，还可以使用强制类型转换，语法是在变量前加\u0026lt;type-name\u0026gt;，例如\n1 2 3 4 5 6 7 8 9 from cpython.ref cimport PyObject cdef extern from *: ctypedef Py_ssize_t Py_intptr_t python_string = \u0026#34;foo\u0026#34; cdef void* ptr = \u0026lt;void*\u0026gt;python_string cdef Py_intptr_t adress_in_c = \u0026lt;Py_intptr_t\u0026gt;ptr 如果使用\u0026lt;type-name?\u0026gt;形式则会在转换时执行运行时检查\nCython中的模板 Cython还支持C++中的模板，语法是class_name[template_args]，不过模板参数目前只支持类型参数，因此更像是C#中的泛型。对模板的支持不仅是可以声明模板类，还可以支持绑定已有C++的模板类，这也是Cython区别于Boost.Python、Pybind11等C++端绑定库的重要一点。由于后者在编译期无法了解Python代码的使用需求，因此只能在编译器展开模板（Instantiation），而Cython则可以通过.pxd头文件保留模板的格式，在引用该库需要编译时再展开。\n模板的应用例子如下：\n1 2 3 4 5 6 7 from libcpp.vector cimport vector cdef vector[int] vect cdef int i, x for i in range(10): vect.push_back(i) 参考内容： Cython文档 Cython文档 - Language Basics\nPython2中转换成str，Python3中转换成bytes\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nchar数组除外\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2018-12-05T00:00:00Z","permalink":"https://zyxin.xyz/blog/2018-12/CythonTypes/","title":"Cython中的类型系统"},{"content":"自从小时候我爸往家里买了一台式机，我就一直梦想着哪天自己能按照自己的喜好组一个狂拽炫酷掉渣天的PC，这次这个梦想终于实现了一半（毕竟还是budget）。激动地赶紧写下这篇博客记录一下整个组装的过程，组装好的桌面效果就如下图啦~\n选件 选件三十天，装机一小时。其实装电脑搭系统本身很简单，但是之前挑选零件却是最耗时的。在考虑到性能、预算、兼容性、扩展性和外观等因素选择各种零件是个十分耗时的过程。在这里推荐PCPartPicker网站，可以通过筛选来选择各部件，而且还可以进行价格追踪，最关键的一点是可以帮你进行兼容性检查，这就省了很多事以及避免犯错导致的损失。另外，选择部件不要过于听信贴吧论坛上的言论，例如水冷就不一定是好于风冷，关于这些选择可以先看看知乎这篇帖子。\n关于装机部件的兼容性主要要考虑一下几点\n主板芯片是否与CPU兼容 各部件的电源接口是否与供电的接口兼容 主板是否为各部件提供了足够的插槽和槽位间隙 各部件在安装之后是否会产生物理干涉或者走线困难 主板的扩展接口是否与机箱以及各部件的扩展接口兼容（如机箱IO接头、水冷泵、LED接口等） 机箱大小是否与主板兼容，机箱厚度是否满足CPU散热和GPU板卡的空间需要 各部件尽量选择同一厂家，以减少驱动安装的难度 CPU 桌面CPU目前主流选择是Intel、AMD二选一。用了这么多年的英特尔了，终于有机会用上我大农企的CPU了！在Ryzen系列处理器发布以后，农企终于要翻身了，AMD Yes！于是CPU就在性价比远超蓝厂的2代Ryzen里面选了。综合考虑性能和价格后选择的是AMD Ryzen 2700，相比一直纠结的2600X，8核终归是有用的而且还带信仰灯哈哈哈。虽然有想过买AMD的APU系列，这样还能通过黑科技让N卡用上FreeSync然后省下一大笔显示器的钱，但是由于目前出的APU性能都比较差，最后还是放弃了。\nCPU性能的比较可以参考某驱动之家的CPU天梯榜和超能网的CPU天梯榜\nGPU GPU的选择与CPU相似，NVIDIA、AMD二选一（不得不说农企还是厉害的）。由于CUDA目前没有一个真正可用的AMD替代品，因此只能选择英伟达的显卡了。老黄新推出的RTX系列显卡性能比10系列提升不大，RTX技术又属于战未来系列，只有新的Turing架构里的TensorCore吸引我。RTX2080和GTX1080的定位超出了预算，而同定位的RTX2070与GTX1070(Ti)相比，前者贵出了100刀，但明显的提升其实只有显存从GDDR5变成GDDR6了，实在是不划算。因此最后选择的是1070Ti，有8G显存的N卡中最便宜的一款。最后剁手的是打折购买的Gigabyte GeForce GTX 1070 Ti Gaming 8G。\nGPU性能的比较可以参考某驱动之家的GPU天梯榜和超能网的GPU天梯榜\nCPU/GPU散热 选择高性能的CPU时还要考虑CPU的散热，由于2700采用钎焊导热，加上平常使用不打算超频，附带的散热器应该还是能压住CPU的。不过为了以后超频的需求，还是看了一下CPU风扇，性能比较好的就是塔式散热器和水冷散热了。塔式散热器体积比较大，而且不是很美观，有条件的还是考虑上一体式水冷吧，或者有条件还有经验的可以上分体式水冷，但是这就要注意水冷液的选择以及漏液问题了。此外风扇的选择都还要考虑一个要素，就是噪声大小，这方面水冷就非常优势了。\n对于GPU散热，一般来说使用自带的风扇就足够了，因为游戏显卡的风扇一般都比较多，只要不选择公版的方案一般都比较给力。如果在CPU散热上选择分体式水冷的话就可以考虑把GPU加进水冷循环了~不过这个方案实在太麻烦，因此就不额外处理GPU的散热了。\n主板 选好CPU后就可以选择主板了，主板的选择就非常多了，有很多参数可以调整。\nCPU兼容：由于选择了A家的CPU，那么主板的主控芯片自然也选择A家的了，考虑到CPU是2代Ryzen而且性能不差，因此决定用AMD的新款性能级别主板芯片B450来配Ryzen。（根据AMD官网，A320是Mainstream，B450是Performance，X470是Enthusiast）。 关于AMD主板的选择，TomsHardware上有大佬贴出了一个总结表格，非常实用，在选择时可以参考\nIO配置：由于这台主机应该会用很久，因此还是要考虑扩展性，IO口的数量就不能少了。 内部接口—DIMM：内存条插槽，有2个或者4个即可，没有必要上8个 内部接口—PCIe x16：可以插显卡，一条即可，两条可以给之后双卡做扩展 这里考虑的双卡是做深度学习用，SLI/Crossfire的性价比非常低。\n内部接口—PCIe x1：插网卡、声卡或者IO卡，至少要一个。 内部接口—SATA3：由于需要把以前积攒的资源都存到本地，因此硬盘接口也不能少，4个以上比较合适 内部接口—M.2：最近的高性能固态都采用NVMe了，因此另外还需要M.2接口来插NVMe固态。 外部接口—VGA/HDMI/DVI/DP：由于不用集显，因此可以不需要显示器接口 外部接口—RJ45：通用的网线接口，这个是必须的 外部接口—TRRS：音频接口，至少支持耳机和话筒。由于之后肯定是要外接音频设备的，因此这个就无所谓了，不过最好有个SPDI/F的数字输出口。 外部接口—USB：这个是最主要的需求了，数量越多越好，标准越新越好，最好能支持最新的USB3.1 Gen2（其实最新的是USB3.2，但是太新了以至于目前还没有真正投产）。另外，在接口形式上，常用的Type-A肯定是需要的，以后可能会需要的Type-C也可以有。 外部接口—Legacy：不少主板上面还带着PS/2、COM等给老设备的接口，这个已经完全可以淘汰了，没有需求。 尺寸：在给定足够的IO需求以后，尺寸就小不了了，主板型号从EATX、ATX、mATX到ITX等，满足这么多接口需求的话至少也是ATX主板了。由于打算把主机放在桌子底下，查了一下ATX机箱的高度没有问题，因此就选择ATX了。 音频配置：主板一般会内置音频解码芯片，并且主流主板基本都采用的是Realtek的ALC887、ALC892、ALC1220这三款芯片。这个尽量能选择最强的ALC1220，输出能力强而且支持ASIO。 无线连接配置：近年的主板还有不少型号会带WiFi和蓝牙模块，这个其实对我非常有用，因为由于是租房住，网线很难牵，有WiFi支持的话就再好不过了，而且内置蓝牙还可以支持蓝牙键鼠和手柄，岂不美哉。 品牌：最后就是选择主板的品牌了，大厂在主板的做工、用料、稳定性以及BIOS功能设计上普遍比较好，因此可以优先选择华硕、技嘉和微星三大厂的板子。根据网上的评价，华硕的高端板子质量高，BIOS功能多，而技嘉的板子则比较实惠。另外的厂家还有华擎，它的板子设计美观，而且成本较低，也可以考虑。 在筛选掉不符合上面要求的主板后，最后买到的是Gigabyte B450 Aorus Pro WiFi主板，刚好在Newegg上有打折，而且完美满足需求，而且还带雕牌信仰灯。\n内存 内存的话就比较好选了，主要有三个参数：容量、频率和时序\n容量：之前俺12G内存笔记本编译个LLVM都内存不够，因此至少要16G了，以后看需要甚至可以考虑上32G。 频率：频率决定了内存的性能，由于暂不打算内存超频，选择AMD支持的2666/3000MHz DDR4就刚好合适了。 时序：时序决定了内存的延迟，这个参数实际体验上影响不大，而且同款内存的C1时序一般都差不多，所以可以忽略。 最后选择的是RGB加持的Corsair Vengeance RGB 16GB (2 x 8GB) DDR4-3000双通道内存，应该是可以完美配合之前选的主板的。\n硬盘 硬盘也是非常影响体验的一个部件，速度快的硬盘能加速开机、加速程序加载、加载文件拷贝，而对与资料存储来说则是选择一款稳定的硬盘比较关键。对于系统盘，我购买了一块西数NVMe黑盘来装系统，考虑到可能会装一些大型软件在系统盘，最后选择的容量是500G，给出一定量的冗余空间有利于延长固态硬盘寿命。由于之前刚好淘了一块Corsair的480G固态以及一块2T西数绿盘，刚好可以分别用作游戏存放盘和资料存放盘，就暂时没有额外购买硬盘了。之后根据资料存储的需要可能还会采购一块4T硬盘，在配上一块便宜的固态来用上AMD的StoreMI技术！\n需要指出的是，对于存储资料的硬盘，选择转速低、缓存小的机械硬盘比较好，这样比较稳定。\n声卡网卡等其他设备 在声卡和网卡上，由于主板已经满足了基本需求，因此之前考虑过的Creative SoundBlaster声卡和其他带WiFi的网卡就可以不用再买了，也省了两个PCIe的槽位。而光驱的话，由于后文提到购买的机箱没有5.25英尺舱位，决定之后购买USB光驱。\n电源 电源的考虑因素主要有三点：\n功率：选好所有内部组件之后就可以给整个系统算一个总TDP功率，然后让总功率处于电源的高效率负载区间就可以了。如果考虑到之后扩展的需求（如超频、加显卡）可以买更大功率的电源。根据PCPartPicker的计算，按照上面的配置装下来系统功率大概是294W，用它除以一般电源的高负载区间（50%~75%）再补一些裕量，这套配置下电源的功率大概是500W左右。 接口：电源由于要给主板、GPU、硬盘等设备进行供电，供电接口必须兼容，不过目前较新的电源都与主流设备兼容。电源的选择还有“模组”(Modular)、“半模组”(Semi-Modular)、“非模组”之分。模组的意思是电源接口上全是母口，可以自己选择是否插线以及插什么线，而半模组则是电源自带几根必要的供电线，其他由用户选择。我最后选择的是半模组电源，供电灵活并且便于走线。 效率：电源的效率就关乎省不省电了，可以根据80+标准来进行选择。 最后我选择的是Corsair TXM Gold 550W 80+ Gold电源，够用、省电。\n机箱 在选好电子部件之后选择机箱就比较简单了，首先限定ATX尺寸，至少3个硬盘位，然后根据外观喜好和接口数量选择即可。仔细一点的话可以考虑机箱对走线的支持、机箱的5.25英尺舱位数量（用来放光驱等设备）、机箱风扇位数量、机箱对水冷冷排的支持以及机箱风道设计等因素。由于带5.25英尺舱位的机箱普遍较丑，因此就没有买带光驱舱位的机箱。最后选择的是外观与内部设计兼具的NZXT H500机箱。\n机箱风扇 由于目前没有高强度的散热需求，因此暂时就不购置机箱风扇了。\n整套设备的零件列表可以参见我在PCPartPicker上的列表~\n组装 部件到手后就是引起极大舒适的组装环节啦~\n硬件组装 硬件组装其实没有什么好说的，按部就班地将部件连接、固定，然后只要能开机就万事大吉了~安装之前注意将手上的静电放一放。（我在Amazon买了个防静电腕带，结果发现很难找地方接地，也没有必要）\n我的安装顺序如下：\nCPU：注意CPU上的方向标志要与主板对齐 CPU风扇：在CPU上涂上导热硅脂后就可以把风扇固定上去了 内存：双通道内存要注意插的槽位，不确定的话看一下说明书 主板：把CPU和内存安装好之后再固定主板会比较省事。由于机箱上的风扇会比较碍事，可以先把机箱风扇拆下来。 GPU：把侧面对应的挡板要卸下来 硬盘和SSD: 稍微留意一下安装的位置和方向，避免SATA线或者电源线不好插。另外根据Newegg上的评论，这款主板如果在M.2接口SSD上装系统，应安装在M2A插槽的SSD上。 电源：其实这里犯了个错，先将电源线插上之后再安电源会比较好操作。 电源线：要给CPU、主板、GPU、硬盘都供上电。 机箱风扇：这里要考虑一下机箱的风道设计 安装完毕之后整理一下走线，和没有插上的接头，把拆下来的机箱部件再装回去就OK了~安装完毕后发现按电源键开不了机，后面经过老司机老王指路后换通道插了一下内存就可以了，成功开机之后再把内存插回最快的通道。\n软件安装 一台全新的主机是不带系统的，因此要先装系统啦~如果是安装Windows，那么在装之前先通过安装盘的Diskpart工具将硬盘分区表转换成GPT格式以支持大容量硬盘，并且在BIOS中开启UEFI启动模式。关于UEFI与GPT好处可以参见这篇博文。不过如果以后想安装Linux双系统的话，[使用UEFI就会有一些蛋疼了](https://zyxin.xyz/blog/2018-09/LinuxDualSystem/。之后从安装盘Boot，安装系统，初始化账号以及更新驱动，一切按部就班即可~\n关于Windows 10的激活：首先，有能力的话还是买正版或者教育版。推荐使用KMS服务激活，如果有学校或者企业的服务器最好，如果没法买正版的话可以使用其他的KMS服务器（如03k）\n更新完驱动以后回到BIOS调一下其他参数，例如内存的频率默认是设置在2133MHz的，调成我内存支持的3000MHz，还有Wake on LAN、Secure Boost等等设置都可以根据需求喜好调整。超频先不打算弄了，一方面电脑还没测试过，另一方面超频也耗电，目前没有什么需求。\n测试 装完系统之后就是对自己的电脑进行测试啦~看有没有达到自己预期的性能。\n烤机 首先是稳定性测试，如果系统都不稳定那一切性能都是白瞎。烤机过程中一方面是观察是否出现卡死或者蓝屏，另一方面是观察硬件温度有没有超出预期。如果硬件温度太高则说明散热的设置有问题。\nCPU烤机测试可以通过AIDA64软件进行，烤机结果如下：\n而GPU烤机测试可以通过Furmark软件完成，这个软件就仅仅是不停地渲染，只要没有出现卡死就没问题了。\n跑分软件 在完成基本的测试之后还可以进行其他性能的测试，如硬盘测试、网速测试等等。这里介绍一下常用的Benchmark软件，\nCPU: CPUz, AIDA64, Cinebench GPU: GPUz, Furmark, 3D Mark 硬盘: AS SSD Benchmark, CrystalDiskMark 其中3D Mark是一个比较常用的跑分软件，测试内容比较综合，可以较为全面地反应电脑性能。下图是我这套配置的跑分结果~\n这里再贴几张硬盘跑分图，感受一下NVMe的速度~等以后有空余的硬盘，用上AMD StoreMI黑科技以后还能更快！~ （从左到右分别是西数NVMe黑盘、海盗船SATA固态、西数5400转绿盘机械硬盘）\n以上就是装机的全过程啦~硬件的评价可以参见上文提到的我的帖子~最后附上一张剁手全家福~\n后记：没忍到黑五就把电脑搭上了，估计之后看到打折都要气死了。另外，对于AMD Ryzen主机的安装可以参考PCWorld上的一篇文章。\n","date":"2018-11-09T23:10:47Z","permalink":"https://zyxin.xyz/blog/2018-11/BrandNewRig/","title":"My First Rig （Ryzen 2700 + GTX 1070 Ti）"},{"content":"在学校提供免费的Google Drive之后，我安装了Google Drive客户端的File Stream版本。Google Drive有两种客户端，一种是Backup and Sync（自动同步的文件夹），另一种是File Stream（虚拟硬盘）。前者与Onedrive的使用体验非常相似，安装之后在文件浏览器左侧直接会有同步文件夹的入口。而后者则是以虚拟硬盘的形式提供Google Drive的文件访问，让我想起了之前的meepo，可惜现在清华已经不提供meepo服务了。File Stream会在文件管理器中添加新的盘符，用来访问文件，但是却没有像Backup and Sync或者Dropbox那样把快捷入口添加到文件浏览器左侧。本文将分享一个将Google Drive添加到文件管理器根空间的方法，效果图如下～\nReg文件导入注册表键值 这个方法来源于一篇博客，只需要将一个注册表文件Google Drive.reg导进注册表即可。不过这个文件是针对Google Drive Sync而不是Google Drive File Stream的，因此需要将里面的exe位置改到你的Drive FS安装的位置，并且还要修改它导向的文件夹路径（默认是G:\\My Drive）。与文件浏览器左侧快捷入口有关的注册表键值是HKCU\\Software\\Classes\\CLSID\\...\\底下的System.IsPinnedToNamespaceTree选项，将这个设置为1即可将COM组件固定在文件浏览器左侧。如果需要将快捷入口去掉，双击运行上文Repo里面的Remove Google Drive.reg删除注册表即可。\nPowershell自动脚本 为了省去Google Drive每次更新后手动更改路径的麻烦，我写了一个Powershell脚本，一键添加和删除快捷入口~在Gist上可以下到。使用十分简单，下载后打开命令行输入powershell.exe -noprofile -executionpolicy bypass -file \u0026lt;下载文件的位置\u0026gt;即可将Google Drive添加到左侧快捷入口，运行powershell.exe -noprofile -executionpolicy bypass -file \u0026lt;下载文件的位置\u0026gt; remove即可将快捷入口删除。\n提示：如果下载下来的脚本运行失败的话可能是文件编码问题导致的，请用VSCode等软件转换为UTF8(BOM)格式\n","date":"2018-11-02T20:10:49Z","image":"https://zyxin.xyz/blog/2018-11/AddGDriveToExplorer/thumbnail.png","permalink":"https://zyxin.xyz/blog/2018-11/AddGDriveToExplorer/","title":"将Google Drive (File Stream)添加到文件管理器左侧空间"},{"content":"PowerShell是微软一个非常棒的产品，终于改变了人们对Windows下命令行的一片鄙视。一直以来都很想学学PowerShell，这样我就不用使用Python作为手边的脚本语言了，对进行一些文件操作、系统操作而言PowerShell还是要比Python来的方便。另外由于有不少C#的经验，因此PowerShell能够调用.NET库的特性也能够充分利用起来，并且实际发现C#的经验让我学习PowerShell快了不少（当然使用bash、CMake这些脚本的经验应该也帮上忙了吧）。本文就是一篇针对有C#经验的用户的PowerShell上手教程，当然如果你有F#、IronPython等基于.NET的脚本经验那就更好了。\nNote: 后文中PowerShell简称PS。\nPowerShell脚本的运行方法 PowerShell本质是一个脚本环境/脚本语言。在PS中，语句从第一行开始依次执行，而不像普通程序一样会有一个显式的程序入口（Entry），并且PS的每一行命令（语句）都不用使用结尾标志（如C家族的;）。因此PS脚本的编写将会非常直观，想要输出Hello World只需一行语句即可：\n1 echo \u0026#34;Hello World\u0026#34; 运行一段PS脚本有两种方式，一种是在PS交互命令行中直接将命令输入，例如你可以直接在PS命令行中输入35+2，或者$env:Path.GetType()等复杂语句；另一种则是将脚本写在.ps1文件中，然后运行.ps1文件即可。这与大部分脚本语言运行的方法是一致的。\n需要指出的是Windows下PS脚本运行是受到系统的限制的，默认系统配置下，如果再PowerShell窗口中直接运行.ps1脚本，PS会提示File cannot be loaded because running scripts is disabled on this system.。解决这个问题有两种方式\n将系统中Windows PowerShell执行策略改为“Bypass”，这个可以通过在PS中运行以下命令完成 1 2 Set-ExecutionPolicy Bypass -Scope CurrentUser Set-ExecutionPolicy Bypass -Scope Process # 仅在当前PS进程中生效。 使用powershell -noprofile -executionpolicy bypass -file \u0026lt;文件路径\u0026gt; [参数]来运行脚本，这是用户友好的方法。由于该命令可以通过cmd或者PS执行，因此可以通过.bat文件封装这个命令，以达到双击运行的效果。 命令 or 参数 or 字符串？ PowerShell中变量名均以$开头。与bash、CMake风格相似的是，PS中的内容如果不以$或者-开头则默认都是命令或者字符串，例如在echo Hello World这样的语句中，echo是命令，Hello和World都是命令的参数并且都是字符串类型。在PS中，命令/函数的调用有两种形式：\n命令形式：\u0026lt;命令\u0026gt; [参数1] .. [-参数名2 \u0026lt;参数2\u0026gt;] ..，如Get-ChildItem C:\\Windows\\* -Include *.exe。在这类形式中，参数默认都是字符串，在不含空格时都可以不打引号。这里的命令主要是PS内置的命令（cmdlet）或者别名（alias），通常是一个首字母大写的单词或者用短横连接的两个首字母大写单词。 函数形式: [对象.]函数(参数1, 参数2, ..)，如\u0026quot;abcd\u0026quot;.Endswith(\u0026quot;cd\u0026quot;)。在这类形式中，参数需要通过引号来明确指定是字符串。通过这样的方法使用的是.NET的函数，写起来就和C#没什么区别。 另外，PowerShell支持管道，因此对于命令形式来说可以通过\u0026lt;命令1\u0026gt; | \u0026lt;命令2\u0026gt; | ..的形式来进行链式调用并且传递参数，而函数形式就没法进行链式调用了。\n.NET交互（Interop） PowerShell本身是用C#编写的，并且其内部运行环境也是基于.NET的，因此PS与.NET交互十分简单。\nPowerShell对象 PS中的对象均为.NET中的对象，因此PS变量可以直接当作.NET对象进行操作，例如下列语句：\n1 2 3 4 5 6 7 \u0026gt;\u0026gt; 123.ToString() # 报错，因为123既不是变量也不是命令 \u0026gt;\u0026gt; ([int]123).ToString() # 这里将字符串123转换成了System.Int32变量 123 \u0026gt;\u0026gt; (Dir C:\\).GetType().Name Object[] \u0026gt;\u0026gt; (Get-Item HKCU:\\Software).GetType().FullName Microsoft.Win32.RegistryKey PS不仅能操作对象，还能够直接创建对象\n1 2 3 4 5 6 7 8 9 10 11 12 13 # PS中创建.NET对象 \u0026gt;\u0026gt; New-Object -TypeName System.Version -ArgumentList \u0026#34;1.2.3.4\u0026#34; Major Minor Build Revision ----- ----- ----- -------- 1 2 3 4 # PowerShell中的Object对象操作 \u0026gt;\u0026gt; $var = New-Object object \u0026gt;\u0026gt; $var.GetType().Name System.Object \u0026gt;\u0026gt; Add-Member -InputObject $var -Name Value -Value 123 -MemberType NoteProperty \u0026gt;\u0026gt; $var.Value 123 通过Add-Member和Get-Member命令，PS不仅能够完成.NET中的反射（Reflection），还能够完成类似匿名对象（Anonymous Object）的创建，这个十分有用！\nPowerShell中操作.NET类 在PS中可以直接调用.NET库中的类进行操作\n新建对象：New-Object -TypeName System.Version -ArgumentList \u0026quot;1.2.3.4\u0026quot; 强制转换：[int]\u0026quot;1234\u0026quot;（等同于[System.Int32]\u0026quot;1234\u0026quot;） 调用静态函数： [System.DateTime]::Parse(\u0026quot;2012-10-13 23:42:55\u0026quot;) 有了这些操作，PowerShell已经完全可以当一个C#脚本引擎了~ 操作符 在利用PS写逻辑流程时就会发现，除了加减乘除外，C#的很多关键字和操作符都不能直接使用。在PS中，这些操作符都变成了命令或者以-开头的命令符了。下表列出了常用的操作符：\n类型 PS操作符 C#操作符 比较 -eq == 比较 -ne != 比较 -gt \u0026gt; 比较 -ge \u0026gt;= 比较 -lt \u0026lt; 比较 -le \u0026lt;= 类型 -is is 类型 -as as 逻辑 -and \u0026amp;\u0026amp; 逻辑 -or || 逻辑 -xor ^ 逻辑 -not ! 运算 -band \u0026amp; 运算 -bnot ~ 运算 -bor | 运算 -bxor ^ 运算 -shl \u0026lt;\u0026lt; 运算 -shr \u0026gt;\u0026gt; 运算 -bxor ^ 另外需要注意的是\u0026gt;、\u0026gt;\u0026gt;等等运算符在PS中是重定向运算符。\n尽管名字不一样，但是这些操作符的用法还是一样的。另外PS中还定义了一些.NET中没有的操作符，这些操作符通常很实用，如：\n-contains：返回集合包含元素 -in：返回元素是否被集合包含 -like: 返回字符串是否与通配式匹配（Wildcard Pattern） -match: 返回字符串是否与正则表达式匹配（Regex） -f: 等价于String.Format() PowerShell“驱动” “驱动”（Drive）是PowerShell中很有意思的一个概念，PowerShell提供了一种统一的接口来管理层次信息系统，包括文件系统（FileSystem）、注册表（Registry）、证书（Certificate）、环境变量（Environment），甚至包括当前会话的变量（Variable）和函数（Function）。这些“Drive”支持统一的一套接口，这就非常的有趣了233。\n通过Get-PSDrive命令我们可以获得当前PowerShell会话支持的驱动，在我的电脑上该命令的运行结果如下（省去部分内容）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 Name Provider Root ---- -------- ---- Alias Alias C FileSystem C:\\ Cert Certificate \\ D FileSystem D:\\ E FileSystem E:\\ Env Environment Function Function G FileSystem G:\\ HKCU Registry HKEY_CURRENT_USER HKLM Registry HKEY_LOCAL_MACHINE Variable Variable WSMan WSMan 通过这些驱动，ls env:\\Path就能够获取系统环境变量，HKCU:\\SOFTWARE就可以获取注册表键，十分方便。但是需要注意的是这些驱动获得的对象的类型是不同的，如文件对象会是System.IO.FileInfo，而注册表键则是Microsoft.Win32.RegistryKey。\n驱动统一支持的命令接口 Cmdlet Alias 用途 Get-ChildItem dir, ls 获取当前位置的所有子项 Set-Location cd 更改当前位置 New-Item md, mkdir 在指定位置新建对象 Get-Item 获取该位置对应的对象 Remove-Item del, rm 删除指定位置的对象 New-ItemProperty 新建对象的属性 Get-ItemProperty 获取对象的属性（如文件属性，注册表键） Set-ItemProperty 设置对象的属性 Clear-ItemProperty 删除对象的属性 Test-Path 判断指定位置是否存在对象 看完这些内容以后你就可以像写C#一样开始写PowerShell啦。更加详细的教程可以参见下方的参考资料~\n参考资料\n微软官方文档 PowerShell在线教程 ","date":"2018-11-02T00:00:00Z","permalink":"https://zyxin.xyz/blog/2018-11/PowerShellForCSharpProgrammer/","title":"PowerShell快速上手（针对有C#经验者）"},{"content":"由于没有足够的动力，之前一直没有学LaTeX。苍天饶过谁，这回有一门课强制使用LaTeX交作业，没办法只能装上LaTeX了。如果是在几年前大一大二的时候，我可能还忍不了MiKTeX难用的命令行和WinEdit丑陋的界面，但是现在有了VSCode，一切都变得easy and works like a charm。 本文就讲述如何利用VSCode搭建LaTeX的编辑环境。如果你还没有装VSCode的话就赶紧去官网下载吧~\nMiKTeX + LyX 想要使用LaTeX，首先需要安装一个LaTeX发行版，也就是实现LaTeX功能的软件包。著名的发行版有TeX Live、MiKTeX、CTeX等。我选择的是MiKTeX，原因有\nMiKTeX是老师推荐的发行版 MiKTeX是LyX的默认后端 MiKTeX体积不大而且安装简单 安装有多简单呢：直接从官网下载界面下载对应安装包，双击安装即可。安装过程中的选项可以保持默认。MiKTeX里面有一些包含有Perl脚本，因此建议再给系统装上Perl的运行时。Perl的运行时也有不同的发行版，我选择的是Strawberry Perl。两者都安装完毕后打开命令行，运行latexmk测试MiKTeX是否安装正常。\n另外你还可以选择安装LyX，这是一个让你像使用Word一样编写tex的软件，由于我也还没怎么用过，就不详细介绍了。LyX安装包有两种，一种是包含了MiKTeX的安装包的，建议先单独安装MiKTeX，再使用独立安装包安装LyX，便于MikTeX的调试。\nVisual Studio Code 插件 VSCode原生只支持.tex文件的高亮，如果想要利用VSCode完成TeX的整个编写流程（编写、预览、编译、发布）就需要安装额外的插件。我使用的是目前做多star的LaTeX Workshop。安装上这个插件后，只要你的系统路径中装有MiKTeX，那么就直接使用了~\n常用的操作可以通过左侧的TeX选项卡、左下角的TeX状态按钮或在编辑窗口右键来完成。并且LaTeX Workshop提供的预览功能支持实时更新，在你每次保存.tex文件时它会自动刷新。另外，如果你安装了vscode-pdf插件的话，LaTeX Workshop会提示它已经包含了vscode-pdf的功能重复了，但我感觉如果纯看PDF的话还是用vscode-pdf比较稳定。\n一些LaTeX技巧 虽然我也是LaTeX新手，但是从Word转换过来时还是有不少操作比较不直观，因此在这里提一些我用到的技巧：\n利用.pgf格式的图片可以使得Matplotlib出的图与LaTeX无缝集成 在LaTeX中使用pgf格式图片需要引用pgfplots库：\\usepackage{pgfplots}\n在LaTeX中打单边的括号可以使用\\left$与\\right$，其中\u0026quot;$\u0026ldquo;代表括号，如果只有单边的话另一边的\u0026rdquo;$\u0026ldquo;使用\u0026rdquo;.\u0026ldquo;替代 LaTeX中\\left{ \\right.的效果等价于word中{ \\close\n我的其他博文: 关于Visual Studio Code的其他插件可以参考[VSCode插件推荐](https://zyxin.xyz/blog/2018-02/ToolVisualStudio/，关于Word中公式的输入技巧则可以参见快速输入数学公式。\n","date":"2018-09-18T00:00:00Z","image":"https://zyxin.xyz/blog/2018-09/LatexSetup/workshop_screenshot.png","permalink":"https://zyxin.xyz/blog/2018-09/LatexSetup/","title":"利用Visual Studio Code搭建Latex编辑环境"},{"content":"自己的笔记本已经用了快4年了，硬盘除了不小的问题，存资料不放心、玩游戏不给力，因此准备把这台机子变成一个工作专用的机器。另外由于刚来美帝，实验室没有配电脑，我需要一个Linux系统来干活，因此就琢磨着给自己电脑装个Ubuntu双系统。\nUbuntu双系统的安装 先说一下自己电脑的情况。联想Y430P，系统是从OEM版Win8一路升上来的，去年为了Hyper-V重装了Window 10教育版。也就是说这台电脑从到我手上以来未装过Windows以外的系统，因此装双系统需要有一定的调整。Ubuntu双系统的安装主要参照了另一篇博客。\n给Ubuntu系统腾空间 由于之前系统所有硬盘位置都被分配好了，因此需要先给另一个系统足够的安装空间。重新分配空间在Windows下能够非常方便地通过磁盘管理进行解决。磁盘管理可在任务栏Windows图标右键菜单中打开。腾空间有几种方式：\n插入新的硬盘：如果你舍得花钱或者有闲置盘的话 删除某一磁盘分区：删除分区不代表数据丢失，只是将磁盘一块区域变成未使用的状态 压缩已有磁盘分区：在不想移动数据的情况下的选择 由于我想让Ubuntu和Windows共用之前Windows独占的固态硬盘空间，因此我只能选择压缩分区（Windows装在C盘），并且由于这是Windows系统所在分区，因此还会降低压缩能力。为了最大化压缩出来的空间，首先将系统重启并且关掉所有能关掉的系统进程与服务，其次是关闭掉C盘的硬盘保护。实验证明，关闭掉硬盘保护后能够压缩的空间比关之前多了两倍！硬盘保护的开关在系统面板-\u0026gt;更改设置-\u0026gt;系统保护选项卡中，在压缩完毕分区后可以再把硬盘保护打开。压缩完毕后磁盘中会多出一个“未分配”的区域，这便是之后Ubuntu安装的位置。\n制作启动盘 如果你有现成的启动盘当然就可以跳过这一步了~这个步骤对于经常装机的同学来说肯定是so easy，过程说到底也就是从官网下一个ISO镜像然后刻录进光盘或者U盘。不过这里我倒是想推荐一个制作启动盘的软件——Rufus，制作流程十分直接，选择ISO后直接按照默认设置就能烧好一个启动盘~之前一直用的是UltraISO，但是完全就是大材小用，而且还收费，只能使用试用版，令强迫症相当不爽。\n运行安装程序 插入启动盘后重启进Boot Menu，选择从启动盘启动，然后就按照Linux的安装流程走了~需要解释的是在选择分区的那一步，如果没有什么特殊需要的话其实直接选择\u0026quot;Install Ubuntu alongside with Windows Boot Manage\u0026quot;（默认的第一个选项）就可以了，但如果想自己定义分区大小、挂载点和boot设置的话就选最后一条\u0026quot;Something else\u0026quot;，然后分区的设置可以参考之前提到的博文。\n需要指出的是，我参考这篇文章最后没有能用Windows Boot Manager来启动Ubuntu，还是只能使用Ubuntu附带的丑陋的GRUB，原因是我的Windows是UEFI安装，这个模式下Windows Boot Manager只能启动Windows系统（可以启动不同版本的）而不能启动Linux。具体解释可以参考EasyBCD的官网说明。\n安装完毕以后可以将系统的更新源设置在国内的镜像库（如清华）上，可以使更新快一点。具体方法是进入系统设置-\u0026gt;软件和更新-\u0026gt;下载至之中选择http://mirrors.tuna.tsinghua.edu.cn/ubuntu。\n解决一些系统冲突 在安装完双系统后，如果没有什么意外的话就可以进入Ubuntu啦~但是我在进入后发现有两个问题，一个是时间错位，另一个是另外的系统分区（NTFS格式下的）无法打开。\n时间错位的现象是你在进入Ubuntu后再登录Windows，会发现Windows的时间被更改了，与实际时间错位了几个小时。这是由于Ubuntu与Windows的默认时区表示方式不同，导致Ubuntu会修改主板时间。解决方案可以参考AskUbuntu上的问题，我选择的方法是运行timedatectl set-local-rtc 1。\n装系统之前的NTFS分区无法打开，并且会提示“Windows is hibernated, refused to mount”。其原因是Windows的快速启动阻止Ubuntu的访问，将Windows的快速启动功能关掉即可。详情可参见CSDN贴。\n调整GRUB的设置 我这安装完双系统之后，默认启动的顺序是linux在前，而我想把Windows设为默认启动系统。这里就需要更改GRUB的配置文件，用sudo加vim或者gedit打开/etc/default/grub, 更改里面的GRUB_DEFAULT值为Windows在GRUB界面的顺序即可，保存后用sudo update-grub覆盖已有配置即可完成更改。此外在GRUB设置中还有个GRUB_GFXMODE选项，如果想更改GRUB界面的分辨率的话可以将其更改为需要的分辨率。GRUB支持的分辨率可以在GRUB界面按c进入命令行，输入videoinfo命令查看。\nUbuntu工作环境的配置 安装完系统之后就是一些软件以及环境的配置啦~\n常用程序安装 由于我很少使用Linux，因此在Ubuntu下常用的程序也很少，大概有这些:\nFirefox: 虽然Ubuntu自带，但是还是更新一下版本比较好 Visual Studio Code: 没有Visual Studio，写代码只能用它了 Anaconda: Python环境，系统自带的Python经常会被各种软件弄乱（如ROS），因此还是装个Anaconda。最好不用sudo安装，放在/home底下就可以了。 如果今后在编译Python扩展相关的代码时要用Anaconda的python（如使用Anaconda编译pycaffe），那么在~/.bashrc末尾加一行export LD_LIBRARY_PATH=$\u0026lt;Anaconda根目录\u0026gt;/lib:${LD_LIBRARY_PATH}\ngit: 这就不解释了 GitKraken：一个非常好使的Git GUI CMake: 写跨平台代码时会用到 aria2c: 快一点的下载器 synaptic: 图形化deb包管理 这些程序的安装要么用sudo apt install，要么从官网下载.deb文件双击安装，非常简单~\n此外，还可以安装一个中文输入法，使用ibus的话会比较好看（Gnome中设置输入法参见这里）。如果想安装GooglePinyin或者搜狗拼音的安装包，也可以在系统设置中添加中文语言支持，然后将输入法换成fcitx即可。\nUbuntu美化 如果你忍受不了ubuntu默认的界面风格的话可以对Ubuntu进行美化。具体而言，效果明显的改进就是换主题和图标啦~\n安装Gnome桌面，具体命令代码如下： 1 2 sudo add-apt-repository ppa:gnome3-team/gnome3 sudo apt update \u0026amp;\u0026amp; sudo apt install gnome-shell ubuntu-gnome-desktop 安装时如果提醒选择X Server的话选择gdm3。安装完毕后在用户登陆界面中，用户名的右边按钮选择Gnome桌面登陆。另外，如果是安装的18.04应该是自带Gnome桌面了，安装就会简单不少。\n安装Tweak工具，这个在应用商店中可以找到。安装完毕后在Extension中打开User themes开关。 安装主题和图标，我选择的是Arc-Darker主题和Papirus图标包。前者的安装方式是在作者的OBS Repo中下载.deb文件直接安装，后者则是使用如下代码 1 2 3 sudo add-apt-repository ppa:papirus/papirus sudo apt-get update sudo apt-get install papirus-icon-theme 安装完毕后在Tweak中选择主题和图标包即可\n其他美化方法可以参照知乎中的该回答和该文章。另外如果最开始就打算安装Gnome3的话可以考虑安装Gnome Ubuntu（最高版本是16.04.5）或者更新的Ubuntu（默认就是Gnome）。\nNVIDIA显卡驱动安装 由于后面还是打算拿这个系统跑深度学习的，因此显卡还是要装的~首先是驱动安装。安装驱动有两种方式，一个是使用.run文件，另一种则是使用apt install，后一种比较简单，在安装全新的系统时推荐使用后面一种。\n使用.run文件安装 从官网下载.run驱动，下载以后放到一个好找的目录下。之后打开终端，输入sudo service lightdm stop关闭X Server的显示，然后按Ctrl+Alt+F1进入tty模式。找到驱动文件对应的目录，输入如下命令开始安装驱动\n1 2 sudo chmod +x NVIDIA-Linux-x86_64-XXX.YY.run sudo ./NVIDIA-Linux-x86_64-XXX.YY.run 安装过程中的各种选项按需选择即可。安装完毕后再输入sudo service lightdm start即可重新打开图形界面。\n使用apt进行安装 打开命令行输入下列命令\n1 2 3 sudo add-apt-repository ppa:graphics-drivers sudo apt-get update sudo apt-get install nvidia-XXX 安装完重启即可。安装结束时可能会提醒你关掉主板的Secure Boot，按照提示完成即可。\n安装CUDA CUDA的安装同样有两种方式，一种是使用.run，一种是使用.deb。后者是官方推荐的，而且相比之下deb文件不含驱动，很少有冲突，并且这样对CUDA的卸载和升级更加方便。如果网速比较好的话可以选择Online形式的deb包，这样使用起来就和一般repository差不多了，能自动升级，但是如果连接NVidia的网速不太行的话还是用Offline的deb包更方便。\n用N卡做计算加速的话CUDA是必需的。从官网下载.deb文件，然后在终端运行如下命令\n1 2 3 sudo dpkg -i \u0026lt;CUDA的.deb文件路径\u0026gt; sudo apt-get update sudo apt-get install cuda 安装完成后修改环境变量。在终端输入sudo gedit ~/.bashrc，然后在文件末尾添加如下几行\n1 2 3 4 # CUDA environment export CUDA_HOME=/usr/local/cuda export LD_LIBRARY_PATH=${CUDA_HOME}/lib64:${LD_LIBRARY_PATH} export PATH=${CUDA_HOME}/bin:${PATH} 注意Linux下PATH的分隔符是冒号:而不是分号;\n然后重启终端或者使用sudo ldconfig命令使环境变量生效。验证是否安装成功可以通过编译官方的CUDA Samples完成\n安装CuDNN 这里采用的是.tar压缩包安装方法，官网还提供.deb安装文件，貌似可以CUDA+CuDNN一起安装\nCuDNN是利用N卡给神经网络计算做加速的库，也是必需的。CuDNN的安装仅仅是把几个库文件拷到CUDA目录下就可以了。从官网下载CuDNN库的.tgz文件，解压后打开终端进入到解压后的目录，然后运行如下命令即可\n1 2 3 sudo cp -P cuda/include/cudnn.h /usr/local/cuda/include sudo cp -P cuda/lib64/libcudnn* /usr/local/cuda/lib64 sudo chmod a+r /usr/local/cuda/include/cudnn.h 题一下我这里遇到的问题。我在之后安装完tensorflow后发现Tensorflow仍然找不到CuDNN，排除了目录不正确的可能之后发现是libcudnn.so.6.0.20文件的权限设置不正确。不知道为什么压缩包里解压出来的这个文件的权限是-rwxr-xr-x，与其他的.so文件不同。之后我用chmod命令将权限改成正常的-rw-r--r--后即可正常使用Tensorflow了。\n安装ROS ROS也是我今后工作中会常用到的框架。目前ROS进行LTS支持的版本是Kinetic，并且刚好Kinetic也是支持Ubuntu 16.04的版本，因此我们就安装Kinetic版本的ROS框架。依次执行如下命令：\n1 2 3 4 5 6 7 8 9 10 sudo sh -c \u0026#39;echo \u0026#34;deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main\u0026#34; \u0026gt; /etc/apt/sources.list.d/ros-latest.list\u0026#39; sudo apt-key adv --keyserver hkp://ha.pool.sks-keyservers.net:80 --recv-key 421C365BD9FF1F717815A3895523BAEEB01FA116 sudo apt-get update sudo apt-get install ros-kinetic-desktop-full sudo rosdep init rosdep update sudo apt-get install python-rosinstall pip install trollius catkin-tools rospkg 最后一行是为ros的Python开发提供支持，其中trollius是catkin-tools的依赖项。安装完之后可以在.bashrc文件里添加环境设置，使得ros的命令能默认在终端里执行。在终端输入sudo gedit ~/.bashrc，然后在文件末尾添加如下几行\n1 2 # add ROS environment source /opt/ros/kinetic/setup.bash ROS是否安装成功可以通过运行ROS示例来测试。\n若要使用TUNA镜像，可以将第一行命令中的http://packages.ros.org/ros/ubuntu换成https://mirrors.tuna.tsinghua.edu.cn/ros/ubuntu/。\n整个安装到这就差不多结束了~Ubuntu的使用还是没有Windows那么友好的，不过在编程环境的配置方面还是能省不少事。以后买新电脑后甚至会考虑让这台机子常开Ubuntu当个服务器使了。\n","date":"2018-09-16T00:00:00Z","image":"https://zyxin.xyz/blog/2018-09/LinuxDualSystem/drive_manage.png","permalink":"https://zyxin.xyz/blog/2018-09/LinuxDualSystem/","title":"安装Windows与Linux（Ubuntu 16.04）双系统并搭建工作环境"},{"content":"这两大软件是我平时开发的主力软件，因此也将其插件配置分享出来~\nVisual Studio VS由于功能已经足够强大了，完全不是很需要插件的存在。不过确实VS还是有不少美中不足的地方的，因此插件也还是会装的~\nInline Color Picker：在代码中将颜色代码对应的颜色标记出来。（注：这个功能在VSCode中已经有部分支持了） Visual Assists：VA是个大名鼎鼎的VS插件，提供丰富的代码提示和代码重构功能。但是由于功能实在太强大，导致VS加载变慢很多，而它的功能只是锦上添花不要也罢，因此我一直都把它禁用了。 CodeMaid：提供丰富的代码整理功能。感觉用的并不多，因此也禁用着= =。 VSColorOutput：将输出窗口的文字显示不同的颜色。很好奇这么常用的功能为什么VS没有实现。。 搜索时发现一个相似插件Output enhancer，会试试这个好不好用 Visual Studio Code VSCode本身作为一个代码编辑器，可拓展的地方就有很多了。在编程语言和界面语言的支持上，基本每种语言都有对应的插件，因此在这里只列举语言支持之外的插件。\nRemove Development Pack：VSCode杀手功能！支持SSH到远程服务器写代码，也支持直接到docker和WSL里面写代码。远程连接十分方便，并且带宽需求很少。 CMake Tools：提供CMake工程的支持，在状态栏添加快捷窗口，很方便。注意与CMake语言支持插件区分。有时候CMake Tools比较烦人，比如在写ROS package的时候，这时可以选择只装CMake语言插件。 Live HTML Previewer：提供HTML页面的即时预览，不支持JS和CSS的动态更新。如果需要非常即时的更新的话可以考虑使用Live Server HTML。 SVG Viewer：提供SVG文件的浏览。注意与SVG语言支持插件区分，后者好像更强大，但是我一般只是看图用。 vscode-icons：VSCode上最老牌的图标包，图标很全！ hexdump for VSCode：将文件通过二进制形式查看，类似于Notepad++的HEX-Editor插件。 vscode-pdf：提供浏览PDF文件的支持，PDF打开速度不慢 Excel Viewer：浏览Excel和CSV数据非常方便！还附带筛选功能 Latex Workshop：Latex配套工具，需要预先安装Latex发行版（如MikTex），提供编译、预览、实时更新等功能 Markdown Preview Enhanced: 相比内置的Markdown预览提供更高性能的公式渲染。 TODO Tree: 便于查看所有的TODO和FIXME。 :emojisense:: 给Markdown添加emoji代码的提示，十分好用！ GitLens: 提供每行、每文件的git history、git blame Git Graph: 在VSCode里直接打开git graph！直观查看git历史~ ","date":"2018-02-02T00:00:00Z","permalink":"https://zyxin.xyz/blog/2018-02/ToolVisualStudio/","title":"利器 - Visual Studio \u0026 Visual Studio Code"},{"content":"VST 插件 VST的全称是Virtual Studio Technology，指的是将音色合成器和效果器整合进音频编辑和录制软件的一种软件接口，而VST插件就指的是一些符合这个接口格式的合成器和效果器。很多软件都支持VST插件，如我用过的FL Studio、Adobe Audition、Overture等，这些插件可以扩展音色、丰富音乐效果。\nSynth (音色合成器) MusicLab Real系列：MusicLab家的RealGuitar、RealLPC、RealStrat三剑客是著名的吉他音色合成器，不仅音色醇正，而且支持和弦操作 HQ Orchestral：罗兰三剑客Hyper Canvas、Super Quartet、HQ Orchestra之一，体积很小但却能模拟出很精致的管弦乐音色 Massive：电子乐制作中很多大牌音乐人都有用到的合成器，同样是基于三波形合成，但是界面很友好 Sylenth1：体积精简的合成器，能仿真出很多音色 Sampler (采样器) Kontakt 5：在软件推荐时也有提到Kontakt。Kontakt是一个音色采样加载器，可以加载很多实际采样出来的高清音质 Sample Tank：与Kontakt相似，同样是知名的采样加载器。但相比之下我更喜欢Kontakt的用户体验 Equalizer (均衡器) 【Fabfilter Pro-Q 2](https://www.fabfilter.com/products/pro-q-2-equalizer-plug-in)：这也是十分著名的均衡器了，界面美观，操作方便！ DSP 插件 DSP就是常说的Digital Signal Processing，由于对音频的操作其实就是数字信号处理，因此音频的特效插件也被称为DSP插件。这里主要推荐的是我在Foobar2000中使用的音效插件。\n注意，音效并不能提高音质，反而常常会损失音质，因此慎用\nWinamp DSP Bridge：让Winamp的DSP插件也能用在FB2K中的插件。Winamp有丰富的音效插件，这个插件就能让你在FB2K中享受Winamp的音效。 VST Bridge：同理，该插件可以将VST插件接入到FB2K中 DFX Audio Enhancer：功能比较单一的音效增强器，最有用的就是超重低音，但是会对音质有很大损失 Advanced Limiter：Foobar自带，防止削波（会产生刺耳的声音）。只要音质不是那么差几乎用不到 Dolby Headphone：在双声道中模拟出5.1甚至7.1声道的效果。听歌一般也没有5.1吧。。可能只有看蓝光时有用。 Dolby Pro Logic II：将双声道变成5.1声道。但由于自己一直用耳机听所以没有用。 Soundtouch：调节播放速度、声调等，很实用的插件。 ","date":"2018-02-02T00:00:00Z","permalink":"https://zyxin.xyz/blog/2018-02/ToolFXPlugins/","title":"利器 - VST \u0026 DSP 插件"},{"content":" 说明\n本文推荐 Windows 10/11 下本人常用的软件。选择标准大概是功能够用、体积小、文件污染少、界面整洁，个人喜好仅供参考~ 除了软件推荐网站外(如小众软件、异次元软件)，有很多其他的推荐列表，如Github上的Amazing-Windows-Apps、zhbhun博客也很不错。 软件安装可以选择去官网下载安装包，或者使用新的Winget + Winstall套装。 标记说明： Free: 有免费版 (freeware) Portable: 有免安装版本 Open-source: 开源 Replaceable: 虽然很优秀，但是有替代品或不常用 通用 驱动 DriverPack Free 驱动自动更新软件，界面不错，而且有一些额外功能 在安装时需要手动取消捆绑安装，曾经比X大师和XX精灵干净点，现在已经半斤八两了。关于捆绑软件的问题参见AppInn AIDA64 硬件参数查看和烤机软件，比较全面。如果喜欢简洁一点的可以使用CPU-z和GPU-z 不免费，不过用的情况也很少，一般是装机或者超频完用一下，因此试用版也够用了。如有需要可以上CRACKsurl找Keygen。 HWiNFO Free \u0026amp; Portable 另一款CPU-z与GPU-z的结合体，但是不如AIDA64稳定 压缩 WinRAR 老牌压缩软件，压缩很方便。恢复记录和加密都很有用。 现在有中文官网了，不过看着不靠谱。 由于WinRAR在解压时需要缓存空间，因此解压大文件时可将缓存位置设在同一盘符下。 Bandizip Free 功能比较全面，界面有很友好的解压软件！完全可以替代7-Zip。 右键菜单可以进行压缩文件预览，还有自动解压的贴心功能（自动识别单个压缩根目录文件夹的情况） 相比WinRAR由于没有恢复记录功能，因此较少使用。 ImgBurn Free 用来烧写和读取光盘镜像（ISO文件）的软件，提到镜像烧写软件除了UltraISO一般都会提到ImgBurn。简洁好用、功能充足。 虽然不是压缩软件，但是由于.iso文件经常被当作压缩文件使用，因此也放在此类。 Advanced Rar Repair Free \u0026amp; Portable 用来修复损坏的压缩包（包括没有恢复记录的）。成功率低，但聊胜于无啊！恢复一点是一点。 输入法 QQ输入法 Free 听起来很Low，但实际上用起来十分稳定，功能也足够丰富，哪怕试过别的输入法我也没换过。 手机我也使用的QQ输入法，手机端的功能甚至更强大，但是词典库与电脑好象是独立的？ 输入法皮肤用的是北方栖姬，有需要的可以点链接下载。 文件整理 Defraggler Free 著名垃圾清理器CCleaner的同门师弟，用来整理磁盘碎片，简便易用。 碎片整理对机械硬盘有一定加速效果，但据说固态硬盘不应使用。 听说有个能够进行优化碎片整理的软件Smart Defrag 5，不过由于没用过，就不推荐了。 Windows自带的碎片整理也是能用的，而且可以定期整理以降低一次运行的压力。 TreeSize (Free) Portable 磁盘空间可视化软件，我用来清理垃圾。相比于傻瓜式垃圾清理软件，自己清理可以删除更多东西，同时也是重新审视文件布局的过程。 TreeSize有免费版和专业版，免费版对我已经完全够用。 Space Sniffer Portable 同样是空间可视化软件，但是该软件的可视化效果是二维呈现的，更为直观。 由于二维绘制较为耗时，因此使用上不如TreeSize速度快。不过保存扫描快照的功能使得我也很常用这个软件。 Directory Lister (Pro) Replaceable 文件列表生成器，在备份和转移文件时挺有用。我会把这个软件用来整理音乐资源。 软件有试用版和专业版，由于其实使用频率很低，因此试用版即够用。另外，这个软件的功能其实可以通过随便写个脚本就能解决，因此不那么推荐，仅供不时之需。 Dism++ Free \u0026amp; Portable 是Windows内置工具Dism的升级版，功能强大。 提供很多系统管理功能，不过我最常用的是磁盘清理，能够清理系统更新残留和安装包残留。 10AppsManager (10AM) Free \u0026amp; Portable 功能很简单：卸载或重装Windows内置应用，强迫症福音 HDD Guardian Open-sourced 用来查看监测硬盘信息，简洁小巧 如果需要详细检查硬盘坏道的话还是需要其他软件，如HD Tune，HDD Scan，Macrorit Partition Expert。其中第一个最专业，但是新版本不免费。 SmartRename Open-sourced 用来批量重命名文件 文件备份 MultiPar Free 生成对多个文件的冗余修复（即RAR恢复记录，除了RAR基本之有这个方法了 Duplicati Open-sourced Replaceable 远程增量备份软件，支持加密和压缩 更新太慢了，现在我使用的是Duplicacy Duplicacy *Free 稳定性比Duplicati好（Feature更新快） 只有CLI的免费的，想要界面的话需要付费 浏览器 Google Chrome Free 这个都不用推荐了，基本已经是装机必备品了。目前最好用的浏览器之一，重在快，以及插件极其丰富 关于插件的推荐详见另一篇博文——浏览器插件 Microsoft Edge Windows10内置浏览器，尽管目前不是很好用，但速度快、更新快，而且有很多有创意的功能。 相比于Chrome，使用Edge的一个理由是占用内存少。Chrome是出了名的内存吞噬者，而Edge就好很多。 网络 下载/上传 Internet Download Manager (IDM)Replaceable 也是老牌文件下载器了，一直使用的原因就是快！非常快！另外，网站抓取的功能也很实用。 不是免费软件，价格也不算贵，可以考虑入正支持支持。 有浏览器支持，但不是很好用，一些需要认证或者Cookie的文件还是得用内置下载。 Free Download Manager (FDM) Open-Sourced 顾名思义，是一个开源的文件下载器。据称速度能赶上IDM，实际用下来速度倒是不差，而且对浏览器的支持比IDM好。 界面对高分屏不太友好，体验上感觉像是迅雷。但是比类似的EagleGet要稳定。 有一个基于著名下载工具Aria2的下载器叫Persepolis，感觉没有这个用着方便，功能超出日常地强大了。 FileUploader Free \u0026amp; Portable 支持很多很多网站的上传的客户端，但由于目前上传需求较少，因此使用频率较低。 SpeedPan Free \u0026amp; Portable Replaceable 良心软件！可以直接下载百度云而且不限速，还能搜索百度云资源 已挂勿念，买个会员吧哈哈哈哈 Rclone Portable \u0026amp; Open-sourced 支持各路网盘的文件同步（国内的除外），并且支持目录mounting（类似于虚拟硬盘） 配合RcloneBrowser使用更方便~ 代理 XX-Net Open-Sourced \u0026amp; Portable GoAgent的后继人，虽然速度不快，但应付日常使用完全足够了~重点是免费！hhh 配合IPv6食用更佳 Proxifier 可以强行将进程的HTTP请求重定向到指定代理地址。配合代理软件这样可以做到让一些程序强行走代理。 远程协作 MobaXTerm 功能极其完善的SSH客户端，比XShell功能更全，整合性更好，秒杀Putty五条街 自带X11服务器！！这是end of game级别的功能了！我配置成功的X11环境只有MobaXTerm。。 TeamViewer Free 非常流畅的远程桌面客户端，跨平台支持很多系统，包括Windows，Linux甚至Android！ 连接十分方便，只要知道代码即可。 社交 QQ Free 虽然很多人诟病QQ功能太花哨，但实际上我认为QQ能做到这么多功能的集成，并保证程序的流畅性已经实属出色。另外新版的QQ已经几乎没有广告的打扰了。 微信我不装电脑板，因为它不清理缓存，很臃肿，而且体验差。偶尔需要使用时会选择网页版。 TIM Free TIM的定位是“QQ办公简洁版”，TIM的流畅度还有待提升，但其进步值得期待。 Slack Free Replaceable 适合团队合作使用的软件，目前团队里会使用这个软件进行资料分享和交流。 每个群组都需要建Workspace才能用，并且需要单独登录，实在是很反人类 Discord Free 游戏语音功能非常流畅，视频功能也还可以 虽然界面和Slack有点像，但是Discord可以私聊 Zulip Open-Sourced 支持话题分类的群组聊天软件，感觉这个在办公上会比Slack好用多了！ 开发 环境 Anaconda Open-Sourced 由于Python是现在越来越常见的一种语言，因此把它的环境也放在推荐里了。 Anaconda是我认为最好用的Python发行包，不仅有必要的科学运算库的整合，还整合了conda环境，提供二进制包管理和虚拟环境 Git Open-Sourced Git环境大概是码农必备的吧~不过Git不仅仅可以用来管理代码，管理一些文档和论文也是很不错的！ Git本身的GUI很难用，主要用命令行，GUI的话可以使用下面推荐的GitKraken GitKraken Free GitKraken是基于Electron的Git客户端，跨平台且十分好用。唯一让我比较介意的是它自己更新时不会自动把旧版本删除。。 GitKraken分为Free、Pro、Enterprise三种版本，免费已经完全够用。 CMake Open-Sourced CMake是现在非常流行的编译工具，大型的C++项目很多都会通过CMake编译，其他语言的工程也会有通过CMake来进行组织的。 CMake自带的GUI也比较好用 编辑器 Visual Studio Code (VSCode) Open-Sourced 好用到无话可说的代码编辑器！有此一个工具，其他代码相关软件都可以不用装了！可以替代PyCharm、Code Blocks、MarkdownPad等等大部分工具 VSCode的定位是介于文本编辑器和IDE之间的软件，但更偏重文本编辑。相似软件有Atom、Sublime Text，但现在都没有VSCode强大了！ VSCode插件列表参见这篇博文 NotePad++ Free \u0026amp; Portable 重量级文本编辑器，轻量级代码编辑器。从名字来看它应该是作为Windows记事本的替代品，实际上我也是这么用的，打开文本快如闪电！ 作者的政治立场有问题，不过该用还是可以用的，只是我是不会用了 HxD Free 二进制内容的查看虽然VSCode也支持，但是还是专用的软件性能更好 IDE Microsoft Visual Studio 最好用的IDE，没有之一。目前用作C#、C++、Python开发主力的IDE。 有很多版本，Express版本是免费版，完全够用。 通过Visual Studio Android Emulator等模拟器可以进行 跨平台开发。 Dev-C++ (DevCpp) Free 默认使用GCC编译器的C/C++语言IDE，安装和使用都比较方便。不过我只拿DevCpp来刷OJ和写一些小的测试项目，大项目还是都上VS。 与Code Blocks很相似，不过我感觉虽然DevCpp不更新了，但它更简洁更快，而且主要是用习惯了。 其实配置习惯以后DevCpp和Code Blocks都可以被VSCode替换掉。 Android Studio Open-Sourced 最好用的Android开发环境，推荐它没有别的意思，只是因为它比Eclipse好用太多！= = JetBrains Free 著名的IDE套装，Java版（IntelliJ），Python版（PyCharm），C++版（CLion）都是对应语言非常流行的IDE 不足之处就是JetBrains套装都有点吃内存，跟Chrome一样 学生不仅可以免费使用Edu版，而且好像可以申请Pro版！ 开发辅助工具 DB Browser for SQLite (DB4S) Open-Sourced \u0026amp; Portable SQLite开发时会用到这个工具，查看和查询数据库内容非常方便！ Fiddler Free HTTP抓包软件，也是业内知名了，做爬虫和第三方软件时很常用。比Wireshark要简单很多。 在设置好Proxy之后甚至可以做到安卓抓包 Serial Port Utility Free 用过的界面最好看的串口调试助手，功能也比较齐全。用来辅助单片机开发 RegexBuddy Replaceable 正则表达式助手，能够解释正则表达式，并测试指定文本，适合学习和调试正则表达式 由于是收费版，因此如果功能需求不多，可以考虑**Notepad++**的插件RegEx RegShot Free 注册表快照软件，现在很少用了。主要用它来监控软件安装和运行过程中修改的注册表内容，避免软件暗中捣鬼，也能在软件卸掉以后通过它来清空注册表 BeCyIconGrabber Portable 功能很单一，就是提取exe、dll等文件中的图标资源，有时候能发挥大作用。 Cmder Open-Sourced Replaceable 非常好用的终端，可以用cmd、PowerShell、WSL bash等作后端 在Windows上现在Windows Terminal更好用 Windows Terminal Open-Sourced 由微软官方开发的现代终端，支持多后端 UI设计比较现代，不过在一些性能上好像不如VSCode的终端 多媒体 播放器 Foobar2000 (FB2K) Free 功能最全的音乐播放器，由于提供插件和皮肤机制，可定制程度极高！ 关于FB2K的插件和DSP效果器的推荐还会有新的博文来介绍。 PotPlayer Free 功能最全的视频播放器，同样有皮肤定制功能。视频播放的相关功能也很完备！ PotPlayer还为平板电脑提供了触控支持，非常赞！ Bililocal Open-Sourced \u0026amp; Portable Replaceable 在线搜索B站弹幕并与本地视频一起播放的软件，由于番剧我一般都是下载下来看，因此看番时我会选择这个。 可以通过Danmu2Ass与弹幕下载来结合，由于Bililocal作者很久不更新了，之后会尝试这个方案。 IrfanView Free 功能最全的图片浏览器，提供完备的图像查看和转换功能和基本的图像处理功能。 支持批处理，因此在整理图片时非常有用！ 对PDF和SVG虽然支持，但是体验不好，两者可以直接通过浏览器查看。 虾米音乐 Replaceable 在几大流行在线音乐网站里面我选择了虾米，不是因为其软件很好用，而是因为用久了。另外虾米的日系歌曲也是比较全的，因此常用虾米。 虾米的桌面客户端非常辣鸡：老版的应用久不更新，不支持高分屏，体验极差；新版的16年才出现，基于Electron但是很卡，功能也很少，不得不吐槽一下。 虾米在2021关停了，RIP Last.fm (Scrobbler) 用了很久Last.fm，由于其实在线听歌的时间不多，很多都是听CD和硬盘里收藏的东西，因此会选择离线听歌。这时就用Last.fm来进行听歌记录。 Last.fm比较强的一点其实是社交和推荐功能，但由于它本身不提供音乐，因此其他功能就用的比较少了。 Cider 第三方苹果音乐客户端，天下苦iTunes久矣！ 我感觉这个软件的UI比官方做的还好 媒体管理 Exact Audio Copy Free 抓CD必备软件，能够尽最大可能确保音质不在抓取过程中损失。 Mp3Tag Free 编辑音乐文件内置Tag信息的软件，功能完备，使用方便~唯一比较在意的是名字太土了- -，一直不改 PicGo Open-Sourced 图片分享软件，相比ShareX而言支持各种国内图床。这对在一些论坛发帖有需要~ 媒体处理 Adobe 套装 大名鼎鼎，毋须介绍，媒体处理还是以Adobe家的工具最好用啊 我常用的产品有： Photoshop: 图像处理。有一个开源的替代品是GIMP，但还是没有Photoshop好用。 Audition: 音频处理。包括去噪、裁剪、混合等等。部分功能可以用Reaper来完成 Lightroom: 照片后期。做修图是非常方便的！ 针对图像处理有一套Adobe插件叫Nik Collection，配合Lightroom后调色十分方便。 Premiere Pro: 视频剪辑。做一些简单的特效是没问题的 After Effects: 视频特效软件，复杂特效很多通过After Effects完成 Media Encoder: 视频转码软件。虽然很专业，但是感觉支持的格式还没有格式工厂多。。 Adobe家的资源基本都可以在LookAE上找到。 Vector Magic Portable 很强大的位图转矢量图软件，可以定义颜色数，定义平滑程度等等，效果很好。还能导出成Illustrator格式 对提取图标、提取素材非常有用 Open Broadcaster Open-Sourced 开源的直播软件，不过我没有用过就是了 有一个类似软件XSplit Broadcaster，也木有用过 Image Composite Editor (ICE)Free 全景照片合成软件，我软出品的系列精品~ Audacity Open-Sourced 单轨音频编辑软件，有点类似以前的GoldWave，重在开源 HandBrake Open-Sourced 功能比较齐全的视频格式转码软件，可以替代Adapter和500th Video Converter。（不过界面还是Adapter最友好。） 和Adapter都支持SRT格式字幕嵌入 需要更专业选项的话可以考虑小丸工具箱，转码+压制的专业工具，十分良心但是最近不怎么更新了。 编曲 FL Studio DAW软件也是种类繁多，百家争鸣，但我最喜欢的还是FL，因为作为初学者，这个上手最简单~~ 以前常用的是FL11，现在的新版本FL12用户操作友好了很多 FL的插件和VST插件也会在其他博文中进行介绍 Reaper Reaper是一个介于编曲与音频编辑之间的软件，也是被很多人推荐的软件。可以将音频、视频和MIDI衔接在一起并进行Mastering 有60天适用期，而且好象是按照使用时间算的？非常人性！ Kontakt Kontakt是一个通用的音色库，可以通过加载音色文件来加载很多音色，然后连接到DAW中。如果在编曲时想混入乐器或者自然声，用Kontakt是很有用的。 系统增强 文件同步 OneDrive Windows亲儿子，系统集成度高。尽管空间不大，但是常用文件的同步十分好用 其他可选软件有Google Drive，七牛云等等，但由于集成优势，我还是选择OneDrive！另外Google Drive要翻墙也是硬伤。 GoogleDriveFS Google Drive Stream可以添加虚拟盘符，在能翻墙的情况下还是很好用的 如果你有美帝高校的账号，可能就会附带Google Drive的空间，使用起来就很舒服了 文件管理 Listary Free 好评如潮的工具，用来进行文件索引和快速访问，还可以将文件选取对话框定位到打开的文件夹。 还可以绑定快捷键，作为一个自动化工具使用。 可以看作另一个著名工具Everything的升级版 Dism++ Free \u0026amp; Portable 同样也是很有名的工具，用来对系统进行垃圾清理以及启动项管理。 体积小、功能多的良心软件 HashTab Free 能在文件属性界面中添加一个选项卡显示文件的Hash值，小巧实用 Aomei Partition Manager Free 功能强大的分区管理软件，甚至可以通过内置WinPE来压缩系统盘的空间 针对NTFS文件系统，如果有装Linux双系统的话可能会在对应硬盘上破坏掉Linux的分区 截图 基本的截图工具Windows是有内置的，叫Snipping Tool，在Win10 1809后有Snip \u0026amp; Sketch，可以在通知中心直接调出。另外也可以通过系统快捷方式来完成简单的截图，Win+Shift+S选框截图，(Ctrl+)PrtScn全屏截图，Alt+PrtScn截取当前窗口。 然后录屏功能的话Windows的Game Console可以直接录像，按Win+G可以调出\nSnipaste Free \u0026amp; Portable 强大的截图软件，除了截图应有的功能外它还可以把剪贴板中的内容固定在屏幕上，这个意外有用的功能也是它名字的由来。 V2EX上有个作者自己写的功能介绍，功能十分贴心。 TakeColor Free \u0026amp; Portable 功能十分单纯的软件，用来屏幕实时取色，有时候想动态地分析图像的颜色就可以用这个软件了。 ShareX Open-sourced \u0026amp; Portable 屏幕截图+屏幕录像+集成上传，非常使用。还有额外的一些小工具，例如计算Hash，编码转换等等 可以替代PicPick、Bandicam、HashCalc等工具，并且最棒的是开源！ 录屏如果要求不高的话，通常还是使用系统自带的Win+G打开XBox工具进行录制。 Honeycam Free 有录屏、录屏+转换GIF、图片转GIF等功能。虽然不直接支持视频转GIF，但是用播放器+录屏就可以了 GIF的质量和色域可以调整，这个非常实用 免费版有水印，但是水印非常小 文件浏览器 RightMenuMgr Free 国人开发的右键菜单管理软件，功能基本够用，不过很久没有更新了 FileMenu Tools 不仅支持右键菜单管理，而且支持添加自定义命令。美中不足的是软件收费。 QuickLook Open-sourced 支持多种文件的预览，在文件浏览器中选中文件按空格即可。 手势 WGesture Open-sourced 通过鼠标手势的方式支持很多小功能，很强大 支持通过中键、右键、侧键来触发 GestureSign Open-sourced 从WGesture衍生而来，支持触屏手势 基于UWP，可以从Microsoft Store下载 SAOUtils 刀剑神域风格的系统启动器，通过鼠标下拉触发，界面仿的太到位了！功能也是很强大，不过最近没有更新了 任务栏 XMeters Free 能够在任务栏美观地显示CPU、内存、硬盘和网络使用情况，不错的小工具 另一款软件cFosSpeed除了网速显示外还能够降低网络延迟，但没用过也就不推荐了。 TwinkleTray Open-sourced 在任务栏中添加按钮，可以自由调节每个显示器的亮度 EarTrumpet Open-sourced 在任务栏中添加按钮，可以很方便地选择音频输出，并且调节每个应用的音量 美化 [TranslucentTB] 让任务栏变得透明 生产力 文档处理 Microsoft Office 这个也不用介绍了吧。。。虽然有WPS、Libre Office、Google Docs等替代品，但终究还是Office好用啊！ Microsoft OneNote 记录文档、做笔记的不二选择！配合微信公众号和Chrome插件，使用起来非常好使！ 另外，对于Surface用户来说Onenote就更棒了，直接手写笔记，和用真正的本子记录没有什么区别 LyX Open-Sourced 被很多人安利过LaTeX，但是限于学习成本高，且没有真正的使用需求，还没怎么学会LaTex的使用。而LyX就是介于Word和LaTex中间的一款软件了，它能够通过可视化界面编辑LaTeX，可以作为过渡期的替代品。 安装比较麻烦，有很多依赖项 Phantom PDF (福昕阅读器) 十分强大的PDF编辑器，功能完备，速度和使用体验都比Adobe自家的要好！另外，它使用的Ribbon界面设计也很讨喜 福昕阅读器的运行速度也不错，高清位图和复杂矢量图都能较快地打开。（目前测试下来，PDF.js是打开PDF速度最快的） Drawboard PDF Surface必备软件，用这个软件在PDF上做笔记是最方便的，配合Onenote使用后上课根本不用带书和笔！ Nebo Surface必备软件，这个在整理功能上没有Onenote强大，但是纯文字识别来说非常有用！能够快速识别手写图表、公式，这方面用得比Onenote顺手 Grammarly 语法纠错软件，免费版的功能已经很不错了，能改掉很多低级错误，在英文写作时很有用。 PDF Shaper Free 提供一些基本的PDF处理功能，在这方面远不如Phantom PDF，不过最有用的是他的解密功能。 数学 SketchPad (几何画板) Replaceable 中学时代就非常喜欢的数学软件，不仅对学习几何很有帮助，能绘制函数图像也非常有用。 使用界面简洁简单，标注的字母和公式我认为也比下面提到的GeoGebra好看。 有一些特别的功能，比如绘制分形和绘制波形来发声等等，目前发现其他类似软件能实现的。但这些都不是常用功能，大部分功能还是可以通过GeoGebra实现的。 GeoGebra Free 能绘制动态约束的几何图形，能绘制函数图像，对数学学习很有帮助 性能上比几何画板差，容易卡，界面对高分屏也不友好 展示 Prezi 也是挺有名的展示软件了吧，内容动画不多，但是章节之间是通过旋转和缩放进行过渡的。使用简单，效果酷炫 Sway 这是我目前最欣赏的展示软件，没有花里胡哨的功能，重视内容，将其他过渡都交给软件处理。做Slides就跟写文章一样直接。 有Windows商店版本，展示内容随微软帐户同步，很方便。 carnac Open-sourced \u0026amp; Portable 用来在屏幕上显示按键操作的软件，小巧美观 有一个功能更加强大的KeyCastOW，但是需要自行编译 文献管理 Mendeley Free 文献管理也是需求很大的一类软件，最常用的应该就是Endnote了，但由于Endnote很臃肿，并且管理需要有Library这个概念，我很不喜欢，我更倾向于Mendeley的轻量级管理方式。 Mendeley有两个很突出的特点：可以导入PDF、有文献推荐系统，这两点就是我选择Mendeley的关键原因。 Citespace Portable Prof. Chen 编写的文献关系可视化软件，可以结合Web of Science生成文献关系图，便于文献的追溯，在刚接触科研的时候很有用~ 杂项 MagicVoxel Open-sourced \u0026amp; Portable 3D像素艺术软件，很有趣。可以在三维中创造类似于平面的像素艺术作品，使用也很方便，性能也不错 Calibre Open-sourced \u0026amp; Portable 著名电子书管理软件，支持txt、epub、mobi等格式~我在用Kindle的时候会用上它 NTLeas Open-sourced 软件(主要是游戏)转区软件，是Windows曾经自带的Applocale的升级版，能解决日文游戏或其他国家游戏的乱码问题。 除了解决乱码问题外还可以解决锁区问题，如CM3D就必备NTLeas Rufus Free \u0026amp; Portable 在U盘上制作系统安装盘的利器，简洁好用，重要的是不像UltraISO一样收费 微软必应词典 Free 这个离线字典对付日常的英语翻译完全没问题了，但如果要丰富的词义还有多语言支持就力不从心了。 Xming Free 在Windows上运行的X Server，可以让WSL支持图形界面。不过这玩意很久没更新了，只能用来尝试玩玩。 待办清单 Trello free 不仅能很好地管理任务列表，还能与他人共享列表，并且支持附件和Markdown。 国内的替代产品是Worktile，但我还是喜欢Trello的交互方式，拖拽十分方便。 UWP版本虽然是网页套壳，但是也勉强够用了(Trello好像不是很重视UWP的样子) Wunderlist free 中文名是奇妙清单，也是很有名的清单软件了。 独特之处是跨平台性好，电脑配合手机上的Microsoft Desktop使用十分顺畅。 游戏 HMCL Open-Sourced \u0026amp; Portable 著名的Minecraft启动器，一键整合Forge、LiteLoader，功能还在不断完善！~ Terramap Open-Sourced \u0026amp; Portable 游戏Terraria的地图浏览器，有了这个之后就能省下很多游戏时间=v= ReShade Open-Sourced \u0026amp; Portable 注入游戏里面可以动态修改渲染，我暂时也没用过 Fix Automata Resolution (FAR) Open-Sourced 修复NieR:Automata的锁帧问题，提高游戏体验，玩这个游戏的话必备~ 不在此推荐的好软件 键盘操作 有一些软件虽然口碑极好，但是我遵循着使用Windows就应该便于鼠标操作的原则，感觉不适合我而没去使用。\nAutoHotKey TotalCommander Win10内置 由于Windows 10足够强大，能够被系统功能代替的程序也不在考虑范围内。\nWox: 可以被Cortana代替 猎豹WIFI: 可以被系统自带WIFI功能代替 nTrun: 核心功能和系统快捷方式区别不大 Start10: 习惯了Windows Metro磁贴的使用方式后其实觉得磁贴是非常好用的 ClipDiary、Ditto：Win10 1809更新后系统自带剪贴板历史和同步了！通过Win+V即可调出~ XShell: Win10 1709更新后已经添加OpenSSH支持，只需在系统可选功能中添加功能即可。 另外，Windows还有一些官方工具，但是没有包括在系统内的，叫PowerToys。这个工具箱里有很多实用的功能，如文件批量重命名、窗口布局、程序Launcher等等。不知道为什么微软没有直接发布到系统商店里= =。\n","date":"2018-02-01T00:00:00Z","permalink":"https://zyxin.xyz/blog/2018-02/ToolWindows/","title":"利器 - Windows"},{"content":"Chrome/Firefox 插件 Chrome/Firefox如此强大离不开它的插件生态，他们的插件成千上万，经常有新的冒出来，这里我就记录一些我常用的吧~\nActiveX for Chrome (网银助手)：介绍说是可以在Chrome中启用ActiveX控件，但实际上为了避免失败重新支付，我一般还是会用Edge打开支付页面。 AdBlock：大名鼎鼎的广告屏蔽软件，效果拔群。不过为了一些站点的发展，还请把必要的站点加进白名单。 Adkill and Media Downloader：去视频广告+媒体下载+盗链图片显示，效果没有想象中那么好 Anything to QRcode：将网页地址或网页文字内容转换为二维码，非常实用！如果你需要向别人发送电脑链接或者文字，不用打开微信客户端，只需这么扫描一下即可。 Awesome Autocomplete for Github：为Github搜索框提供自动提示，提示内容包括仓库和用户等 Better History：友好的历史记录管理器，自带的确实不怎么好用 Chrono：Chrome下载管理器，很好用，自带的下载器蛋疼的不行。 DarkReader：自动生成自适应的夜间模式，效果非常好！不过开启时会影响网页加载速度 EditThisCookie：修改网站的Cookie，不仅对开发有用，而且对一些网站的限制也可以通过这个打破！ Enhanced Steam：增强Steam商店页面，可以显示价格趋势，关怀剁手党 Github Plus：在Github仓库中显示文件大小 Github Stars Manager：给Github Star增加标签，非常实用！！还在改进中，比较大的一个缺点就是性能比较差，加载慢！ goo.gl URL Shortener：通过goo.gl服务压缩当前地址，这个需要连接Google服务，因此需要梯子。 Google Scholar：功能很简单，就是小型的文献搜索按钮。但由于搜索文献的需求很大，因此能提高不少效率。 Keepa：亚马逊价格追踪器，专克价格虚标！ Mendeley Importer：配合Mendeley使用，可以在网页内导入文献信息 Neater Bookmarks：弹出式的小型书签管理器，搜索框非常好用因此经常使用它 Octotree：为Github仓库页面添加代码树，用于文件导航，也是很实用的功能 OneNote Web Clipper：提供将网页直接存到OneNote中的功能，对我十分有用的功能 Project Naptha：对网页中所有图片提供OCR支持，可以直接选择图片中的文字（仅限英文）。实际使用效果差强人意，因此使用频率很低 Proxy SwitchyOmega：经常用梯子的人对这个插件应该很熟悉了，能够方便地切换代理设置 Sad Panda：如果上不去N站可以通过这个插件解决 SimpleExtManager：这个插件很关键！这个插件能够便捷地启用和停止其他插件，加速Chrome的运行速度 Tampermonkey：Userscript（又称油猴脚本）的加载器，油猴脚本的使用会在下一节介绍 The Great Suspender：将长时间不活动的标签页暂时挂起（实际上是转到内置的暂停页面），这个插件能够有效避免Chrome对内存的消耗。但是另一方面可能会导致正在编辑的窗口被取消，造成数据损失，因此使用时需小心 Toby:可以将标签页暂存到它的库中，当打开新标签页时可以通过Toby快速访问。有点像临时书签的感觉。另外，这个功能在Edge中已经内置实现了。 Unblock Youku：这是从国外翻回国内的梯子 Visual Ping：定期检查页面的变化，并在产生变化时发出提醒。由于我对这个需求很少，因此基本是一直禁用着的。 Wappalyzer：分析网站使用的框架，对开发者有一定帮助 Xiamini (虾米你)：虾米页面功能拓展 哔哩哔哩助手：B站页面功能扩展 Userscript 用户脚本（Userscript、油猴脚本）指的是修改网页内容的脚本。相比用户脚本，浏览器拓展能够调用浏览器的API对浏览器进行操作，但另一方面体积却更加臃肿。用户脚本主要用于页面内容的修改，更注重内容的操作，不限于某一种浏览器。但由于用户脚本非常多，没有审核机制，因此没有鉴别能力的话慎用。\n用户脚本最开始的管理网站是userscript.org，但是它挂掉了。现在更好使的是GreaseFork。下载之后需要加载进浏览器的插件中，其中Tampermonkey是支持浏览器最多的加载器，其他加载器可以参见GreaseFork的首页。\n下面有一些我常用的用户脚本，介绍就直接去页面里面看吧。更多的用户脚本可以去知乎或者别的地方搜索~\n城通网盘、皮皮盘、牛盘显示正确下载地址 琉璃神社下载链接生成 百度云插件+APIKey 百度网盘直接下载助手 自定义百度云分享密码 Fake115 ","date":"2018-02-01T00:00:00Z","permalink":"https://zyxin.xyz/blog/2018-02/ToolBrowser/","title":"利器 - 浏览器插件"},{"content":"我经常会碰到拿别人的代码过来用却发现不是Python写的代码的情况。这个时候，如果你想调用他的代码，要么自己费力地把他的和自己的代码翻译成同一种语言，要么利用语言特性直接调用（如Lua直接调用C函数），但其实最简便的办法是通过外部程序调用的方式调用他的程序，只要传入相关参数即可~本文就讲一下在Python下调用外部函数或者命令的几种方法~\nos.system 这个函数和C语言中的system()函数是类似的。这个函数比较简单，但是只能调用系统命令，无法直接调用外部函数，也无法获取运行的返回值或者输出流什么的，简便但不够灵活。\nos.spawn* Python中os模块1自带的函数spawn*是我最早接触到可以调用外部程序的函数，根据*的不同具体一共有八个函数\n1 2 3 4 5 6 7 8 os.spawnl(mode, path, args*) os.spawnle(mode, path, args*, env) os.spawnlp(mode, file, args*) os.spawnlpe(mode, file, args*, env) os.spawnv(mode, path, args) os.spawnve(mode, path, args, env) os.spawnvp(mode, file, args) os.spawnvpe(mode, file, args, env) 不同字母代表的含义其实通过函数定义即可看出，具体分别是：\nl和v的区别在于调用的参数是直接传入的还是通过列表对象进行传入的，从函数定义即可看出。 p代表外部程序的文件本体将从系统PATH中进行寻找，只需输入文件名即可 e代表所调用的程序的环境变量可以通过env参数来指定 mode代表调用函数的线程模式，有如下几种：\nos.P_NOWAIT: 调用外部程序后函数本身不会等待，将会立即返回，代码继续执行 os.P_WAIT: 调用外部程序后函数等待程序执行结束才会返回继续 os.P_DETACH: 与os.P_NOWAIT相似，但是新的线程会脱离所调用的控制台（也就是说新的程序将不会通过当前的控制台来输出） os.P_OVERLAY: 当前线程将会被替换成新的线程，这意味着spawn*函数将一直不返回 subprocess subprocess模块2据Python官方文档所说，是用来替代以下这些函数的：\nos.system os.spawn* os.popen* popen2.* commands.* subprocess常用的函数或对象有这么几个：call, check_*, Popen。下面介绍一下它们的用法。\ncall: 调用程序，等待到程序执行完成后返回程序的返回值 check_call: 调用程序，等待到程序执行完成后，若返回值为0则函数返回，若返回值不为0则抛出CalledProcessError异常 check_output: 调用程序，将程序的输出字符串以bytes形式返回 Popen: 参数与call相同，新建Popen对象即会调用程序，并且将新线程的相关操作封装在了Popen对象内，包括检查状态，等待等等。 这些函数或类对象的调用方法与在Shell中直接调用十分相似，并且除了指定参数之外还可以通过stdin, stdout, stderr等参数来指定新进程的输入输出，还可以通过指定shell参数来让，命令通过Shell进行调用，以利用Shell的一些功能。\nos.spawn文档\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nsubprocess文档\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2017-12-14T00:00:00Z","permalink":"https://zyxin.xyz/blog/2017-12/PythonCall/","title":"Python - 如何调用系统命令或外部程序"},{"content":"Python \u0026amp; C/C++ 近来用Python用的越来越多，对这种十分灵活的动态语言的哲学也有了较深的理解。虽然Python有不少缺点，如没有强类型，GIL全局锁，没有编译因此效率底下，但正因为其动态性，它非常适合写软件的Prototype。因此一种典型而高效的工作流程是先用Python调用各种轮子，快速实现软件原型，然后再优化代码，将稳定的部分用C++或其他编译语言进行重写，变成一个供调用的库。\n在这个过程中就难免碰到Python与C++相互调用的问题，尤其体现在：\n在原型开发阶段，如何将现有的C++库封装成Python能够方便调用的库，避免重造轮子 当原型开发结束后，如何将Python代码高效地转换成其他语言的代码 能够完成Python与C/C++相互操作的方式有很多，可以参见知乎的这篇专栏，但是本文介绍的Cython却鲜有详细或通俗的中文资料。Cython是个易用的Python扩展，在Anaconda等发行包里面都自带了，可以用Python的语法写出Python的C语言扩展。因此我选择这一款扩展库学习，之后也会把相关的学习经验写下来~\n安装与基本使用 后文中的环境都是在 Windows10 + Visual Studio 2017 下\nCython在流行的Python发行版本中都有被包含，包括Anaconda、Canopy、Pythonxy和Sage等。如果使用普通的Python的话可以使用pip安装：pip install Cython。\n简单运行Cython代码 从语言层面来说，Cython是一种拓展的Python，其文件的扩展名为.pyx。这种类型的文件通过编译之后可以变成供Python直接调用的动态链接库（Linux/Mac下是.so，Windows下是.pyd）。根据官方文档，主要如下几编译方式：\n(推荐) 通过setup.py中调用Cython.Build进行编译 使用pyximport调用.pyx文件，这种方法.pyx文件相当于普通的.py文件 在命令行使用cython命令从.pyx文件生成.c文件，再使用外部编译器将.c文件编译成Python可用的库 使用Jupyter Notebook或者Sage Notebook直接运行Cython代码 这上面四种方法里最简单的是第三种方法。运行cythonize -i \u0026lt;.pyx File\u0026gt;即可编译.pyx成二进制库，并保存在与.pyx文件相同的目录下。cythonize命令有其他的参数，可以通过命令行查看。这个命令也可以通过python -m Cython.Build.Cythonize -i \u0026lt;.pyx File\u0026gt;来完成。\n不过推荐使用的是第一种方法，原理也就是通过指定distutils或者setuptools库中的ext_modules参数来编译Cython代码。以官方示例为例，它的setup.py文件如下\n1 2 3 4 5 6 7 from distutils.core import setup from Cython.Build import cythonize setup( name = \u0026#39;Hello world app\u0026#39;, ext_modules = cythonize(\u0026#34;hello.pyx\u0026#34;), ) 其中hello.pyx的代码为\n1 2 def say_hello_to(name): print(\u0026#34;Hello %s!\u0026#34; % name) 编辑保存之后直接运行python setup.py build_ext --inplace即可进行编译。其中--inplace参数可以让对应的链接库生成在源代码所在的目录。\n编译中可能遇到的问题有\nerror: command 'cl.exe' failed: No such file or directory: 这说明在环境中没有找到C编译器。由于我电脑中安装了Visual Studio，我的解决方法是根据平台使用VS的x86 Native Command Prompt或x64 Native Command Prompt来运行编译命令。此外还可以选择通过python setup.py build_ext --inplace --compiler=mingw32使用Anaconda内置的MinGW32编译器，不过这种情况下还可能会遇到内置MinGW32的问题，具体的解决方法在链接里。 编译之后直接通过import hello或from hello import say_hello_to即可调用这个编译好的库。\n复杂Cython工程的setup.py 如果的Cython工程中有很多.pyx文件，甚至有很多.cpp文件需要编译，那么这时候最好使用setup.py进行编译，并使用Cython.Build.cythonize模块。具体编写方式如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from distutils.core import setup from distutils.extension import Extension from Cython.Build import cythonize extensions = [ Extension(\u0026#34;Module Name\u0026#34;, [\u0026#34;file1.pyx\u0026#34;, \u0026#34;file2.cpp\u0026#34;, ...], include_dirs = [...], libraries = [...], library_dirs = [...]), Extension(\u0026#34;Module 2\u0026#34;, ...) ] setup( name = \u0026#34;XXX\u0026#34;, ext_modules = cythonize(extensions), ) 最后的setup部分还有另一种写法：\n1 2 3 4 5 setup( name = \u0026#34;XXX\u0026#34;, ext_modules = extensions, cmdclass={\u0026#39;build_ext\u0026#39;: Cython.Build.build_ext} ) 这样的写法可以让安装整个库的时候一起执行掉Cython代码的编译和安装。此外，如果要在编译.pyx和.cpp时指定语言或者编译参数，在Extension类的构造函数中添加合适的参数即可。\n总结 本文介绍了Cython的安装与初步使用，看完以后就已经可以动手试试写Cython代码啦~Cython语言的特性也有不少，掌握其中的一小部分就能大大提高你的Python代码的运行效率！这些内容将会在之后的文章中讲述~\nCython的完整介绍可以参考Cython官网 Cython代码的编译还有其他方法，参见Cython文档的编译部分\n","date":"2017-12-05T00:00:00Z","permalink":"https://zyxin.xyz/blog/2017-12/CythonIntro/","title":"Cython - 入门简介"},{"content":" 本文安装时的各软件版本为\nWindows 10.0.15063 Visual Studio 2017 (VS15.2) Anaconda3 4.3.25 CNTK 2.2 Tensorflow 1.4 Keras 2.0.6 NVIDIA Geforce Notebook Driver 376.54 配这一波环境又让我对微软爸爸的信仰值飙升一大截！特此记录一下安装过程，虽然步骤十分简单没有什么好写的（笑，但是本着能不再踩的坑就不要再踩的原则，还是记录下来吧~\n安装 CNTK 不得不说我还是非常喜欢CNTK的，不仅因为它是微软爸爸的产品，能在Windows亲儿子上运行，而且性能很不错（关于性能的比较可以参见Github一篇评测、一篇老文和一篇新文），最重要的是它是所有深度学习库里面唯一提供Pre-built Installation的！！不知道多少人在编译Caffe和Tensorflow时被N卡驱动和CUDA、MKL等等安装坑过。。。占空间就罢了，还经常各种报错！而Windows下安装CNTK，由于已经编译好了，就不会碰到这种问题！所以当我得知几个月前Keras已经支持CNTK后端的时候，我立马准备在自己的电脑上装一份了！省的天天跟别人抢服务器= =\n安装流程可以参考官方教程。首先就是下载CNTK，我当然是选择下载编译后的包啦，直接进入CNTK的Release页找到你需要的版本就可以~（不得再次感叹一声预编译版本好全。。连UWP都有）当然你如果不怕像Linux一样折腾= =那么你可以直接下载源码去编译。\n下载后解压。注意，解压后的位置直接就是之后CNTK运行的位置，因此后文解压到的目录就称作“CNTK目录”了。然后cd进\u0026lt;CNTK目录\u0026gt;\\Scripts\\install\\windows运行install.bat即可安装。为了避免cmd把路径识别成两个参数，请把压缩包解压到一个不含空格的路径中。\n如果之前已经装了Anaconda，就可以通过AnacondaBasePath参数指定Anaconda的位置避免重复安装。这里如果你anaconda的安装位置有空格的话batchfile就会同样因为路径问题用不了了，只能上Powershell直接运行ps1脚本。用管理员模式打开Powershell，先在环境变量中添加ps1的模块位置$Env:PSModulePath=$Env:PSModulePath+\u0026quot;;\u0026lt;CNTK目录\u0026gt;\\Scripts\\install\\windows\\ps\\Modules\u0026quot;，然后运行ps/install.ps1 -AnacondaBasePath \u0026quot;\u0026lt;Anaconda安装目录\u0026gt;\u0026quot;，即可安装。如果遇到无法加载文件，因为在此系统中禁止执行脚本。的报错，可以运行Set-ExecutionPolicy Bypass命令（不区分大小写），在运行完脚本后运行Set-Execution Restricted设置回来。\n此外还可以通过PyVersion参数来设置conda环境的Python版本，默认的版本是3.5。安装完成后Anaconda中会添加cntk-pyxx的环境，后两位是你指定的Python版本，后文就用默认的cntk-py35来表示。\n安装完成后运行\u0026lt;CNTK目录\u0026gt;\\Scripts\\cntkpy35.bat设置环境变量，然后会进入cntk-py35环境。再cd到\u0026lt;CNTK目录\u0026gt;\\Tutorials\\HelloWorld-LogisticRegression，运行cntk configFile=lr_bs.cntk makeMode=false command=Train即可验证安装。\n安装 Keras 安装CNTK后安装Keras就很简单了。首先运行activate cntk-py35进入环境，然后运行pip install keras即可。\n然后是把Keras后端切换成CNTK，Keras文档有对应的说明，只需将%USERPROFILE%\\.keras\\keras.json中的backend值改为cntk。\n初步测试Keras只需测试import keras能否成功即可。进一步的测试可以通过运行Keras的样例脚本来完成。运行结果如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 (cntk-py35) C:\\Users\\Jacob\u0026gt;python C:\\Users\\Jacob\\Downloads\\mnist_mlp.py Using CNTK backend Selected GPU[0] GeForce GTX 850M as the process wide default device. 60000 train samples 10000 test samples _________________________________________________________________ Layer (type) Output Shape Param # ================================================================= dense_1 (Dense) (None, 512) 401920 _________________________________________________________________ dropout_1 (Dropout) (None, 512) 0 _________________________________________________________________ dense_2 (Dense) (None, 512) 262656 _________________________________________________________________ dropout_2 (Dropout) (None, 512) 0 _________________________________________________________________ dense_3 (Dense) (None, 10) 5130 ================================================================= Total params: 669,706 Trainable params: 669,706 Non-trainable params: 0 _________________________________________________________________ Train on 60000 samples, validate on 10000 samples Epoch 1/20 D:\\Program Files\\Anaconda3\\envs\\cntk-py35\\lib\\site-packages\\cntk\\core.py:361: UserWarning: your data is of type \u0026#34;float64\u0026#34;, but your input variable (uid \u0026#34;Input75\u0026#34;) expects \u0026#34;\u0026lt;class \u0026#39;numpy.float32\u0026#39;\u0026gt;\u0026#34;. Please convert your data beforehand to speed up training. (sample.dtype, var.uid, str(var.dtype))) 60000/60000 [==============================] - 4s - loss: 0.2464 - acc: 0.9248 - val_loss: 0.1097 - val_acc: 0.9653 Epoch 2/20 60000/60000 [==============================] - 3s - loss: 0.1035 - acc: 0.9681 - val_loss: 0.0843 - val_acc: 0.9744 Epoch 3/20 60000/60000 [==============================] - 3s - loss: 0.0742 - acc: 0.9776 - val_loss: 0.0872 - val_acc: 0.9764 Epoch 4/20 60000/60000 [==============================] - 3s - loss: 0.0607 - acc: 0.9822 - val_loss: 0.0688 - val_acc: 0.9804 Epoch 5/20 60000/60000 [==============================] - 3s - loss: 0.0502 - acc: 0.9851 - val_loss: 0.0863 - val_acc: 0.9781 Epoch 6/20 60000/60000 [==============================] - 3s - loss: 0.0424 - acc: 0.9874 - val_loss: 0.0828 - val_acc: 0.9801 Epoch 7/20 60000/60000 [==============================] - 3s - loss: 0.0369 - acc: 0.9890 - val_loss: 0.0758 - val_acc: 0.9812 Epoch 8/20 60000/60000 [==============================] - 3s - loss: 0.0367 - acc: 0.9895 - val_loss: 0.0840 - val_acc: 0.9825 Epoch 9/20 60000/60000 [==============================] - 3s - loss: 0.0338 - acc: 0.9903 - val_loss: 0.1029 - val_acc: 0.9782 Epoch 10/20 60000/60000 [==============================] - 3s - loss: 0.0313 - acc: 0.9912 - val_loss: 0.0837 - val_acc: 0.9827 Epoch 11/20 60000/60000 [==============================] - 3s - loss: 0.0273 - acc: 0.9919 - val_loss: 0.1013 - val_acc: 0.9808 Epoch 12/20 60000/60000 [==============================] - 3s - loss: 0.0277 - acc: 0.9925 - val_loss: 0.0921 - val_acc: 0.9827 Epoch 13/20 60000/60000 [==============================] - 3s - loss: 0.0252 - acc: 0.9931 - val_loss: 0.0900 - val_acc: 0.9832 Epoch 14/20 60000/60000 [==============================] - 3s - loss: 0.0268 - acc: 0.9931 - val_loss: 0.1035 - val_acc: 0.9830 Epoch 15/20 60000/60000 [==============================] - 3s - loss: 0.0233 - acc: 0.9940 - val_loss: 0.1280 - val_acc: 0.9797 Epoch 16/20 60000/60000 [==============================] - 3s - loss: 0.0243 - acc: 0.9942 - val_loss: 0.0998 - val_acc: 0.9830 Epoch 17/20 60000/60000 [==============================] - 3s - loss: 0.0222 - acc: 0.9942 - val_loss: 0.1011 - val_acc: 0.9849 Epoch 18/20 60000/60000 [==============================] - 3s - loss: 0.0205 - acc: 0.9946 - val_loss: 0.1111 - val_acc: 0.9830 Epoch 19/20 60000/60000 [==============================] - 3s - loss: 0.0201 - acc: 0.9951 - val_loss: 0.1302 - val_acc: 0.9801 Epoch 20/20 60000/60000 [==============================] - 3s - loss: 0.0206 - acc: 0.9952 - val_loss: 0.1181 - val_acc: 0.9827 Test loss: 0.11807218486 Test accuracy: 0.9827 安装 Tensorflow Tensorflow虽然没有提供安装即可用的安装包，但是它可以通过pip和conda来安装，也是非常方便的，直接pip install tensorflow-gpu即可。如果想避免CNTK和Tensorflow相互影响，可以专门为Tensorflow也开一个环境。\nTensorflow的GPU版本需要CUDA和CuDNN的支持，这个是pip无法安装的。独立安装CUDA和CuDNN需要从NVIDIA官网注册下载，也是很麻烦，但而由于CNTK里面是带这两个东西的，因此只需要把PATH设置到CNTK下面即可，非常方便！具体方式是在环境变量PYTHONPATH中添加\u0026lt;CNTK目录\u0026gt;\\cntk，如果原本没有PYTHONPATH这个变量就新建一个。\n这样，Tensorflow也很快就安装完成了，修改Keras的后端跑一个测试结果如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 (tf-py35) C:\\Users\\Jacob\u0026gt;python C:\\Users\\Jacob\\Downloads\\mnist_mlp.py Using TensorFlow backend. 60000 train samples 10000 test samples _________________________________________________________________ Layer (type) Output Shape Param # ================================================================= dense_1 (Dense) (None, 512) 401920 _________________________________________________________________ dropout_1 (Dropout) (None, 512) 0 _________________________________________________________________ dense_2 (Dense) (None, 512) 262656 _________________________________________________________________ dropout_2 (Dropout) (None, 512) 0 _________________________________________________________________ dense_3 (Dense) (None, 10) 5130 ================================================================= Total params: 669,706 Trainable params: 669,706 Non-trainable params: 0 _________________________________________________________________ Train on 60000 samples, validate on 10000 samples Epoch 1/20 2017-11-19 11:17:30.732744: I C:\\tf_jenkins\\home\\workspace\\rel-win\\M\\windows-gpu\\PY\\35\\tensorflow\\core\\platform\\cpu_feature_guard.cc:137] Your CPU supports instructions that this TensorFlow binary was not compiled to use: AVX AVX2 2017-11-19 11:17:31.701106: I C:\\tf_jenkins\\home\\workspace\\rel-win\\M\\windows-gpu\\PY\\35\\tensorflow\\core\\common_runtime\\gpu\\gpu_device.cc:1030] Found device 0 with properties: name: GeForce GTX 850M major: 5 minor: 0 memoryClockRate(GHz): 0.8625 pciBusID: 0000:01:00.0 totalMemory: 2.00GiB freeMemory: 1.65GiB 2017-11-19 11:17:31.701257: I C:\\tf_jenkins\\home\\workspace\\rel-win\\M\\windows-gpu\\PY\\35\\tensorflow\\core\\common_runtime\\gpu\\gpu_device.cc:1120] Creating TensorFlow device (/device:GPU:0) -\u0026gt; (device: 0, name: GeForce GTX 850M, pci bus id: 0000:01:00.0, compute capability: 5.0) 60000/60000 [==============================] - 122s 2ms/step - loss: 0.2460 - acc: 0.9233 - val_loss: 0.1317 - val_acc: 0.9590 Epoch 2/20 60000/60000 [==============================] - 6s 96us/step - loss: 0.1023 - acc: 0.9698 - val_loss: 0.0881 - val_acc: 0.9745 Epoch 3/20 60000/60000 [==============================] - 6s 95us/step - loss: 0.0762 - acc: 0.9768 - val_loss: 0.0823 - val_acc: 0.9744 Epoch 4/20 60000/60000 [==============================] - 5s 91us/step - loss: 0.0612 - acc: 0.9811 - val_loss: 0.0812 - val_acc: 0.9761 Epoch 5/20 60000/60000 [==============================] - 6s 98us/step - loss: 0.0514 - acc: 0.9845 - val_loss: 0.0734 - val_acc: 0.9813 Epoch 6/20 60000/60000 [==============================] - 6s 102us/step - loss: 0.0454 - acc: 0.9866 - val_loss: 0.0783 - val_acc: 0.9818 Epoch 7/20 60000/60000 [==============================] - 6s 93us/step - loss: 0.0388 - acc: 0.9884 - val_loss: 0.0871 - val_acc: 0.9797 Epoch 8/20 60000/60000 [==============================] - 6s 95us/step - loss: 0.0354 - acc: 0.9896 - val_loss: 0.0918 - val_acc: 0.9813 Epoch 9/20 60000/60000 [==============================] - 6s 96us/step - loss: 0.0330 - acc: 0.9906 - val_loss: 0.0859 - val_acc: 0.9800 Epoch 10/20 60000/60000 [==============================] - 6s 103us/step - loss: 0.0308 - acc: 0.9915 - val_loss: 0.0898 - val_acc: 0.9812 Epoch 11/20 60000/60000 [==============================] - 5s 89us/step - loss: 0.0261 - acc: 0.9924 - val_loss: 0.0975 - val_acc: 0.9824 Epoch 12/20 60000/60000 [==============================] - 6s 103us/step - loss: 0.0266 - acc: 0.9925 - val_loss: 0.0906 - val_acc: 0.9848 Epoch 13/20 60000/60000 [==============================] - 6s 102us/step - loss: 0.0248 - acc: 0.9934 - val_loss: 0.0907 - val_acc: 0.9834 Epoch 14/20 60000/60000 [==============================] - 6s 96us/step - loss: 0.0224 - acc: 0.9939 - val_loss: 0.1088 - val_acc: 0.9811 Epoch 15/20 60000/60000 [==============================] - 6s 97us/step - loss: 0.0217 - acc: 0.9938 - val_loss: 0.0973 - val_acc: 0.9818 Epoch 16/20 60000/60000 [==============================] - 6s 97us/step - loss: 0.0202 - acc: 0.9946 - val_loss: 0.1075 - val_acc: 0.9819 Epoch 17/20 60000/60000 [==============================] - 6s 99us/step - loss: 0.0197 - acc: 0.9947 - val_loss: 0.1218 - val_acc: 0.9815 Epoch 18/20 60000/60000 [==============================] - 6s 96us/step - loss: 0.0208 - acc: 0.9945 - val_loss: 0.1131 - val_acc: 0.9832 Epoch 19/20 60000/60000 [==============================] - 6s 93us/step - loss: 0.0190 - acc: 0.9949 - val_loss: 0.1285 - val_acc: 0.9805 Epoch 20/20 60000/60000 [==============================] - 6s 94us/step - loss: 0.0185 - acc: 0.9955 - val_loss: 0.1153 - val_acc: 0.9833 Test loss: 0.115294696707 Test accuracy: 0.9833 （可以看出Tensorflow比CNTK要慢不少）\n","date":"2017-09-21T00:00:00Z","permalink":"https://zyxin.xyz/blog/2017-09/InstallCNTKKeras/","title":"Windows10下配置Keras + CNTK (GPU) + Tensorflow (GPU)"},{"content":"在阅读VTK和QT的源码时，遇到了类似于Python中特殊变量形式的宏，如__LINE__和__FILE__，这两个宏的用途是作为函数参数返回调用行数和文件名。一时惊奇，原来C里面也有这个内置宏，而且貌似在各大库的Debug模块中都经常被用到。此外也碰到了变长的宏的用法，于是查了一下标准中对宏的描述，做一下笔记，对宏代码很有帮助~\n文中点击标题的角标即可转到GCC文档对应页面。\nStringizing1 (字符串化) 在宏定义中可以将传入的参数原封不动地变成字符串常量插入代码中，使用的方法是利用#运算符。例如下面的宏\n1 2 3 4 5 #define WARN_IF(EXPR) \\ do { if (EXPR) \\ fprintf (stderr, \u0026#34;Warning: \u0026#34; #EXPR \u0026#34;\\n\u0026#34;); } \\ while (0) WARN_IF (x == 0); 其中#EXPR便是字符串化的参数，在编译时会变成\n1 2 3 do { if (x == 0) fprintf (stderr, \u0026#34;Warning: \u0026#34; \u0026#34;x == 0\u0026#34; \u0026#34;\\n\u0026#34;); } while (0); 会输出Warning: x == 0。这一特性可以使得使用宏定义的时候同时输出参数名字或者表达式，便于进行记录。此时若x本身也是宏的话在#EXPR中不会展开。如果想让宏x在#EXPR中也展开的话，需要再用另一个宏把这个宏包起来即可。\nConcatenation2 (符号连接) 有时候向宏内传入的参数不完全是你想要的参数，或者希望通过一个参数展开成多个变量的时候，就可以使用符号连接的宏，使用方法是利用##运算符。例如假设有一个储存命名函数的结构体\n1 2 3 4 5 struct command { char *name; void (*function) (void); }; 使用下面的宏可以简洁方便地定义多个结构体\n1 2 3 4 5 6 7 #define COMMAND(NAME) { #NAME, NAME ## _command } struct command commands[] = { COMMAND (quit), COMMAND (help), }; 其中NAME ## _command的作用就是在NAME展开后在末尾加上_command，避免直接连接会导致宏无法被识别的现象。展开后得到\n1 2 3 4 5 struct command commands[] = { { \u0026#34;quit\u0026#34;, quit_command }, { \u0026#34;help\u0026#34;, help_command }, }; Variadic Macros3 (可变参数的) 可变参数的用法与普通代码中的可变参数用法是一致的，即通过对最后一个参数进行特殊声明来让这个宏可以接受变长的参数。举例如下：\n1 2 #define eprintf(…) fprintf (stderr, __VA_ARGS__) #define eprintf(args…) fprintf (stderr, args) 这两个宏的展开效果是一样的，如果在代码中插入\n1 eprintf (\u0026#34;%s:%d: \u0026#34;, input_file, lineno) 则会展开成\n1 fprintf (stderr, \u0026#34;%s:%d: \u0026#34;, input_file, lineno) 从上面的代码可以看出，如果使用...来表示变长参数，那么在宏定义中就用预定义宏变量__VA_ARGS__来代表这些参数，如果是在某一个参数名的后面加上...，那么就是用将这个参数变成变长参数。\n另外，变长参数之前可以有普通的参数，如\n1 #define eprintf(format, …) fprintf (stderr, format, __VA_ARGS__) 不过需要注意的是，在标准C中这样的情况下变长参数至少需要输入一个参数，否则在转义时参数末尾会多一个逗号。即eprintf(\u0026quot;success!\\n\u0026quot;, );会变成fprintf(stderr, \u0026quot;success!\\n\u0026quot;, );。在GNU CPP中这个问题可以通过在__VA_ARGS__前面加上##符号来解决。\nPredefined Macros4 (预定义的宏) 在标准中有提供一些内置的宏，可以给调试提供很多方便~\n__FILE__：当前文件的路径名 __LINE__：调用处的行号 __func__(C99)/__FUNCTION__(GCC)：调用处所属的函数名 __DATE__：处理器上当前的日期 __TIME__：处理器上当前的时间 __STDC_VERSION__：C标准的版本，例如C11标准下会展开成201103 __cplusplus：在C++编译器时会被定义，展开结果同__STDC_VERSION__ 其他还有很多的不在标准中的预定义的宏，具体可以查看编译器的说明。其中GNU C的预定义宏可以参考Common Predefined Macros Directives Within Macro Arguments5 (在宏参数里修改宏) GNU编译器还提供了在展开宏的参数时修改宏的功能。。。这个功能非常少用，先举个病态的例子：\n1 2 3 4 5 #define f(x) x x f (1 #undef f #define f 2 f) 这一段语句展开后得到的结果是1 2 1 2，这就是在参数中修改宏。但是这个宏非常影响阅读，太tricky了，最好还是别用。\nGCC文档中的Stringizing部分\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nGCC文档中的Concatenation部分\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nGCC文档中的Variadic部分\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nGCC文档中的预定义宏\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nGCC文档中Directives部分\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2017-09-20T00:00:00Z","permalink":"https://zyxin.xyz/blog/2017-09/SpecialMacrosInCpp/","title":"C/C++中的特殊宏"},{"content":"Minecraft之所以能这么火热，一方面是因为是开发得较早的沙盒游戏，另一方面则是Minecraft庞大的Mod（Modification，中文称模组）数量，Mod生态环境非常棒！这篇文章里就稍微介绍一下Minecraft的Mod吧~（Mod具体怎么使用直接搜索就行）\n介绍的主要是客户端的Mod，服务端的Mod由于没有开过服，知道的很少，就不在这写了~\nMod资源 MC的Mod这么多，在哪里去找呢？不外乎两种方式，一种是知道Mod的名字的话就可以直接搜索，如果不知道的话就需要去整合Mod的资源站去找了：\n论坛中的Mod板块：MinecraftForum / MCBBS / MinecraftUser Mod整合站: Hzyswiki / MCMod / Curse1 （其中Curse是维护MCWiki托管站Gamepedia的公司） 这里推荐一下MCMod，里面有很多小功能，比如神秘研究帮助、模组关系图等。 核心Mod介绍 有三大Mod是几乎每一个Mod玩家以及Mod整合包都会安装的：\nForge: 最常用的模组加载器(Modloader)，是大量Mod的基础Mod，抽象出了一套Mod接口。 Liteloader: 最常用的加载器之二，被不少UI相关的Mod所用。可以与Forge共存，只需在Forge之后安装即可。 Optifine：高清修复。不仅仅是高清，而且还有帧速的提升，以及在1.9之后把光影核心也加入了其中。也就是现在如果要加载光影包只需要安装Optifine即可。如果是1.9之前的版本加载光影的话还需要安装ShadersMod这个光影模组。 世界观Mod推荐 Minecraft的Mod里面有很大一部分是工具类的Mod，比如小地图、物品整理、创世神等；另一大部分则是给Minecraft加了自定义的方块、物品，如和风、枪战、IC等。这些Mod我不会推荐给大家，因为一方面这一类Mod可能会导致Minecraft难度下降，自动化程度过高，另一方面是这种Mod实在数量太多。。每种Mod都有很多相似的替代品。。\n工具类的Mod个人认为只需要一个地图和一个物品整理就可以了。个人用的是Rei\u0026rsquo;s Minimap和Inventory Tweak，不过有人十分推荐Journey Map和Not enough items，我没有试过。\n我觉得十分难得的是给Minecraft加入新的世界观的Mod，这些Mod的内容丰富，并且可以带来不一样的Minecraft体验。当然这一类Mod也比较大，内容丰富到可能能玩半年，但这也正是乐趣所在！~\n神秘时代 - Thaumcraft 神秘时代是一个十分著名的Mod，为游戏加入了魔法元素（称为要素）与炼金系统，魔法与炼金系统的设计十分有趣，并且良心的是作者一直在更新，加入新的魔法要素。最棒的是Mod里面自带一份指南（魔导手册），随着不断的学习能够解锁新的知识，这个过程非常容易产生满足感！炼金体系的平衡性设计的也不错，强大的物品消耗的物品和要素也十分惊人。此外这个Mod还衍生出很多其他的Mod，总之非常值得一试！\n以太 - Aether 以太是一个老牌的Minecraft世界模组，在Wiki中都有介绍。以太新增了浮空岛的世界，它的定位是与下界（地狱）相反的天堂，加入了很多天堂动物，天堂的景色也非常不错，如果站在浮空岛边缘不小心掉下去了还会掉回主世界233。此外还在天堂增加了地牢，里面错综复杂难度不小，是一个冒险元素挺强的模组。\n暮光森林 - The Twilight Forest 暮光森林Mod加入了暮光森林世界，这个世界美丽而宁静，比原版的森林群系更像真正的森林。这个世界里有很多生物群系，如彩色的冰川等等，也是一个冒险元素比较浓厚的Mod。暮光森林里面也有类似于地牢的存在，不过是以塔的形式矗立在森林之中。总而言之这个模组最吸引我这个外貌协会成员的还是里面美好的风景啦~\n其他Mod Mod分很多很多种，如功能拓展、HUD增强、多样生物群系，还有更为复杂的工业、能源、物流Mod（如著名的工业时代2 - IC2）。仅仅是创造世界观的Mod也有很多很多，我也只玩过一部分，下面是另一些我没有玩过的Mod，也列在这里了：\n魔戒 - The Lord of Ring 火箭 - Advanced Rocketry：这货可以带你上太空o,o 巫师 - Witchery 热带 - Tropicraft \u0026hellip; 这一类Mod在Curse中被分为Adventure and RPG，可以去这里面淘优秀的模组~\n更多Mod推荐可以参考知乎里的两个问题：https://www.zhihu.com/question/41743331 和 https://www.zhihu.com/question/31954440\nCurse Mod的官网旧地址是https://mods.curse.com/mc-mods/minecraft\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2017-09-13T00:00:00Z","image":"https://zyxin.xyz/blog/2017-09/MCMods/aetherII.png","permalink":"https://zyxin.xyz/blog/2017-09/MCMods/","title":"Minecraft - MOD杂谈"},{"content":"从美帝回来以后终于可以用上宿舍的大屏， 但是却发现显示器插在笔记本上又不显示了。。。这个问题在上学期也遇到过，当时还一度以为是电脑的接口烧了，摆弄了好几天没能用上显示器，给科技服务队也没能弄好，最后还是狠心尝试把驱动卸了才成功= =前前后后折腾了一周，非常头疼，在这把解决方案贴出来供参考。。。\n环境 OS：Windows 10 1607/1703 集显：Intel HD Graphics 4600 独显：NVIDIA GeForce GTX 850M 外显：AOC Q2577W 显卡驱动版本：Intel 15.40.20 / NVIDIA 376.54 问题描述 这两次出现的毛病都是插上显示器能够检测到显示器但是无法使用它，具体表现为你无论开复制还是扩展模式都还是显示在原来的显示器上（即笔记本自带的显示器上），外接显示器则一直黑屏。该问题出现在Windows10系统上，但我怀疑也可能会出现在其他Windows版本上。\n具体的两个特征有：\n右键桌面打开显示设置可以发现有多个显示器（大于实际的显示器数量）。例如加上外接的显示器我的笔记本一共就两个显示器，但是却显示为6个。 在设备管理器中查看“监视器”时会发现除了自带的和外接的显示器之外多出了四个“通用非即插即用监视器”。 Intel的“英特尔核心显卡控制面板”无法打开。 解决方案 按理来说最开始想到的方案就是安装最新驱动，但是实际尝试以后发现两个显卡都更新驱动以后仍然没有改变。后来便怀疑是硬件问题，但想想能识别到外接显示器应该是没有硬件损坏的。最后心惊胆战地卸载了集显的驱动意外地就好了。。。\n问题原因处在Intel翔一般的集显驱动上，两次出现这个问题都是在系统大版本更新之后，前一次是1511到1607，这次是1607到1703，更新系统时会强制把显卡驱动一起更新掉，而这个问题刚好就是因为新版Intel显卡驱动的某BUG，并且一直没修复。笔记本电脑的外接显示接口一般是集显的接口，因此改动N卡驱动是没用的。上一次解决这个问题时，搜索这个问题发现了一个回答说是因为Intel的锅，具体的帖子已经找不到了。\n解决方法就是卸载新版的集显驱动，装回老版的驱动。如果这个问题是手动更新驱动造成的话，应该卸载驱动之后就直接可以使用外接显示器了，而如果是系统更新造成的话则还要装回老版的显卡驱动。15年的Intel显卡驱动亲测可用，如果官网的连接找不到了的话可以使用我下载的版本1。\n如果想避免之后因为驱动更新再次造成这个问题的话可以禁用Intel显卡的驱动更新。禁止方法参见这篇百度经验：\n设备管理器 → “显示适配器” → 集显显卡 → 右键点击属性 → “详细信息”选项卡 → “类Guid”属性 → 记录下GUID 打开本地组策略编辑器（Win+R → 输入gpedit.msc） → “计算机配置” → “管理模板” → “系统” → “设备安装” → “设备安装限制” → “阻止安装与下列任何设备ID相匹配的设备” → 右键点击编辑 → 启用，并点击“显示”按钮输入上面记录的GUID 如果想重新允许驱动安装，可以直接禁用这个策略，也可以把同一个策略组的“允许管理员忽略设备安装限制策略”启用。后一种方法可以避免重新输入GUID。\n参考资料 Intel论坛上一个相似问题的帖子 StackExchange上的帖子 15.40.4\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2017-09-12T00:00:00Z","permalink":"https://zyxin.xyz/blog/2017-09/IntelMultiDisplayer/","title":"如何解决Intel集显笔记本插外接显示器时，外接显示器识别但不可用的问题"},{"content":" 这篇文章里的设计方案都是我从视频中以及MC论坛里看到的，非原创。\n人肉大炮是MC里面有趣的娱乐活动之一，尤其是当你的刷怪塔收获了很多火药而没地方用的时候2333。人肉大炮的原理不复杂，简而言之就是一堆围绕你的TNT炸了以后把你送上高空。TNT在水里炸的时候不会产生伤害，因此可以在生存模式玩，但是请注意，从高空摔下来的时候你是会摔死的！因此最好在湖边或海边建造人肉大炮。\n人肉大炮有两种，一种是射高，一种是射远~但天空是人类的梦想，因此本文还是主要讲述向上发射的人肉大炮，横向和斜向发射的大炮本文就不介绍了~\nNaive版 最最简单的人肉大炮的结构图如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 {% minecraft 俯视图 %} |----|- |ab|ab|ab|ab|ab|- |ab|tnt|tnt|tnt|ab|- |ab|tnt|wa |tnt|ab|- |ab|tnt|tnt|tnt|ab|- |ab|ab|ab|ab|ab|- |----|- |rd-se|rd-ew|wb-$n|rd-ew|rd-sw|- |rd-ns| | | |rd-ns|- |rd-ns| | | |rd-ns|- |rd-ns| | | |rd-ns|- |rd-ne|rd-ew|rd-ew|rd-ew|rd-nw|- {% endminecraft %} 填充完TNT以后，站在水中按下开关，八个TNT一起爆炸瞬间让你扶摇直上，把你推上60+的高度！2333\n双层大炮 简单的改进就是在第二层也放上TNT，变成双层大炮。由于这种情况下第一层没法通过上面的布线方式来引燃TNT，因此体积会稍微扩大一点。点燃TNT用两种方法，一种是强充能TNT相邻的方块，另一种是用含有打火石的发射器对着TNT，然后激活发射器就能引燃TNT。处于成本考虑，本方案使用中继器充能的方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 {% minecraft 俯视图 %} |----|- ||||ab||||||- ||||rd-nse|rd-sew|rd-sw||||- |rd-se|rd-ew|rr-w1|rd-nw|rr-s1|rd-ne|rr-e1|rd-ew|rd-sw|- |rd-ns| |ab |ab |ab |ab |ab | |rd-ns|- |rd-nse|rr-e1|ab |tnt |tnt |tnt |ab |rr-w1|rd-nsw|- |rd-nse|rr-e1|ab |tnt |wa |tnt |ab |rr-w1|rd-nsw|- |rd-ns| |ab |tnt |tnt |tnt |ab | |rd-ns|- |rd-ns| |ab |ab |ab |ab |ab | |rd-ns|- |rd-ns| | |rr-n1|rr-n1|rr-n1| | |rd-ns|- |rd-ne|rd-ew|rd-ew|rd-new|rd-new|rd-new|rd-ew|rd-ew|rd-nw|- |----|- ||||rd-se|ab|||||- |||||ab|||||- |||||ab|||||- |||ab|ab|ab|ab|ab|||- |||ab|tnt|tnt|tnt|ab|||- |||ab|tnt||tnt|ab|||- |||ab|tnt|tnt|tnt|ab|||- |||ab|ab|ab|ab|ab|||- |----|- |||||rd-sw|||||- |||||rd-ns|||||- |||||rr-s2|||||- |||rd-se|rd-ew|rd-new|rd-ew|rd-sw|||- |||rd-ns||||rd-ns|||- |||rd-ns||||rd-ns|||- |||rd-ns||||rd-ns|||- |||rd-ne|rd-ew|rd-ew|rd-ew|rd-nw|||- |----|- ||||||||||- |||||ab|||||- |||||wb-n|||||- {% endminecraft %} 站在水里按下按钮即可起飞(误。这个方案的发射高度可达250+，十分高效~不过如果嫌在中间按按钮不方便的话，可以把第一层的水换成石头，然后在上方放上水。但是这样会损失一些发射高度。\n堆叠大炮 实际上对于上面形式的炮，飞的高度与同时爆炸的TNT数量有关，因此可以通过堆叠TNT来达到增加炮的高度的目的~\n具体的堆叠方式见下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 {% minecraft 俯视图 %} |----|- ||ab|ab|||- ||ab||||- |ab|ab|ab|ab|ab|- |ab|tnt|tnt|tnt|ab|- |ab|tnt|wa |tnt|ab|- |ab|tnt|tnt|tnt|ab|- |ab|ab|ab|ab|ab|- |----|- |ts|rd-sew|wb-$n|||- ||rr-s1||||- |rd-se|rd-new|rd-ew|rd-ew|rd-sw|- |rd-ns||||rd-ns|- |rd-ns||||rd-ns|- |rd-ns||||rd-ns|- |rd-ne|rd-ew|rd-ew|rd-ew|rd-nw|- |----Level 2k|- |rd-ew|ts+→||||- ||ts||||- |ab|ab|ab|ab|ab|- |ab|tnt|tnt|tnt|ab|- |ab|tnt| |tnt|ab|- |ab|tnt|tnt|tnt|ab|- |ab|ab|ab|ab|ab|- |----Level 2k+1|- |ts|rd-sw||||- ||rr-s1||||- |rd-se|rd-new|rd-ew|rd-ew|rd-sw|- |rd-ns||||rd-ns|- |rd-ns||||rd-ns|- |rd-ns||||rd-ns|- |rd-ne|rd-ew|rd-ew|rd-ew|rd-nw|- {% endminecraft %} 堆叠有效的关键是需要在同一时刻点燃TNT，所以当堆叠很高时，会需要通过中继器来延长信号，此时中继器会产生1tick的延时，因此在低层需要额外增加中继器的延时。这个时候就可以沿箭头方向绕着延长某一层的红石输入，并在其中加入足够的中继器即可，如下所示。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 {% minecraft 俯视图 %} |----Level 2k（延时）|- |rd-ew|ts|ts|ts|ts|ts|- ||||||ts|- |ab|ab|ab|ab|ab|ts|- |ab|tnt|tnt|tnt|ab||- |ab|tnt| |tnt|ab||- |ab|tnt|tnt|tnt|ab||- |ab|ab|ab|ab|ab||- |----Level 2k+1（延时）|- |ts|rd-ew|rr-e4|rr-e4|rr-e4|rd-sw|- ||||||rr-s1|- |rd-se|rd-ew|rd-ew|rd-ew|rd-sew|rd-nw|- |rd-ns||||rd-ns||- |rd-ns||||rd-ns||- |rd-ns||||rd-ns||- |rd-ne|rd-ew|rd-ew|rd-ew|rd-nw||- {% endminecraft %} 至于堆叠的高度与大炮射程的关系，由于TNT点燃后掉落方向是随机的，因此大炮射的高度每次也不一样。我做了一个小试验，1~4层堆叠，每种两组，一组静止发射10次，一组边跳边发射10次。（边跳边发射的话能够射得更高，如果在快到跳的最高点时被发射，高度就能显著增加！）试验中，每次发射时都通过/tp命令传送到TNT炮塔的中心，以避免站位的影响。（站位偏了的话会造成向上射变成斜射，影响高度。）试验结果如下：\n图中绿色三角为均值。可以发现TNT层数（可以按一层8个换算成个数）与发射高度并不呈完全线性的关系，当TNT较多时，发射高度的增加会变快。\n这个方案的炮塔堆叠不能无限高，因为TNT激活后掉落到底部的池子里是需要花时间的，如果炮塔太高，则可能导致TNT没有落进池子便爆炸，这不仅会浪费TNT，还会造成爆炸破坏（不在水里的TNT是有爆炸伤害的）。根据试验，大概堆叠个36层（72格高）就不能再堆了，再高TNT就会在控制爆炸。当然，这个堆叠型的炮塔还能够更加密集，把两侧之间的空隙也用TNT填上，然后交替用前面提到的两种方法激活TNT就能够做到更加密集的TNT爆炸，不过线路会复杂很多。\n堆叠方案有两个缺点，一个是在生存模式下装填比较麻烦，二是塔较高的时候进到发射位置就比较麻烦，可以考虑从地下开通道过去。\n飞的更高 如果你想让你的大炮射得更高，还有一下这些方法来改进~\n扩大TNT的形状（不是3x3，而是3x4或者分布式的炸药之类的~） 用其他方法堆叠TNT，以在有限时间内堆叠更多的TNT。（例如使用漏斗矿车） 二次推进：先用一个小炮打到一定高度，再用大炮打上天。这样可以让你在进入大炮时有一定初速度~（见Youtube上的案例） 更复杂的大炮就自行创造啦~如果是服务器生存，这样最基本的大炮已经够玩掉不少火药了233。\n","date":"2017-09-01T00:00:00Z","permalink":"https://zyxin.xyz/blog/2017-09/MCHumanCannon/","title":"Minecraft - 人肉大炮"},{"content":"养鸡大概是Minecraft里面最省事的养殖业了，只要有鸡蛋就能砸出小鸡，只要有小鸡就能生鸡蛋。不像牵个牛一样还得奔袭万里，甚至遇见夜里把自己埋一晚第二天牛就不见的尴尬。养鸡尽管可以很简单，但是最爽的还是做一个完全自动的养鸡场，砸鸡蛋捡鸡蛋甚至杀鸡都不用自己亲自动手，这是坠吼的！\n一个全能型的全自动的养鸡场大概分为如下几个模块：自动收集、鸡蛋传递系统、自动鸡蛋发射器、自动杀鸡器等，下面挨个介绍一下每一个模块的红石结构，以及最终的完整集成结构。\n自动收集 自动收集是养鸡场最基本的功能。养鸡场的典型建法是把鸡困在一个格子内，然后在鸡的脚底放上下半砖，下方放上漏斗收集鸡蛋。使用半砖的目除了防止鸡跑出来以外，是为了在杀鸡时让成熟的鸡被杀掉而小鸡不被影响到。这是因为小鸡的碰撞箱高度小于等于半格。因此只要它不乱跳就不会被杀\n典型的鸡圈的结构如下图\n1 2 3 4 5 {% minecraft 俯视图 %} |ab|C|ab|- |glass|slab|glass|- ||ho-$n||- {% endminecraft %} 玻璃用来观察鸡的情况，C处就是鸡所在的地方，可以往这个地方砸鸡蛋。这样的结构在后文就简称鸡圈了。\n鸡蛋传递系统 鸡蛋传递系统在鸡场里起到的作用是，将鸡生出来的鸡蛋传送到发射器中自动砸成小鸡。由于砸小鸡需要在鸡圈的上方，因此需要一个将物品向上传递的系统。由于漏斗不能向上放置，因此需要别的方法来实现这个目的。\n向上传递物品有两种方式，一种是利用投掷器能向容器里传递物品的特性，另一种是利用方块会把物品“挤”到最顶端的特性。由于养鸡场砸鸡蛋只需要向上传递3格，因此也就以3格为例，传递更高的方案可以同理搭建出来。\n投掷器塔 投掷器按照向上发射的方向摆成塔，然后通过红石信号依次激活他们即可做到向上传递。具体结构如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 {% minecraft 俯视图 %} |----|- |ts|rd-ew|rd-ew|rt-e|ab|rd|- |rd-ns|rr-s1|ab|ab|rd-!|ab|- |rd-ns|dr-u|ho-w|st|st|st|- |ab|rc-s|ab|ab|rr-n1!|ab|- ||ab|rt-w!|rd-ew!|rd-nw!||- |----|- |rd-se|ts||ab|rr-e2|ab|- ||st|st|st|st|st|- ||dr-u||←|←|←|- |rt-!|st|st|st|st|st|- |----|- ||rd-sw|||||- ||rr-s2|||||- ||dr-u|||||- |ab||||||- |----|- |||||||- |||||||- ||dr-u|st|st|st|st|- |rt||||||- |----|- |||||||- ||st|st|st|st|st|- ||dr-u|→|→|→|→|- |ab|ab|st|st|st|st|- |----|- |||||||- |||||||- |||||||- |rd-ew|rd-ew|||||- {% endminecraft %} 这种方案成本较高，但重在噪声小。\n平滑的石头代表与红石无关的方块，箭头指的方向是物品移动的方向。物品的移动可以通过流水（部分方块就是为流水设计的），也可以通过漏斗管道来移动（可以去掉一些方块），但是会进一步提高成本。\n方块挤压 如果将九宫格中周围八格都放上石头，终中间丢一个物品，那么在往中间放上石头后物品会被挤压而浮到玻璃上面。利用方块的这个特性就可以制作一个向上传递的机构。结构如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 {% minecraft 俯视图 %} |----|- ||||- ||sp-u|sp-u|- ||rr-n4|rr-n2|- |----|- ||||- ||ab|ab|- |----|- |ab|ab|ab|- |ab|U|←|- |ab|ab|ab|- |----Level4 ~ Level(n-1)|- |ab|ab|ab|- |ab|ab|ab|- |ab|ab|ab|- |----Leveln|- |ab|ab|ab|- |ab|U|→|- |ab|ab|ab|- {% endminecraft %} 这个方案看起来很没有技术含量，但确实是最简单省事，并且最省材料的方案。同样的，箭头代表物品移动的方向，U为物品上行的地方。比较器需要通入周期信号以不停地传输物品，如果用水流移动物品周期最好为1s（10Tick）左右，而如果是漏斗管道+投掷器则可以短一点。\n需要注意的是，收集鸡蛋和收集杀鸡的产物都通过同一个漏斗，因此其实在鸡蛋传递系统之前应该还要加一个物品分流装置。物品分流通过活塞实现比较麻烦，因此一般是通过改变水的流向来改变。改变水流方向十分简单，在这里就不叙述了。\n自动发射器 自动发射器把收集到的鸡蛋砸到鸡圈里，生出新的小鸡，进行可持续发展。这个自动发射装置的原理我在[小麦塔教程]({{ ref \u0026ldquo;MCTowerWheat\u0026rdquo; }})中的漏斗转移装置中有讲到，只需要用比较器获取容器中是否含有物品，再接上高频时钟即可。这里也略过了。\n自动杀鸡器 杀死鸡有两种方法，一种是用实心方块填充鸡圈，使得鸡窒息而死，另一种则是利用岩浆烧死鸡。自动杀鸡的装置需要在养鸡之前就设计好，不然后加就比较麻烦。\n窒息 使鸡窒息的操作非常简单，只需要用一个粘性活塞将实心方块推到上文提到的鸡圈结构中的C位置即可使鸡窒息而死。因此只需要一个开关、一个活塞、一个方块，或者多加一个自动复位的计时器，就可以实现这个功能了~\n窒息杀死的鸡会掉落生鸡肉和羽毛。\n岩浆烧死 岩浆烧死稍微麻烦一点，因为岩浆不能一直放在鸡圈里，而是需要杀鸡的时候才放出来。这个可以通过发射器来实现，当发射器中有一个岩浆桶的时候，给发射器一个信号它就能喷出一格岩浆，再给一次信号即可收回。而杀鸡时需要在喷出岩浆后立即收回，否则可能会把杀鸡的收获物都烧掉。这个需要通过脉冲信号来实现。\n脉冲发生器对发射器以及投掷器非常有用，因为经常会出现需要让发射电路迅速复位的情况。此外，脉冲发生器还是大量数字电路的组成部分，产生触发信号。\n脉冲发生器的基本结构在MCWiki里有明确讲到，如果需要产生单次脉冲，可以采用最简单的断路器脉冲发生器。但是由于我们不仅要喷出岩浆还要立即收回，因此需要使用两个时间间隔很密的脉冲发生器来激活两次。（理论上来说，使用开关+双边沿触发器也可以达到收放岩浆的效果，但是为了迅速收回岩浆，最好还是使用两个脉冲发生器）\n一种比较廉价的双脉冲发生器的方案如下：\n1 2 3 4 5 6 7 8 {% minecraft 俯视图 %} |----|- |pi-u|ab|ab|ab|- |ab|pi-u|ab|ab|- |----|- |sand|rr-e1|rd-ew|→|- |rd+S|sand|rr-e3|→|- {% endminecraft %} 激活S处的红石后（最简单的方法是按钮），箭头所指的方向就能输出两次间隔很短的脉冲信号。如果连上发射器的话就可以做到岩浆的发射与立即收回。\n岩浆杀死的鸡会掉落熟鸡肉，能够省去后序烧鸡的步骤。不过由于村民交易时会需要生鸡肉，因此两种方法最好都加到鸡场中去。\n集成结构 有了上面这些部件以后，就可以集成出一个全自动养鸡场啦~布线的方案有很多，这里就不细讲了，大概的流程是：\n自动收集 → 分流 → 储物/鸡蛋上行 → 自动投掷鸡蛋 一个按钮连接粘性活塞控制窒息法杀鸡获得生鸡肉 一个按钮连接发射器控制岩浆杀鸡获得熟鸡肉 另一点是鸡圈的布置：鸡圈的C格上方用来砸鸡蛋，左右分别是活塞+实心方块和发射器，用来杀鸡，底部用漏斗收集。这样就能有效利用鸡圈的空间了。\n其实这个自动鸡场还有进一步改进的地方，比如最近参观dxsc的鸡场就看到了可以用一个按钮控制自由繁殖/自动杀鸡，这就更加方便了~不过本文中这样的一个鸡场已经完全够用啦~\n","date":"2017-08-31T00:00:00Z","permalink":"https://zyxin.xyz/blog/2017-08/MCChickenFarm/","title":"Minecraft - 集成养鸡场"},{"content":"时钟电路在MC里面是十分基础的结构，主要用于发射器或者活塞，用来循环进行某一活动。而高频时钟除了这些东西以外还会产生一些别的Side Effect（比如[刷铁轨机](https://zyxin.xyz/blog/2017-08/MCTrailAndStone/什么的）。本文就稍微总结一下我知道的时钟电路方案~\n文中概念说明：\nRT代指红石刻(Redstone Tick)。 电路可控代表可以用开关（拉杆）控制起停。 时钟不稳定指的是把时钟关上后可能会产生结构变化导致需要调整后才能继续使用。 高频电路可扩展指的是可以通过改变中继器的延时或增加中继器来延长周期。 中继器\u0026amp;比较器 方案1 1 2 3 4 {% minecraft 俯视图 %} |rd-se|rr-e1!|rd-sw!|- |rd-ne|rr-w1|rd-nw!|- {% endminecraft %} 周期≥2RT，不可控，不稳定，可扩展。该方案应该是最直观的时钟电路，不过开启循环比较麻烦，需要迅速通入红石信号以后再撤掉。可以通过调节中继器的数目和刻度来调节周期。\n方案2 1 2 3 4 {% minecraft 俯视图 %} |rd-ew|rr-e1!|ab|- |ab|rr-w1|rd-ew!|- {% endminecraft %} 周期为2RT，不可控，不稳定，不可扩展。比较器的延时只能是1RT。\n方案3 1 2 3 4 {% minecraft 俯视图 %} ||rd-se|rd-sw|- |rt-!|rc-e!|rd-nw|- {% endminecraft %} 周期为2RT，可控，稳定，可扩展。该方案是最经济并且可控的方案，实用性非常高。使用时右键比较器即可开闭。\n活塞 + 恒定信号 方案4 1 2 3 4 5 6 7 8 9 10 {% minecraft 俯视图 %} |----|- ||||- |ab|||- |ab|rd-ew|ab|- |----|- |ab|sp-s||- |rd-ns|ab||- |rd-ne||le-d|- {% endminecraft %} 周期为3RT，可控，不稳定。\n方案5 1 2 3 4 5 6 7 8 9 10 11 12 {% minecraft 俯视图 %} |----|- |||ab|- |||ab|- ||rt-!|ab|- ||||- |----|- |le-e!|ab|rd-ns!|- ||sp-s!|rd-ns!|- ||se-s|rd-ns!|- ||ab||- {% endminecraft %} 周期为3RT，可控，稳定。\n方案6 1 2 3 4 5 6 7 8 {% minecraft 俯视图 %} |----|- |le-e!|ab|sp-s!|- ||rd-ns!|se-s|- |||br|- |----|- ||rd-ns!||- {% endminecraft %} 周期为3RT，可控，稳定。这个方案是结构非常精简的一个方案，十分有用。\n方案7 1 2 3 4 5 6 7 8 9 10 11 {% minecraft 俯视图 %} |----|- |||ab|- |rt-!||rd-ns!|- |rd-ne!|ab|rd-ns!|- |----|- |||sp-s!|- |||se-s|- ||rd-ew!|ab|- ||le-n!||- {% endminecraft %} 周期为3RT，可控，稳定。\n红石火把 使用红石火把作为高频源时需要注意，红石火把会在2RT周期的时钟信号中烧毁而熄灭，因此如果只用一个火把的话需要把周期调至4RT以上，否则就需要采用两个火把交替熄灭的方案。\n方案8 1 2 3 4 5 6 7 8 {% minecraft 俯视图 %} |----|- |rd-se|rd-ew|rt-s|- |rd-ne|rr-e2|ab|- |----|- ||||- |||le-d!|- {% endminecraft %} 周期≥6RT，可控，稳定，可扩展。中继器的延时至少设为2RT，否则会使得火把烧毁。\n方案9 1 2 3 4 5 6 7 8 {% minecraft 俯视图 %} |----|- |rt-s!|rd-ew!|rd-sw!||- |ab|rr-w2|ab|le-w!|- |----|- |||||- |||rd-ns!||- {% endminecraft %} 周期≥6RT，可控，稳定，可扩展。中继器的延时同样至少为2RT。\n方案10 1 2 3 4 5 6 7 {% minecraft 俯视图 %} |----|- |le-e!|ab|rd-sew!|ab|- ||rt-n!|rd-new!|rt-n!|- |----|- ||rd-ew!||rd-ew!|- {% endminecraft %} 周期为2RT，可控，稳定，不可扩展。原理是两个火把交替熄灭。有一个缺点是火把熄灭时会产生噪音2333。\n方案11 1 2 3 4 5 6 7 8 {% minecraft 俯视图 %} |----|- |ab|rt-w!|- |rt-n||- |----|- |rd-!|ab|- |ab|le-n|- {% endminecraft %} 周期为2RT，可控，稳定，不可扩展。原理同样是交替熄灭。这个结构是周期为2RT的结构中最精简的一个，不需要中继器和比较器即可稳定产生高频。需要注意的是火把只能相邻放置，不能对置在方块两侧，因为火把熄灭产生的更新可以使相邻的火把重新可用。\n对置漏斗 方案12 1 2 3 4 5 6 7 8 {% minecraft 俯视图 %} |----|- |ho-e|ho-w|- |ab|rc-s|- |----|- |||- |le-$n!||- {% endminecraft %} 周期为7RT，可控，稳定，可扩展。使用时只需在漏斗中任意放一个物品即可。如果需要增长周期，可以使用更长的循环漏斗管道。\n矿车 只要让铁轨首尾相连，并再其上放上矿车，加上动力和检测铁轨就能造出时钟电路。这个方案非常直观，并且调整周期、起停控制很方便，可控性高，并且可以一周期内产生多次信号。\n方案13 1 2 3 4 5 {% minecraft 俯视图 %} |ra-se|dr-ew|ra-sw|- |ar-ns!|le-d!|ar-ns!|- |ra-ne|ar-ew!+mc-ew|ra-nw|- {% endminecraft %} 周期为20RT，可控，不稳定，可扩展。这是最简单的铁路时钟电路了，感应铁轨可以产生周期信号。但由于矿车停下来的位置不可确定，因此不稳定。\n","date":"2017-08-29T00:00:00Z","permalink":"https://zyxin.xyz/blog/2017-08/MCHfOscillation/","title":"Minecraft - 高频电路"},{"content":"雪块在Minecraft里面是不错的建筑材料，材质好看，并且来源容易。不过如果有个刷雪机的话还是能够大大提高出产速度的。刷雪机有很多种版本，其中在纯净服务器能用的目前我知道的只有半自动的刷雪机，全自动的大多利用的是某种BUG，并且在之后的版本就被修复了。\n刷雪机的基本原理是雪傀儡会在脚底下生成雪（除在沙漠等群系下除外），并且除掉雪以后会立即重新生成。这就给刷雪提供了来源。收集雪球的原理全自动版本有两种，一种是1.5之前可用的活塞推动雪傀儡下体的雪，雪被破坏后会直接生成雪球。另一种是1.5之后很多教程里提到的用水冲雪即可生成雪球。但实际上后一种是Forge的Bug，纯净的Minecraft用水冲雪是无法生成雪球的。因此据我所知，在1.5之后Minecraft里没有自动刷雪的可能了，因此只能手动刷雪了。\n虽然理论上只要把雪傀儡困住即可开始刷雪，但是这样很容易伤到雪傀儡，并且挖雪角度比较小。这里介绍一个比较方便的刷雪方案，并且如果使用Forge的话，就可以立即改造为全自动的刷雪机。这个方案的核心是站在灵魂沙上的雪傀儡可以在相邻的低一格的方块上生成雪，这是因为灵魂沙的碰撞箱比较特殊，会让在其上的实体下沉两个像素。\n困雪傀儡 刷雪机最基础的一步是困住雪傀儡，虽然困住雪傀儡很容易，但是由于方案的需要，我们要把雪傀儡捆在两个或者四个方块中间的位置，来让灵魂沙相邻的低一格方块上能够生成雪。因此最好是放在四格的中心，能够生成三格雪。\n这个方案的困雪傀儡可以分为如下几步：\n在第二格高搭建一个3x3的空心栅栏围墙\n把栅栏围墙中间的地面换成灵魂沙，并在其上用两个雪块和南瓜造一个雪傀儡\n在雪傀儡头顶放一个活塞和一个栅栏，栅栏在活塞下方，并准备好红石信号（红石块或方块+拉杆）\n用雪球把雪傀儡打到一个角落\n激活活塞，把栅栏推进中间\n把多余的栅栏打掉\n这样困住的雪傀儡一方面会在地上三格产生雪，另外头顶其实是被栅栏封住的，因此下雨不会影响到它。\n刷雪设置 困好傀儡后在周围稍稍改动一下就能很方便地进行刷雪了。首先需要把雪傀儡相邻的四格地面方块，除了灵魂沙以外的三个都打掉，然后把雪傀儡脚底的雪打掉。此时就会发现低一层的三格表面已经可以生成雪了。这样其实就已经可以愉快地刷雪啦~\n但是这样刷雪的时候由于雪球堆叠数目少，并且合成雪块又需求比较大，会经常碰见背包拾满的情况，因此可以增加一个物品收集系统。最直接方便的就是把相邻三格换成漏斗做地面，直接就能收集。另外一种是把三格做成水道封起来，然后在一端用发射器放水，另一端用漏斗接收即可。然后将发射器连上周期为8tick的时钟就可以自动冲雪了。这样不仅节省材料，而且在有Forge的情况下就是一个自动刷雪机~\n","date":"2017-08-27T11:28:55Z","permalink":"https://zyxin.xyz/blog/2017-08/MCSnowMachine/","title":"Minecraft - 刷雪机"},{"content":"Minecraft里面有很多种类的花，如玫瑰、向日葵、郁金香、兰花等等，如果配上一个好的材质包，就十分美好了~！除此之外，花也是合成染料的原料，因此在搭大型建筑物的时候花也是需求很大的。本文就介绍Minecraft中的刷花机，用花团装饰你的家吧！\n需要注意的是刷花机需要大量的骨粉，因此建议先建一个刷怪塔（最好是小白刷怪塔）~\n抖动刷花机 这一类刷花机的原理是对草地使用骨粉的话会生成草丛和花，再使用时钟或者BUD将花“抖落”即可。下面是BUD刷花的方案（用到了之前在红石基础里没有讲到的水平BUD，可以参见Wiki页面的“活塞BUD位充能”）。结构如下：\n{% minecraft 俯视图 %} |\u0026mdash;-Level1|- |ab|ab|ab|ab|ab|rt-!| | | |- |ab| | | | |rt-!|ab|ab|ab|- |ab| | | | |ab | | |ab|- |ab|pi-e!|pe-e|gb|gb|gb|gb|pi-w|ab|- |ab|pi-e!|pe-e|gb|gb|gb|gb|pi-w|ab|- |ab|pi-e!|pe-e|gb|gb|gb|gb|pi-w|ab|- |ab|pi-e!|pe-e|gb|gb|gb|gb|pi-w|ab|- |\u0026mdash;-Level2|- |rd-se!|rd-ew!|rd-ew!|rd-sew!|rr-w1!|ab | |||- |rd-ns!| | |ab | |pe-n |rr-e1!|rd-ew!|rd-sw!|- |rd-ns!| | | | |pi-n!| ||rd-ns!|- |rd-ns!| | | | |S | ||rd-ns!|- |rd-ns!| | | | | | ||rd-ns!|- |rd-ns!| | | | | | ||rd-ns!|- |rd-ns!| | | | | | ||rd-ns!|- |\u0026mdash;-Level3|- |||| | |||||- ||||rd-ns!| |||||- ||||ab |ab|||||- |\u0026mdash;-Level4|- ||||||||||- ||||||||||- ||||rt|rd-ew|||||- {% endminecraft %}\n这个刷花机本质上是个大型的BUD，其中S上方的活塞为感应器，剩下的活塞都是执行器。对S处地面不停地使用骨粉就能够大量刷花了~草地原则上尺寸不限，不过由于感应器位置的限制，4x4左右的尺寸是比较合适的，大了骨粉几乎影响不到，小了又会浪费骨粉。\n这个刷花机能够刷出的花为一格高的花，并且与地形有关，因此基本上在繁花森林(Flower Forest)建一个刷花机就基本能满足需求了。唯一的例外是兰花，兰花只在沼泽生成，因此需要兰花的话得去沼泽建刷花机。具体的生物群系与话的关系参见Wiki。\n另外需要注意的是，中间刷花的地面一定要是草方块，因此如果不是利用现成的地形改造刷花机的话就需要用精准镐子采集草方块来造刷花机了。\n发射器刷花机 上面一种刷花机只能刷一格高的花，而两格高的花（玫瑰从、向日葵等）有一个特别好用的特性，对这个花的第二格使用骨粉会直接掉落一朵新的花。因此可以用发射器与高频时钟来快速刷花，并且效率比第一种方案要高很多~\n上结构： {% minecraft 侧视图 %} |\u0026mdash;-Level1|- |||||- |||||- |rd-$!|rd-$!|rd-$!||- |ab|ab|ab||- |\u0026mdash;-Level2|- |||||- ||||rt-$n!|- |rd-$!|rr-s1!+R|rd-$!|rd-$!|- |ab|ab|ab|ab|- |\u0026mdash;-Level3|- |||||- ||di-$s|rc-$e|ab|- |rt-$e|ab|ab|ab|- |\u0026mdash;-Level4|- ||glass|||- |glass|F|glass||- |glass|F|glass||- ||gb|||- ||mc/ho-$ew+ra-$ew|||- |ch-$|ho-$w|||- |\u0026mdash;-Level5|- |||||- ||glass|||- ||glass|||- {% endminecraft %}\nR代表一个继电器，朝着发射器下方的方块。F代表两格高的花~刷花机的本体是Level4，下方用漏斗矿车来收集掉落物，其他的方块只是为了把花封闭起来防止掉落物乱跑，或者为了生成高频时钟。\n这个刷花机体积小，制造简单，唯一可惜的就是只能刷大型花~\n","date":"2017-08-27T00:00:00Z","permalink":"https://zyxin.xyz/blog/2017-08/MCFlowerMachine/","title":"Minecraft - 刷花机"},{"content":"铁轨是自动化设备的另一大功臣，充能铁轨作为长距离自动运输最重要的手段，成本比较高，因此在最开始玩MC的时候根本就没怎么造铁轨。。但后面进了服务器后发现可以刷铁轨！顿时打开了新世界的大门，不仅用铁轨搭建高空交通站，欣赏雨林、针叶林风景、还能抓村民回来当苦工~2333因此在这里介绍一下刷铁机的造法。\n此外，因为如果把铁轨搭建在地面上的话经常会受到怪物的干扰，因此一般会选择把铁轨搭在地下或者空中。而我个人比较喜欢空中铁轨，能看风景，而搭建空中铁轨就需要耗费大量耗材。出于成本和稳定性考虑铁路路基一般选择石头而不是雪块或者其他更难刷的材料，因此会需要大量的石头。这里也顺便把刷石机介绍一下了~\nPS: 本文所有结构都是我之前在各种教程中看到的，非原创，这里只是整理一下。\n刷铁轨 刷铁轨的原理是利用MC在高频推动铁轨时产生的判定BUG，因此这些原理很有可能在将来有会被禁掉。不过总有大佬能发现这样的BUG哈哈刷铁轨机能够刷全种类铁轨：普通铁轨、充能铁轨、激活铁轨、感应铁轨，因此非常实用！不过唯一需要注意的是由于使用了高频信号，在服务器上运行时不要常开。\n1.9 版本前 在1.9之前，通常利用的刷铁轨机是两个错位对置的活塞，这是一个半自动机构，需要手动放置铁轨。具体结构如下：\n1 2 3 4 5 6 7 8 9 {% minecraft 俯视图 %} |----Level1|- |ab|ab|ab|ab||- |↑||ab+R||ab|- |||||↑|- |----Level2|- |sp-e|ra-ns||ra-ew||- |||||sp-w|- {% endminecraft %} 这个结构中，铁轨的朝向不限，箭头代表高频时钟信号输入（两个活塞要连同一个信号）。用法是当开启高频时钟输入以后，在R处不停放置你想刷的铁轨，即可获得两倍的铁轨。\n1.9 版本后 1.9以及1.9之后，这个BUG被修复了。现在可以使用的刷铁轨机是另一种方案，结构如下：\n1 2 3 4 5 {% minecraft 侧视图 %} ||R|sl|sp-w||- |ra-$eu|sl|sl|ab|←|- |obsidian|A|A|||- {% endminecraft %} 其中R处放上想刷的铁轨，箭头代表高频时钟信号输入（貌似周期要在2tick以上），A处要留成空气（避免粘液块粘上其他东西，该装置粘液块的其他方向上也不能有方块）。这里使用黑曜石的目的是防止此方块被粘液块带走，这是这个刷铁轨机的关键。\n关于高频时钟信号的设计见我的另一篇文章\n刷石机 刷石机的基本原理是流动的岩浆与的流动的水相遇会生成石头（水可以是静止水，但是生产效率没有流动水高）。这是游戏本身的设定，因此刷石机在版本更新后基本上不会有太大的变化。用这个原理直接就能造出很简单的刷石机，只需要用一个活塞+时钟信号推走石头即可（要注意不能直接在岩浆与水交汇处挖石头，因为这样很有可能石头就被岩浆烧掉了。最合适的时钟间隔是10tick）。不过这里介绍一种利用BUD生成一列石头的方案，能够更加方便的刷石头。\n这里的BUD采用红石基础中的下落物BUD（因为试了一下别的BUD好象不太行）。刷石机结构示意图如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 {% minecraft 俯视图 %} |----Level0|- ||||||- ||ab||||- ||ab||||- |----Level1|- ||ab||||- |ab||ab|ab||- ||ab||||- |----Level2|- ||pi-s|dirt|dirt||- |sp-u|st+G|wa|wa|dirt|- ||st|dirt|dirt||- ||st||||- |----Level3|- |ab|dirt| |dirt||- |gs|lv+S|dirt|wa+S|dirt|- |ab|dirt| |dirt||- |----Level4|- |rd-!|||||- |sand|dirt||dirt||- |rr-n1!|||||- |ab|||||- |le-n!|||||- {% endminecraft %} 其中标S的是岩浆源和水源，G是生成石头的地方，石头会沿着G往下一直生成，直到活塞推不动为止（13格）。方案中的泥土是为了封闭岩浆和水。相比采用时钟电路的方案，这个方案有一点不好是活塞推不动以后需要重置设备，重置只需要在挖掉石头以后，在活塞周围放置方块使BUD更新即可。\nTips:\n在Minecraft里面铺设长距离铁路一般是刷感应铁轨和充能铁轨，然后按照1感应铁轨+3充能铁轨的配置来铺，这样能够让矿车自动保持高速，并且省下很多红石材料。 长距离旅行的话可以使用另一种结构：冰路。就是用冰铺路，并在离地三格高的位置铺方块顶。玩家在冰上行走时边疾行边跳能获得非常快的速度。 ","date":"2017-08-27T00:00:00Z","permalink":"https://zyxin.xyz/blog/2017-08/MCTrailAndStone/","title":"Minecraft - 刷铁轨\u0026刷石机"},{"content":"可可豆是一种染料，可以种在丛林木的树干上。可可豆由于需求量真心比较低，因此其实没有自动化的必要，一般用量比较大的地方是用作建筑材料的原料，如果是地毯那么手动栽培+羊毛种植其实就够了，而如果是硬化粘土（陶瓦）则直接可以从黏土山挖到。不过由于可可豆种植比较容易集成进作物塔，因此我也把结构放在这里吧~\n由于可可豆是先种植再生长的，因此无法使用BUD来自动化（除非暴力使用长周期时钟，如阳光传感器），只有半自动的结构。可可豆的收集有两种方法，水流式和活塞式。\n基本布置 两种方法的种植布置方式是一样的，只是收集方式不同，因此把布置方式与底部的水流收集先讲一下。按照作物塔的尺寸，考虑到走道和水流收集，从林木可以种成3排，每一排9格宽，高度不限，但为了便于种植，4格高比较合适。\n布置的俯视图如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 {% minecraft 俯视图 %} |----Level1|- ||||ab|ab| |ab|ab||||- ||||ab|ab| |ab|ab||||- ||||ab|ab| |ab|ab||||- ||||ab|ab| |ab|ab||||- ||||ab|ab|ab |ab|ab||||- ||||ab|ab|si-n+P|ab|ab||||- ||||ab|ab|ab |ab|ab||||- ||||ab|ab| |ab|ab||||- ||||ab|ab| |ab|ab||||- ||||ab|ab| |ab|ab||||- ||||ab|ab| |ab|ab||||- |----Level2|- ||ab|ab|wa|wa|ab|wa|wa|ab|ab||- ||ab|ab|wa|wa|ab|wa|wa|ab|ab||- ||ab|ab|wa|wa|ab|wa|wa|ab|ab||- ||ab|ab|wa|wa|ab|wa|wa|ab|ab||- ||ab|ab|wa|wa|ab|wa|wa|ab|ab||- ||ab|ab|wa|wa|wa|wa|wa|ab|ab||- ||ab|ab|wa|wa|ab|wa|wa|ab|ab||- ||ab|ab|wa|wa|ab|wa|wa|ab|ab||- ||ab|ab|wa|wa|ab|wa|wa|ab|ab||- ||ab|ab|wa|wa|ab|wa|wa|ab|ab||- ||ab|ab|wa|wa|ab|wa|wa|ab|ab||- |----Level3|- |st|wa|wa ||fg-ns!| |fg-ns!||wa |wa|st|- |st|wa|ab+S||fg-ns!|ab+S|fg-ns!||ab+S|wa|st|- |st|wa|ab+S||fg-ns!|ab+S|fg-ns!||ab+S|wa|st|- |st|wa|ab+S||fg-ns!|ab+S|fg-ns!||ab+S|wa|st|- |st|wa|ab+S||fg-ns!|ab+S|fg-ns!||ab+S|wa|st|- |st|wa+O|ab+S|| | | ||ab+S|wa+O|st|- |st|wa|ab+S||fg-ns!|ab+S|fg-ns!||ab+S|wa|st|- |st|wa|ab+S||fg-ns!|ab+S|fg-ns!||ab+S|wa|st|- |st|wa|ab+S||fg-ns!|ab+S|fg-ns!||ab+S|wa|st|- |st|wa|ab+S||fg-ns!|ab+S|fg-ns!||ab+S|wa|st|- |st|wa|wa ||fg-ns!| |fg-ns!||wa |wa|st|- {% endminecraft %} O代表水源，S代表此处为从林木种植处（一共三排），P为作物塔管道出口。左右的平整石头代表走道，中间的两排栅栏门也是起走道作用，便于在其中播种可可豆。当需要播种时可以把栅栏门关上，播种完毕后把栅栏门打开，便于可可豆下落。栅栏门也可以换成活板门。不过实测站在边上是可以播种到里面的，因此这个栅栏门不是必须的。\n由于下文提到的可可豆种植结构可能会使作物塔管道被遮住，因此又可能需要额外的水流转移绕开遮挡。以及由于本文的红石设计难度不大，并且有额外的一圈供铺设红石，因此与上下层的红石连接，以及半自动设备中开关信号的接收在这里就略去了。\n水流式 水流式的一排可可豆种植结构如图：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 {% minecraft 侧视图 %} |----无红石信号|- ||||ab|wa|ab||||- ||||pi-e!|pe-e|ab||||- |||||ab+lighter+B|||||- ||||| ab |||||- ||||ab||ab||||- |||ab||||ab|||- ||ab||||||ab||- |Ow-$|Ow-$|Ow-$|Ow-$||Ow-$|Ow-$|Ow-$|Ow-$|- |Ow-$|Ow-$|Ow-$|Ow-$||Ow-$|Ow-$|Ow-$|Ow-$|- |ellipsis-ns|ellipsis-ns|ellipsis-ns|ellipsis-ns||ellipsis-ns|ellipsis-ns|ellipsis-ns|ellipsis-ns|- |Ow-$|Ow-$|Ow-$|Ow-$||Ow-$|Ow-$|Ow-$|Ow-$|- |Ow-$|Ow-$|Ow-$|Ow-$||Ow-$|Ow-$|Ow-$|Ow-$|- |----有红石信号|- ||||ab|wa|ab||||- ||||pi-e!|pe-e|ab||||- ||||rt-$e!+lighter|ab+lighter+B|||||- |||||ab+rt-$n|||||- ||||ab|rt-$!|ab||||- |||ab||ab||ab|||- ||ab|||rt-$|||ab||- |Ow-$|Ow-$|Ow-$|Ow-$|ab|Ow-$|Ow-$|Ow-$|Ow-$|- |Ow-$|Ow-$|Ow-$|Ow-$|rt-$!|Ow-$|Ow-$|Ow-$|Ow-$|- |ellipsis-ns|ellipsis-ns|ellipsis-ns|ellipsis-ns|ellipsis-ns|ellipsis-ns|ellipsis-ns|ellipsis-ns|ellipsis-ns|- |Ow-$|Ow-$|Ow-$|Ow-$|ab|Ow-$|Ow-$|Ow-$|Ow-$|- |Ow-$|Ow-$|Ow-$|Ow-$|rt-$!|Ow-$|Ow-$|Ow-$|Ow-$|- {% endminecraft %} 顶端较亮的B方块是在指这一个平面前后两个都有一个方块，以限制水在这一格只能向左右流下去\n当种在树干上的可可豆成熟之后可以switch红石灯，然后水则会顺着几个砖块流下，使得每一列从林木都能被水冲刷到，种在上面的可可豆即可被冲刷掉。\n可以看出该方案好在结构简单，成本十分低廉。但缺点是整体过高，并且水流下落和收回的时间均较慢。\n活塞式 活塞式的设计就是通过对称的活塞把从林木“晃”一下，使得可可豆掉落。\n1 2 3 4 5 6 7 8 {% minecraft 正视图 %} |----正面|- |ellipsis-ns|ellipsis-ns|ellipsis-ns|ellipsis-ns|ellipsis-ns|ellipsis-ns|ellipsis-ns||ellipsis-ns|- |pi-e|Ow-$|Ow-$|Ow-$|Ow-$|Ow-$|Ow-$||pi-w|- |pi-e|Ow-$|Ow-$|Ow-$|Ow-$|Ow-$|Ow-$||pi-w|- |pi-e|Ow-$|Ow-$|Ow-$|Ow-$|Ow-$|Ow-$||pi-w|- |pi-e|Ow-$|Ow-$|Ow-$|Ow-$|Ow-$|Ow-$||pi-w|- {% endminecraft %} 侧面的活塞红石布线如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 {% minecraft 侧视图 %} |----后面|- |||rd-$!||rd-$!|||- |pi-d|rd-$!|ts-$|pi-d|ts-$|rd-$!|pi-d|- |pi-d|ts-$|rd-$!|pi-d|rd-$!|ts-$|pi-d|- |pi-d|rd-$!|ts-$|pi-d|ts-$|rd-$!|pi-d|- |pi-d|ts-$|rd-$!|pi-d|rd-$!|ts-$|pi-d|- |wa-$2|wa-$1|ts-$| |ts-$|wa-$1|wa-$2|- |----前面|- ||||||||- ||||||||- ||||||||- ||||rd-$!||||- |||rd-$!|ab|rd-$!|||- |||ab |ab|ab |||- {% endminecraft %} 只需将传入本层的红石信号引到侧面就行。在三排之间穿行的方法，一种是从活塞与木头间的空格通过，另一种就是可以单独用一排栅栏门替换从林木，造一个通道出来。\n可可豆的自动农场之前在服务器上没有搭建过，这个实在本地试验出来的，尺寸和作物塔是可以对上的，敬请参考~\n","date":"2017-08-26T00:00:00Z","permalink":"https://zyxin.xyz/blog/2017-08/MCTowerCocoa/","title":"Minecraft - 集成作物塔 - 可可豆"},{"content":"Minecraft中的红石有非常多的玩法，基本只有你想不到，没有你做不到的。但是Minecraft的红石原理入门较难，如果有数电基础还好说，没有的话推荐通过看一些大佬的教程的上手。这里就介绍一些学习红石的资源~\nMinecraft Wiki Minecraft Wiki中的内容非常全面，其中对红石的教程也比较多，是很好的参考材料。Wiki中文版大部分是翻译自英文版的内容，因此如果能读英文版的话学到的东西会多一点。\n红石页面：中文|EN 红石设备列表：中文|EN 明月庄主 很多MC老玩家应该都听过庄主的名字了，我就是看他的红石视频入门的。庄主已经持续高产好几年了，从基础的红石到复杂红石设备都有涉及，并且还会有生存直播等等。非常值得关注~\n微信公众号：moonmc666 B站：ID 2170934 Youtube Tunnels sethbling：著名油管MC播主。在前几年经常有各种各样的红石设计视频，但好象最近没什么更新了。 Automatic Redstone：中文，无语音，基础红石设备为主。 贴吧 红石电路吧：大佬聚集地，貌似现在里面有一个TheRedPixel团队了？ 题外话：红石电路其实分两种，一种是利用了命令方块的，相当于开挂。能做的东西多很多，并且体积也比较小，但是这对生存模式是不友好的；另一种是不用命令方块的，能实现的电路也很多，只是体积相对较大。在学习的时候要区分一下~\n","date":"2017-08-25T00:00:00Z","permalink":"https://zyxin.xyz/blog/2017-08/MCRedstoneRes/","title":"Minecraft - 红石相关资源"},{"content":"甘蔗机是一个在早期就能搭建起来的复杂自动设备。甘蔗在水边很容易就能找到，并且生长会产生新方块，因此甘蔗机只需要一个BUD和一堆活塞。如果使用普通活塞制作BUD的话，就能够在挖到铁块之后立即建造出来。\n一般如果独立造甘蔗机的话会并排造，而在作物塔内还要考虑到收集的方便，并对尺寸进行了一定的压缩。BUD使用的是在[红石基础](https://zyxin.xyz/blog/2017-08/MCTowerRedstone/中的粘性活塞+火把结构（当然，也可以使用别的BUD结构），然后通过活塞阵列进行扩增。当甘蔗生长时立刻被活塞推掉变成掉落实体，然后流水收集即可。\n话不多说，直接上结构。一排甘蔗机的结构如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 {% minecraft 俯视图 %} |----Level0|- ||||||- ||ab||||- ||ab||||- ||ab||||- ||ab||||- ||ellipsis-ns||||- |----Level1|- |ab|ab|ab|||- |ab|wa+O|dirt|||- |ab|wa|dirt|||- |ab|wa|dirt|||- |ab|wa|dirt|||- |ellipsis-ns|ellipsis-ns|ellipsis-ns|||- |----Level2|- |ab|ab|ab|||- |ab||S|ab||- |ab||S|ab||- |ab||S|ab||- |ab||S|ab||- |ellipsis-ns||ellipsis-ns|ellipsis-ns||- |----Level3|- |ab|ab|pe-u|||- ||ib-ns||pi-w||- ||ib-ns||pi-w||- ||ib-ns||pi-w||- ||ib-ns||pi-w||- ||ellipsis-ns||ellipsis-ns||- |----Level4|- |ab|ab|ab|ab|ab|- |||||ab|- |||||ab|- |||||ab|- |||||ab|- |||||ellipsis-ns|- |----Level5|- |ab|rr-w1||rd-ew!|rd-sw!|- |||||rd-ns!|- |||||rd-ns!|- |||||rd-ns!|- |||||rd-ns!|- |||||ellipsis-ns|- |----Level6|- |rd-ew|ab|ab|rt-w!||- |----Level7|- ||rd-ew|rd-ew|||- {% endminecraft %} O是水源方块，S的位置种上甘蔗。这个结构里面有很多多余的方块，有些是为了便于爬上去建造，另一些是为了保证甘蔗不被弹到别的地方。可以适当去掉其中的一些。栅栏的作用一是防止误落水中，二是限制甘蔗掉落的位置，保证甘蔗能够掉落到水中。\n将几列这样的结构并排放置即可得到作物塔中的甘蔗层。具体的密排方式如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 {% minecraft 俯视图 %} |----Level0|- ||||||||||||- ||||||||||||- ||||||||||||- ||||||||||||- ||||||||||||- ||||||||||||- ||||||||||||- ||||||||||||- ||||||||||||- ||ab|ab|ab|ab|ab|ab|ab|ab|||- ||||||||||||- |----Level1|- ||||||||||||- ||ab|||ab|||ab||||- ||ab|||ab|||ab||||- ||ab|||ab|||ab||||- ||ab|||ab|||ab||||- ||ab|||ab|||ab||||- ||ab|||ab|||ab||||- ||ab|||ab|||ab||||- ||ab|ab|ab|ab|ab|ab|ab|ab|ab||- |ab|wa+O|wa|wa|wa|wa|wa|wa|wa|P||- ||ab|ab|ab|ab|ab|ab|ab|ab|ab||- |----Level2|- |ab|ab|ab|ab|ab|ab|ab|ab|ab|st|st|- |ab|wa+O|dirt|ab|wa+O|dirt|ab|wa+O|dirt||st|- |ab|wa|dirt|ab|wa|dirt|ab|wa|dirt||st|- |ab|wa|dirt|ab|wa|dirt|ab|wa|dirt||st|- |ab|wa|dirt|ab|wa|dirt|ab|wa|dirt||st|- |ab|wa|dirt|ab|wa|dirt|ab|wa|dirt||st|- |ab|wa|dirt|ab|wa|dirt|ab|wa|dirt||st|- |ab|wa|dirt|ab|wa|dirt|ab|wa|dirt||st|- |ab|wa|dirt|ab|wa|dirt|ab|wa|dirt||st|- |ab||||||||||st|- |st|st|st|st|st|st|st|st|st|st|st|- |----Level3|- |ab|ab|ab|ab|ab|ab|ab|ab|ab|||- |ab||S|ab||S|ab||S|ab||- |ab||S|ab||S|ab||S|ab||- |ab||S|ab||S|ab||S|ab||- |ab||S|ab||S|ab||S|ab||- |ab||S|ab||S|ab||S|ab||- |ab||S|ab||S|ab||S|ab||- |ab||S|ab||S|ab||S|ab||- |ab||S|ab||S|ab||S|ab||- |ab||ab|||ab|||ab|||- |----Level4|- |||pe-u||||||pe-u|||- ||ib-ns||pi-w|ib-ns||pi-w|ib-ns||pi-w||- ||ib-ns||pi-w|ib-ns||pi-w|ib-ns||pi-w||- ||ib-ns||pi-w|ib-ns||pi-w|ib-ns||pi-w||- ||ib-ns||pi-w|ib-ns||pi-w|ib-ns||pi-w||- ||ib-ns||pi-w|ib-ns||pi-w|ib-ns||pi-w||- ||ib-ns||pi-w|ib-ns||pi-w|ib-ns||pi-w||- ||ib-ns||pi-w|ib-ns||pi-w|ib-ns||pi-w||- ||ib-ns||pi-w|ib-ns||pi-w|ib-ns||pi-w||- ||ib-ns|||ib-ns|pe-u||ib-ns|||- |----Level5|- |ab|ab|ab|ab|ab||ab|ab|ab|ab|ab|- |||||ab|||ab|||ab|- |||||ab|||ab|||ab|- |||||ab|||ab|||ab|- |||||ab|||ab|||ab|- |||||ab|||ab|||ab|- |||||ab|||ab|||ab|- |||||ab|||ab|||ab|- |||||ab|||ab|||ab|- ||||ab|ab|ab|ab|ab||||- |----Level6|- |ab|rr-w1||rd-ew!|rd-sw!||ab|rr-w1||rd-ew!|rd-sw!|- |||||rd-ns!|||rd-ns!|||rd-ns!|- |||||rd-ns!|||rd-ns!|||rd-ns!|- |||||rd-ns!|||rd-ns!|||rd-ns!|- |||||rd-ns!|||rd-ns!|||rd-ns!|- |||||rd-ns!|||rd-ns!|||rd-ns!|- |||||rd-ns!|||rd-ns!|||rd-ns!|- |||||rd-ns!|||rd-ns!|||rd-ns!|- |||||rd-ns!|||rd-ns!|||rd-ns!|- ||||ab|rr-w1||rd-ew!|rd-nw!|- |----Level7|- |rd-ew|ab|ab|rt-w!|||rd-ew|ab|ab|rt-w!||- ||||||||||||- ||||||||||||- ||||||||||||- ||||||||||||- ||||||||||||- ||||||||||||- ||||||||||||- ||||||||||||- ||||rd-ew|ab|ab|rt-w!||- |----Level8|- ||rd-ew|rd-ew|||||rd-ew|rd-ew|rt-w!||- ||||||||||||- ||||||||||||- ||||||||||||- ||||||||||||- ||||||||||||- ||||||||||||- ||||||||||||- ||||||||||||- |||||rd-ew|rd-ew|||- {% endminecraft %} 按照惯例，O为水源，S种甘蔗，平整石头代表走道，P代表作物塔管道。\n这个方案在底层的密度非常大，两排甘蔗机刚好可以在BUD的中继器处分开，不产生干扰（红石信号强度不足以锁定中继器）。可以看出甘蔗田由于BUD的存在，高度比之前的几种都要高（相互叠加的情况下Level0和Level8是不能重合的，因此实际要占9层），并且高层的空间利用率比较低。不过空间什么的应该不会缺吧2333~。\n如果有侦测器的话应该能把高度压缩不少，但是成本应该会有一定上升。\n右下角有一缺口，这个位置就是作物通道的位置，上层的作物可以流到这一格进入管道向下传递。不过由于甘蔗层的管道在角落上，因此如果要与管道在中间的层（如小麦塔）相连，则需要像上一篇所写的转移装置来转移位置。\n","date":"2017-08-23T00:00:00Z","permalink":"https://zyxin.xyz/blog/2017-08/MCTowerSugarcane/","title":"Minecraft - 集成作物塔 - 甘蔗"},{"content":"南瓜和西瓜都是需要先长出茎，茎成熟之后则会在周围四个生成南瓜或西瓜。由于这两种作物的生成是在四周生成的，因此BUD的排列比较Tricky。\n我使用的BUD结构仍然是在红石基础中的粘性活塞+火把结构。南瓜茎需要交替种植，在交替的泥土之间会生成南瓜，用BUD检测它然后用活塞推掉即可。\n自动南瓜的基本单元是一个BUD+一个南瓜可能生成的格子，因此不考虑布线的情况下暴力堆叠即可。但是在这个自动塔中由于尺寸的限制，需要一定的规划~\n直接上结构示意图：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 {% minecraft 俯视图 %} |----Level0|- ||||||||||||- ||||||||||||- ||||||||||||- ||||||||||||- ||||||||||||- ||||||||||||- ||||||||||||- ||||||||||||- ||||||||||||- ||ab|ab|ab|ab|ab|ab|ab|ab|||- ||||||||||||- |----Level1|- ||||||||||||- |||ab|||st|||ab|||- |||ab|||st|||ab|||- |||ab|||st|||ab|||- |||ab|||st|||ab|||- |||ab|||st|||ab|||- |||ab|||st|||ab|||- |||ab|||st|||ab|||- ||ab|ab|ab|ab|ab|ab|ab|ab|ab||- |ab|wa+O|wa|wa|wa|wa|wa|wa|wa|P||- ||ab|ab|ab|ab|ab|ab|ab|ab|ab||- |----Level2|- |st|st|st|st|st|st|st|st|st|st|st|- |ab|dirt|wa+O|fa|ab||ab|dirt|wa+O|fa|ab|- |ab|fa|wa|dirt|ab|ts|ab|fa|wa|dirt|ab|- |ab|dirt|wa|fa|ab|ts|ab|dirt|wa|fa|ab|- |ab|fa|wa|dirt|ab|ts|ab|fa|wa|dirt|ab|- |ab|dirt|wa|fa|ab|ts|ab|dirt|wa|fa|ab|- |ab|fa|wa|dirt|ab|ts|ab|fa|wa|dirt|ab|- |ab|dirt|wa|fa|ab|ts|ab|dirt|wa|fa|ab|- |ab|fa|wa|dirt|ab| |ab|fa|wa|dirt|ab|- |st||||||||||st|- |st|st|st|st|st|st|st|st|st|st|st|- |----Level3|- ||||||||||||- |pi-e||ib-ns|S|gs||pi-e||ib-ns|S|gs|- |gs|S|ib-ns||pi-w||gs|S|ib-ns||pi-w|- |pi-e||ib-ns|S|gs||pi-e||ib-ns|S|gs|- |gs|S|ib-ns||pi-w||gs|S|ib-ns||pi-w|- |pi-e||ib-ns|S|gs||pi-e||ib-ns|S|gs|- |gs|S|ib-ns||pi-w||gs|S|ib-ns||pi-w|- |pi-e||ib-ns|S|gs||pi-e||ib-ns|S|gs|- |gs|S|ib-ns||pi-w||gs|S|ib-ns||pi-w|- |----Level4|- ||||||||||||- ||sp-u||||||sp-u||||- ||||pe-u||||||sp-u||- ||sp-u||||||sp-u||||- ||||sp-u||||||sp-u||- ||sp-u||||||sp-u||||- ||||sp-u||||||sp-u||- ||sp-u||||||sp-u||||- ||||sp-u||||||sp-u||- |----Level5|- ||||||||||||- |ab|ab|ab||||ab|ab|ab|||- |||ab|ab|ab||||ab|ab|ab|- |ab|ab|ab||||ab|ab|ab|||- |||ab|ab|ab||||ab|ab|ab|- |ab|ab|ab||||ab|ab|ab|||- |||ab|ab|ab||||ab|ab|ab|- |ab|ab|ab||||ab|ab|ab|||- |||ab|ab|ab||||ab|ab|ab|- |----Level6|- ||||||||||||- |rd-!||rr-e1|ab|||rd-!||rr-e1|ab||- ||ab|rr-w1||rd-!|||ab|rr-w1||rd-!|- |rd-!||rr-e1|ab|||rd-!||rr-e1|ab||- ||ab|rr-w1||rd-!|||ab|rr-w1||rd-!|- |rd-!||rr-e1|ab|||rd-!||rr-e1|ab||- ||ab|rr-w1||rd-!|||ab|rr-w1||rd-!|- |rd-!||rr-e1|ab|||rd-!||rr-e1|ab||- ||ab|rr-w1||rd-!|||ab|rr-w1||rd-!|- |----Level7|- ||||||||||||- |rt-e!|ab|ab|rd-ew|||rt-e!|ab|ab|rd-ew||- ||rd-ew|ab|ab|rt-w!|||rd-ew|ab|ab|rt-w!|- |rt-e!|ab|ab|rd-ew|||rt-e!|ab|ab|rd-ew||- ||rd-ew|ab|ab|rt-w!|||rd-ew|ab|ab|rt-w!|- |rt-e!|ab|ab|rd-ew|||rt-e!|ab|ab|rd-ew||- ||rd-ew|ab|ab|rt-w!|||rd-ew|ab|ab|rt-w!|- |rt-e!|ab|ab|rd-ew|||rt-e!|ab|ab|rd-ew||- ||rd-ew|ab|ab|rt-w!|||rd-ew|ab|ab|rt-w!|- |----Level8|- ||||||||||||- ||rd-ew|rd-ew|||||rd-ew|rd-ew|||- |||rd-ew|rd-ew|||||rd-ew|rd-ew||- ||rd-ew|rd-ew|||||rd-ew|rd-ew|||- |||rd-ew|rd-ew|||||rd-ew|rd-ew||- ||rd-ew|rd-ew|||||rd-ew|rd-ew|||- |||rd-ew|rd-ew|||||rd-ew|rd-ew||- ||rd-ew|rd-ew|||||rd-ew|rd-ew|||- |||rd-ew|rd-ew|||||rd-ew|rd-ew||- {% endminecraft %} O是水源，S种南瓜或西瓜种子，平整的石头是走道，P是作物塔管道。上面的萤石可以换成南瓜灯，是用来照明的，当然也可以用其他的方块，只要保证南瓜不生成在这个格子即可。水流方向也可以左右对调。\n这个方案资源开销特别大，粘性活塞和中继器都很多，在前期可能不太吃得消，但重在特别整齐o(*￣▽￣*)ゞ。整个机构净高有8层，堆叠时Level0和Level8是可以重合的。\n到这为止，我在服务器上搭的作物塔层已经全部介绍完了~下面还会介绍一些没有在服务器上搭的作物层以及一些新版本的作物。\n","date":"2017-08-23T00:00:00Z","permalink":"https://zyxin.xyz/blog/2017-08/MCTowerPumpkin/","title":"Minecraft - 集成作物塔 - 南瓜\u0026西瓜"},{"content":"仙人掌 仙人掌收获的基本原理是，当仙人掌方块被生成时，如果周围方块内有物体，那么仙人掌方块会变成实体掉落。（周围有方块时仙人掌方块无法被放置，但是如果先放置仙人掌后放置其他方块，则仙人掌会掉落）\n因此常见的仙人掌农场会把仙人掌间隔着交叉种植，并在空隙上放上栅栏来使仙人掌掉落。具体结构如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 {% minecraft 侧视图 %} |----侧视图|- ||||ib-ns||ib-ns||ib-ns||ib-ns||||- |||cactus-$||cactus-$||cactus-$||cactus-$||cactus-$|||- |||sand||sand||sand||sand||sand|||- |st||ab||ab||ab||ab||ab||st|- ||slab+ts-$|wa+O|wa-$7|wa-$6|wa-$5|wa-$4|wa-$5|wa-$6|wa-$7|wa+O|slab||- |||ab|ab|ab|ab|ab|ab|ab|ab|ab|||- {% endminecraft %} {% minecraft 俯视图 %} |----俯视图|- |st|st|st|st|st|st|st|st|st|st|st|st|st|- |st|ts+S|ts+S|ts+S|ts+S|ts+S|ts+S|ts+S|ts+S|ts+S|ts+S|ts+S|st|- |st|ts+S|sand+cactus+O|wa+rd-!|sand+cactus|wa+rd-!|sand+cactus|wa+rd-!|sand+cactus|wa+rd-!|sand+cactus+O|ts+S|st|- |st|ts+S|wa+rd-!|sand+cactus|wa+rd-!|sand+cactus|wa+rd-!|sand+cactus|wa+rd-!|sand+cactus|wa+rd-!|ts+S|st|- |st|ts+S|sand+cactus|wa+rd-!|sand+cactus|wa+rd-!|sand+cactus|wa+rd-!|sand+cactus|wa+rd-!|sand+cactus|ts+S|st|- |st|ts+S|wa+rd-!|sand+cactus|wa+rd-!|sand+cactus|wa+rd-!|sand+cactus|wa+rd-!|sand+cactus|wa+rd-!|ts+S|st|- |st|ts+S|sand+cactus|wa+rd-!|sand+cactus|wa+rd-!|P|wa+rd-!|sand+cactus|wa+rd-!|sand+cactus|ts+S|st|- |st|ts+S|wa+rd-!|sand+cactus|wa+rd-!|sand+cactus|wa+rd-!|sand+cactus|wa+rd-!|sand+cactus|wa+rd-!|ts+S|st|- |st|ts+S|sand+cactus|wa+rd-!|sand+cactus|wa+rd-!|sand+cactus|wa+rd-!|sand+cactus|wa+rd-!|sand+cactus|ts+S|st|- |st|ts+S|wa+rd-!|sand+cactus|wa+rd-!|sand+cactus|wa+rd-!|sand+cactus|wa+rd-!|sand+cactus|wa+rd-!|ts+S|st|- |st|ts|sand+cactus+O|wa+rd-!|sand+cactus|wa+rd-!|sand+cactus|wa+rd-!|sand+cactus|wa+rd-!|sand+cactus+O|ts+S|st|- |st|ts+S|ts+S|ts+S|ts+S|ts+S|ts+S|ts+S|ts+S|ts+S|ts+S|ts+S|st|- |st|st|st|st|st|st|st|st|st|st|st|st|st|- {% endminecraft %} 上面的示意图中，O代表水源，S代表下半砖，P代表作物塔管道。铁栅栏可以用木栅栏代替，俯视图的红石代表栅栏的位置。没有标记S的砖块用作台阶，周围的石头代表走廊。这个方案中栅栏有浪费，最节省的方案中，栅栏所影响的方块是不相互重叠的。不过为了美观和插火把的需要，本文中还是在全部缝隙中插入了栅栏。\n被栅栏破坏的仙人掌方块会掉入到下面流动的水中，最终被四角水源产生的水流冲到中间的通道，掉落下去而被收集，简单有效。唯一不足就是仙人掌掉落的方向随机，可能会掉到其他仙人掌上而被破坏，或者掉落到走廊上而无法收集。\n鸡蛋 鸡会以一定间隔自动生蛋，因此非常省事，只需要把它们养起来就可以啦233。有一种更为复杂的鸡圈，除了收集鸡蛋外还可以自动杀鸡、烤鸡和生小鸡，这个会在后面的文章中讲到。\n在作物塔中养鸡可以直接用一池水把鸡圈养着，鸡生出的鸡蛋可以直接掉入下方进行收集。该层的剖面如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 {% minecraft 侧视图 %} |----中部|- ||ab||||||||||ab||- |st|ab||||||||||ab|st|- ||ab|wa|wa|wa|wa|wa|wa|wa|wa|wa|ab||- ||ab|fg-$ew!|fg-$ew!|fg-$ew!|fg-$ew!|fg-$ew!|fg-$ew!|fg-$ew!|fg-$ew!|fg-$ew!|ab||- ||ab|wa-$4|wa-$3|wa-$2|wa-$1|P|wa-$1|wa-$2|wa-$3|wa-$4|ab||- |||ab|ab|ab|ab||ab|ab|ab|ab|||- |----边上|- ||ab||||||||||ab||- |st|ab||||||||||ab|st|- ||ab|wa|wa|wa|wa|wa|wa|wa|wa|wa|ab||- ||ab|fg-$ew!|fg-$ew!|fg-$ew!|fg-$ew!|fg-$ew!|fg-$ew!|fg-$ew!|fg-$ew!|fg-$ew!|ab||- ||ab|wa+O|wa-$7|wa-$6|wa-$5|wa-$4|wa-$5|wa-$6|wa-$7|wa+O|ab||- |||ab|ab|ab|ab|ab|ab|ab|ab|ab|||- {% endminecraft %} 收集方法类似于上面的仙人掌，是利用四角水源把鸡蛋冲到中间。这个方案中上层每一歌水的下方都有一个打开的栅栏门来阻隔水，同时不阻挡方块的下落。用告示牌可以达到相似的效果，但是告示牌阵列是依附于一个初始方块的，如果那个方块被破坏，那么所有告示牌都会被破坏。这样很不稳定，而栅栏门则没有这个问题。\n使用时向池子里打鸡蛋，或者把鸡从外面赶进来即可。另外一个需要注意的是水面到池边需要至少两格的高度差，否则鸡可能会从池子里扑腾出来。\nTips 这两种农场都是四角水源，因此可以用于通道转移，将角落的通道掉落下来的物品冲到中间继续下落（南瓜和甘蔗会从角落下落）。\n非常简单的两层农场。下面会写使用了BUD的农场，会比较复杂。\n","date":"2017-08-22T00:00:00Z","permalink":"https://zyxin.xyz/blog/2017-08/MCTowerCactus/","title":"Minecraft - 集成作物塔 - 仙人掌\u0026鸡蛋"},{"content":"小麦塔的原理非常简单，也是大部分生存玩家最先考虑的自动设施。小麦塔不仅仅可以种小麦，还可以种土豆、胡萝卜，甚至地狱疣，以及1.9进入PC版的甜菜。\n在作物塔中的小麦层有两种，一种是半自动的，一种是全自动的~还有一种1x1的刷小麦机，靠大量骨粉来催熟，速度超群，在有刷小白的刷怪塔后可以建造这样的小麦机，也属于半自动的，同样适用上述作物，就不放在这里讲了。\n半自动小麦塔 半自动小麦塔的功能是自动收割，但是不能自动播种，因此每次收割完毕后需要人工播种。半自动小麦塔的结构如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 {% minecraft 俯视图 %} |----Level0|- |||||||rt-!+darker|||||||- ||||||||||||||- ||||||||||||||- ||||||||||||||- ||||||||||||||- |||||| |dirt| ||||||- ||||||dirt|si-n+P|dirt||||||- |||||| |dirt| ||||||- ||||||||||||||- ||||||||||||||- ||||||||||||||- ||||||||||||||- ||||||||||||||- |----Level1|- |||||||st|||||||- ||||||||||||||- |||fa|fa|fa|fa|fa|fa|fa|fa|fa||- |||fa|fa|fa|fa|fa|fa|fa|fa|fa||- |||fa|fa|fa|fa|fa|fa|fa|fa|fa||- |||fa|fa|fa|fa|fa|fa|fa|fa|fa||- |||fa|fa|fa|fa|wa|fa|fa|fa|fa||- |||fa|fa|fa|fa|fa|fa|fa|fa|fa||- |||fa|fa|fa|fa|fa|fa|fa|fa|fa||- |||fa|fa|fa|fa|fa|fa|fa|fa|fa||- |||fa|fa|fa|fa|fa|fa|fa|fa|fa||- ||||||||||||||- ||||||||||||||- |----Level2|- |||||||rt|||||||- ||ts+S|ts+S|ts+S|ts+S|ts+S|ts+S|ts+S|ts+S|ts+S|ts+S|ts+S||- ||ts+S||||||||||ts+S||- ||ts+S||||||||||ts+S||- ||ts+S||||||||||ts+S||- ||ts+S||||||||||ts+S||- ||ts+S||||||||||ts+S||- ||ts+S||||||||||ts+S||- ||ts+S||||||||||ts+S||- ||ts+S||||||||||ts+S||- ||ts+S||||||||||ts+S||- ||ts+S|ts+S|ts+S|ts+S|ts+S|ts |ts+S|ts+S|ts+S|ts+S|ts+S||- ||||||||||||||- |----Level3|- |st|st|st|st|st|st|st|st|st|st|st|st|st|- |st| | |||||||| | |st|- |st|pi-e!|pe-e||||||||pe-w|pi-w!|st|- |st| | |||||||| | |st|- |st| | |||||||| | |st|- |st| | |||||||| | |st|- |st| | |||||||| | |st|- |st| | |||||||| | |st|- |st| | |||||||| | |st|- |st| | |||||||| | |st|- |st|pi-e!|pe-e||||||||pe-w|pi-w!|st|- |st| | |||||||| | |st|- |st|st|st|st|st|st|st|st|st|st|st|st|st|- |----Level4|- |||||||rt-!|||||||- ||ts|ts|ts|ts|ts |ts |ts |ts|ts|ts|ts||- ||ts|wa|ts| | | | | |ts|wa|ts||- ||ts|ts| | | | | | | |ts|ts||- ||ts| | | | | | | | | |ts||- ||ts| | | | |dirt+lighter| | | | |ts||- ||ts| | | |dirt+lighter|si-n |dirt+lighter| | | |ts||- ||ts| | | | |dirt+lighter| | | | |ts||- ||ts| | | | | | | | | |ts||- ||ts|ts| | | | | | | |ts|ts||- ||ts|wa|ts| | | | | |ts|wa|ts||- || |ts| | | | | | | |ts| ||- ||||||||||||||- |----Level1\u0026#39; (上一层)|- |||||||st+lighter|||||||- ||rd-se!|rd-ew!|rd-ew!|rd-ew!|rd-ew!|rd-new!|rd-ew!|rd-ew!|rd-ew!|rd-ew!|rd-sw!||- ||rd-ns!|fa+lighter|fa+lighter|fa+lighter|fa+lighter|fa+lighter|fa+lighter|fa+lighter|fa+lighter|fa+lighter|rd-ns!||- ||rd-ns!|fa+lighter|fa+lighter|fa+lighter|fa+lighter|fa+lighter|fa+lighter|fa+lighter|fa+lighter|fa+lighter|rd-ns!||- ||rd-ns!|fa+lighter|fa+lighter|fa+lighter|fa+lighter|fa+lighter|fa+lighter|fa+lighter|fa+lighter|fa+lighter|rd-ns!||- ||rd-ns!|fa+lighter|fa+lighter|fa+lighter|fa+lighter|fa+lighter|fa+lighter|fa+lighter|fa+lighter|fa+lighter|rd-ns!||- ||rd-ns!|fa+lighter|fa+lighter|fa+lighter|fa+lighter|wa+lighter|fa+lighter|fa+lighter|fa+lighter|fa+lighter|rd-ns!||- ||rd-ns!|fa+lighter|fa+lighter|fa+lighter|fa+lighter|fa+lighter|fa+lighter|fa+lighter|fa+lighter|fa+lighter|rd-ns!||- ||rd-ns!|fa+lighter|fa+lighter|fa+lighter|fa+lighter|fa+lighter|fa+lighter|fa+lighter|fa+lighter|fa+lighter|rd-ns!||- ||rd-ns!|fa+lighter|fa+lighter|fa+lighter|fa+lighter|fa+lighter|fa+lighter|fa+lighter|fa+lighter|fa+lighter|rd-ns!||- ||rd-ns!|fa+lighter|fa+lighter|fa+lighter|fa+lighter|fa+lighter|fa+lighter|fa+lighter|fa+lighter|fa+lighter|rd-ns!||- ||||||||||||||- ||||||||||||||- {% endminecraft %} 图示说明：\nP代表作物塔管道出口，上层以及本层的作物通过该出口落向下一层。 严格来说小麦塔只有四层高，在叠加的时候，第0层是可以与下一层重合的。 第0层的四个泥土只有放告示牌的是必须的，其他的都可以不要，放在这只是为了对称，以及可以插下一层的火把~~ 第3层周围的石头代表走道。 标为S的半砖是下半砖，第2层唯一一个上半砖可以作为台阶，用来跳上走道 最顶层Level1\u0026rsquo;其实是上一层的Level1。 小麦塔中间的泥土9x9的尺寸是由一格水可以灌溉周围四格以内的耕地所决定的。\n收割的原理非常简单，当信号切换后，活塞不再激活，活塞头收回，水下流，把小麦冲到中间的水源里。之后小麦会掉落下去或者被漏斗收集。中间的告示牌用来阻挡水下流。红石信号通过示意图上端的红石火把向上传递，小麦塔四层的高度可以保证它可以正确累加而信号没有错误。\n全自动小麦塔 村民农场也称全自动小麦农场，顾名思义完全不需要人为操作，会自动产生作物。这个方案实现全自动是靠村民用爱发电。村民会自动照顾作物，并且村民在一定情况下会向其他农民扔作物，利用这个特性就可以从村民手里骗吃的了2333。更棒的一点是村民在仍作物时会自动用小麦合成面包，这样连合成的时间都能省啦~\n不过由于需要村民，因此找到村庄是前提条件，并且还要花大力气把村民运到家里（一般是通过矿车捕获村民，然后通过下界铁路运送回来）。但其实只要有两个村民就能开始繁殖，然后就一劳永逸了~\n村民小麦塔的结构如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 {% minecraft 俯视图 %} |----Level0|- ||||||||||||||- ||||||||||||||- ||||||||||||||- ||||||||||||||- ||||||||||||||- ||||||||||||||- ||||||||||||||- ||||||||ab||||||- ||||||||||||||- ||||||||||||||- ||||||||||||||- ||||||||||||||- ||||||||||||||- |----Level1|- ||||||||||||||- ||||||||st||||||- ||||||||st||||||- ||||fa |fa |fa |fa |fa |fa |fa |fa |fa ||- ||||fa |fa |fa |fa |fa |fa |fa |fa |fa ||- ||||fa |fa |fa |fa |fa |fa |fa |fa |fa ||- ||||fa |fa |fa |fa |fa |fa |fa |fa |fa ||- ||||fa |fa |fa |fa |wa |fa |fa |fa |fa ||- ||||fa |fa |fa |fa |fa |fa |fa |fa |fa ||- ||||fa |fa |fa |fa |fa |fa |fa |fa |fa ||- |||ho-d|fa |fa |fa |fa |fa |fa |fa |fa |fa ||- ||st|ho-n|ho-w|fa|fa|fa|fa |fa |fa |fa |fa ||- ||||||||||||||- |----Level2|- ||||||||||||||- |||||||ab|fg-ew|ab|||||- |||ab|ab|ab|ab|ab|fg-ew|ab|ab|ab|ab|ab|- |||ab||||| |||||ab|- |||ab||||| |||||ab|- |||ab||||| |||||ab|- |||ab||||| |||||ab|- |||ab||||| |||||ab|- |||ab||||| |||||ab|- |||ab||||| |||||ab|- ||ab|ho-d||||| |||||ab|- |ab|V|ab||||| |||||ab|- ||ab|ab|ab|ab|ab|ab|ab |ab|ab|ab|ab|ab|- |----Level3|- ||||||||||||||- ||||||||||||||- |||ab|ab|ab|ab|ab||ab|ab|ab|ab|ab|- |||ab||||| |||||ab|- |||ab||||| |||||ab|- |||ab||||| |||||ab|- |||ab||||| |||||ab|- |||ab|||||ab+lighter |||||ab|- |||ab||||| |||||ab|- |||ab||||| |||||ab|- ||ab|ho-d||||| |||||ab|- |ab|V|ab||||| |||||ab|- ||ab|ab|ab|ab|ab|ab|ab |ab|ab|ab|ab|ab|- {% endminecraft %} 标注V的地方需要囚禁一个身上没有作物的农民进去（比如刚出生的），此外还要在农田区域内放另一个农民。可以看到村民农场比水流农场要矮一层，更加紧凑了。不过由于是用漏斗收集作物，因此物品的传输需要使用漏斗管道。\n这个作物塔的原理是，村民会主动照料周围一定范围内的耕地，并且当它发现附近（可以穿透方块）有农民身上没有什么作物的话它可能会把作物扔给较穷的农民。因此我们只要保证一个一直很穷的农民在吸引他扔食物即可~~~~简直是地主剥削~~。两个栅栏门的作用是便于出入并防止农民跑出来。\n漏斗转移装置 由于村民农场的收集方式为漏斗，如果要与下层的水流收集的作物层叠加的话需要把漏斗中的物品转移到水流中。转移可以使用一个自动喷射装置，如下所示：\n1 2 3 4 {% minecraft 俯视图 %} |rd-se!|rd-ew!|rd-sew!|dirt+darker+rd-ew!|- |rd-ne!|rr-w1!|rs-w! |dr-s |- {% endminecraft %} 其中泥土上的红石比其他红石要高一层（即在发射器上表面那一层）。比较器是否激活都可以。将漏斗管道的出口接到发射器中，发射器会自动把物品喷射到指定方向。将发射器出口放一个水流，即可完成漏斗管道到水流收集的过渡。\n自动喷射的原理是当发射器中有物品时，发射器会从后端向比较器输入信号，激活比较器自身构成的时钟电路。时钟电路再通过图中的泥土块激活发射器。只要发射器中有物品，时钟电路便会一直运行，直到将物品清空。\n","date":"2017-08-22T00:00:00Z","permalink":"https://zyxin.xyz/blog/2017-08/MCTowerWheat/","title":"Minecraft - 集成作物塔 - 小麦"},{"content":"周围很多人对Word中输入公式的方式非常不满，认为在Word中打公式太慢，因而转投LaTeX。每当发现这样的情况，我就会告诉他们其实Word现在输入公式已经可以非常快了，而且相比TeX，可以实时预览能方便太多！我的大部分复变笔记就是在Surface上全部用Onenote输入的。然而坑爹的就是Word对公式输入的帮助非常少，很难搜到详细的文档（好吧我被打脸了，这里有官方文档：英文|中文）。因此此文的目的就在于详细展示一下Word中快速输入公式的技巧，造福广大苦逼工科生。\n在Office2010之前的早期版本，Word中的公式是MathType通过“域”的方式插入的（类似于在Word中插入Visio图表的样子），实际渲染时直接是生成图片，而如果需要编辑的话得在外部程序MathType中编辑。这个方式有很多弊端，一很丑，二生成的pdf的公式是图片，三操作很不方便。而在近期的Office版本中公式输入大有改进，并且在PPT、Onenote（包括Win10的UWP版）等Office软件中已经全面支持native体验的公式输入（公式编辑器貌似被称作UnicodeMath，在Office大部分产品中都已包含），现在我打公式的速度已经起飞了。\n基本操作 在Word中任意位置按下Alt+=（Mac中是Control+=）可以切换公式编辑，或者选中文字按下Alt+=把它变成公式，再按Ctrl+I可以设置成斜体。输入内置公式或者拷入的公式可以按Enter可以整体格式化。对于格式化的公式可以选择“线性”格式查看原始文字。在公式编辑中，快捷命令通过空格可以立即转换成格式化后的公式形式，因此当公式没有按照你想要的形式生成时可以按空格试试。\n例如内置公式(a+b)^n=∑_(k=0)^n▒〖(n¦k) a^k b^(n-k) 〗，选中它后按下Alt+=，然后把光标移到末尾按回车即可变成格式化的公式： $$(a+b)^n=\\sum_{k=0}^n\\binom{n}{k}a^kb^{n-k}$$\n在Word公式中有一些内置的函数识别（例如sin、exp），这些函数的名字打完后按空格会自动生成公式块，并且取消函数名称的斜体显示。即$sin$ → $\\sin\\square$\n内置的函数名的列表可以在Word的公式选项中“可识别的按钮”面板中查看\n快捷命令 公式输入有不少快捷命令（转义符），熟练掌握就能大大提高速度。\nNote: 在下面的命令中，空格是很重要的。如果代码中有空格的话代表在Word中输入时也要按下空格。\n常规符号 在Word的公式工具栏中，鼠标移到工具栏符号列表中的符号上即可看见符号的意义和快捷命令。（不过不是所有符号都有快捷键）\n例如在上图中，小于等于的快捷输入方法是\\le、\\leq和\u0026lt;=，其中输入\u0026lt;=会自动转换成该符号，而另外两个需要输入后按空格才会立即转换（不按的话在继续输入公式时也会转换）。\nTips\n变体字母有三种：手写体（\\script$），花体（\\fraktur$），双线（\\double$），其中$为任意字母（大小写是对应的）。这三种字母应用在不同的场景，需注意区分。如\\doubleR($\\mathbb{R}$)为实数，\\scriptR($\\mathcal{R}$)为黎曼积分，\\frakturR($\\mathfrak{R}$)为实部。部分字母的双线形式可以直接通过\\$$打出（如\\jj → $\\mathbb{j}$，\\Dd → $\\mathbb{D}$） 〈与TeX相同〉希腊字母的快捷命令，小写开头为小写，大写开头为大写：\\gamma → γ \\Gamma → Γ。个别字母有多种小写，如\\phi → $\\phi$ | \\varphi → $\\varphi$。这样的字母有\\varepsilon \\varphi \\varpi \\varrho \\varsigma \\vartheta。 〈与TeX相同〉积分符号、导数等是可以累计的：\\int \\iint \\iiint \\oint \\oiint \\dot \\ddot \\prime \\pprime 括号 括号会默认配对和自动封闭，如果需要输入不自动配对的括号，或者转义括号，请使用命令输入括号，而不是直接打（括号的快捷命令见下文）。\n如果只有一边括号，使用位置符可以\\open \\close或\\begin \\end封闭括号块： {5x\\close结果为$\\{5x$，\\open5x}结果为$5x\\}$。当然，直接打{5x也是可以的，但是这样的话5x和{会在同一级，而如果封闭括号块后5x会被包在一个公式块内，并且可以自动根据括号内内容调整大小。\n例：123\\open 45\\close =123\\begin 45\\end =123〖45〗 =123\\box 45 → $123\\boxed{45}$\n排版符号 位置格式符： \\above: 位于上方 （显示为 $\\perp$ ，即\\perp/\\bot） \\below: 位于下方 （显示为 $\\top$ ，即\\top） \\left: 位于左侧 （显示为 $\\vdash$ ，即\\vdash） \\right: 位于右侧 （显示为 $\\dashv$ ，即\\dashv） \\atop: 上下排列 （显示为 ¦ ） \\rect: 矩形方框 \\matrix: 矩阵 \u0026amp; \\eqarray：多行公式 \u0026amp;: 换列（可以看作\\t，对应TeX的\u0026amp;） 也可以作为参数分隔：\\sqrt(5\u0026amp;2) → $\\sqrt[5]2$ @: 换行（可以看作\\n，对应TeX的\\\\） 例：\\matrix (A\u0026amp;B@C\u0026amp;D) → $\\begin{array}{lc}A\u0026amp;B\\\\C\u0026amp;D\\end{array}$ \\of：构建子区域，用于文字运算的表达 例：cov \\of (A^T A) → $\\mathrm{cov}\\left(A^TA\\right)$ Tips 多行公式可以利用\u0026amp;指定对齐位置：\n\\eqarray (x+y\u0026amp;=2@x+y+z\u0026amp;=3@z\u0026amp;=5) $$\\begin{array}{rcl}x+y\u0026amp;=\u0026amp;2\\\\x+y+z\u0026amp;=\u0026amp;3\\\\z\u0026amp;=\u0026amp;5\\end{array}$$ \\eqarray (\u0026amp;x+y=2@\u0026amp;x+y+z=3@\u0026amp;z=5) $$\\begin{align}\u0026amp;x+y=2\\\\\u0026amp;x+y+z=3\\\\\u0026amp;z=5\\end{align}$$ 多行公式对齐也可以用Shift+Enter换行之后，右键在菜单中选定指定位置对齐。不过此方法只能指定一个对齐位置。\n使用\\Vmatrix开头可以直接输入竖线包围的矩阵：\n\\Vmatrix (A\u0026amp;B@C\u0026amp;D) $$\\begin{Vmatrix}A\u0026amp;B\\\\C\u0026amp;D\\end{Vmatrix}$$ 自动合并 在公式输入时，有不少的符号会自动合并，便于你输入一些常用符号。如之前所说，这些快捷方式都能在工具栏的提示框中可以找到，但是由于不好找，这里还是总结一下:\n+- → $\\pm$, -+ → $\\mp$ ... → $\\ldots$ /= → $\\neq$, ~= → $\\cong$, /~= → $\\ncong$ := → $\\mathrel{\\vcenter{:}}=$ /\u0026gt; → $\\ngeq$, /\u0026lt; → $\\nleq$ \u0026gt;\u0026gt; → $\\gg$, \u0026lt;\u0026lt; → $\\ll$ \u0026gt;= → $\\geq$, \u0026lt;= → $\\leq$ -\u0026gt; → $\\rightarrow$, \u0026lt;- → $\\leftarrow$ \u0026gt;- → $\\succ$, -\u0026lt; → $\\prec$ (好像只有OneNote支持) =\u0026gt; → $\\Rightarrow$ (好像只有OneNote支持) 工具栏中常用结构的输入 分数 $\\frac{A}{B}$ ← A/B AB ← A\\sdiv B $A⁄B$ ← A\\ldiv B $\\partial A$ ← \\partial A（偏导） 上下标 $A^B$ ← A^B $A_B$ ← A_B $A^B_C$ ← A^B_C $_C^BA$ ← (_C^B)A 根式 $\\sqrt A$ ← \\sqrt A $\\sqrt[B]A$ ← \\sqrt (B\u0026amp;A) 或 \\root B\\of A $\\sqrt[3]A$ ← \\cbrt A $\\sqrt[4]A$ ← \\qdrt A 积分、大型运算符 $\\int A$ ← \\int \\of A $\\int^B_C A$ ← \\int^B_C\\of A Tips\n积分号可以换成如下符号：〈与TeX相同〉 积分: \\int \\iint \\iiint \\oint \\oiint \\oiiint \\coint \\aoint 求和/积: \\sum \\amalg \\prod \\coprod 逻辑: \\bigcap \\bigcup \\bigsqcup \\bigvee \\bigwedge 转换这两种形式的符号有两种方法： 右键积分符号 右键菜单中还有隐藏上下限等选项。 在公式选项页面卡中 （前提是公式显示为“显示”模式而非“内嵌”模式） 括号 $\\left(A\\right)$ ← (A) $A)$ ← \\open A) $(A$ ← (A\\close $\\left(A\\vert B\\right)$ ← (A\\vbar B) （分隔符能分割出两个公式块） $\\binom{A}{B}$ ← (A\\atop B) $\\left\\{\\begin{aligned}A\\\\B\\end{aligned}\\right.$ ← {\\matrix (A@B)\\close 括号有如下选择：\\bra \\ket \\langle \\rangle \\Rangle \\lbrace \\rbrace \\lbbrack \\Rbrack \\lbrack \\rbrack \\lceil \\rceil \\lfloor \\rfloor \\vert \\Vert \\lmoust \\rmoust\n导数符号（上下标） $\\overrightarrow A$ ← A\\vec 相同用法的符号有：\\dot \\ddot \\dddot \\bar \\Bar \\ubar \\Ubar \\vec \\lvec \\hvec=\\rhvec \\lhvec \\tvec \\hat \\tilde，以及音标符号：\\grave \\acute \\breve \\check\n$\\overbrace A^B$ ← \\overbrace A\\above B 相同用法的符号有：\\overbar \\overbrace \\overbracket \\overline \\overparen \\overshell\n$\\underbrace A_B$ ← \\underbrace A\\below B 相同用法的符号有：\\underbar \\underbrace \\underbracket \\underline \\underparen\n$\\boxed A$ ← \\rect A 极限和对数 $\\log_B\\left(A\\right)$ ← log_B A limBA ← lim\\below B A 或 lim_B A min、max、sup、inf等用法类似\n运算符 $\\overset{def}{=}$ ← \\defeq， $\\overset\\cdot=$ ← \\doteq， $\\overset\\Delta=$ ← \\Deltaeq $\\xrightarrow A$ ← \\rightarrow \\below A $\\xleftarrow[A]{}$ ← \\leftarrow \\above A 可以替换的箭头符号：\\leftarrow \\Leftarrow \\leftharpoondown \\leftharpoonup \\rightarrow \\Rightarrow \\rightharpoondown \\rightharpoonup \\leftrightarrow \\Leftrightarrow \\Longleftarrow \\Longleftrightarrow \\Longrightarrow \\lrhar\n矩阵 $\\begin{array}{ccc}A\u0026amp;B\u0026amp;C\\\\D\u0026amp;E\u0026amp;F\\end{array}$ ← \\matrix (A\u0026amp;B\u0026amp;C@D\u0026amp;E\u0026amp;F) 常用占位符: $\\cdots$ ← \\cdots $\\ddots$ ← \\ddots $\\vdots$ ← \\vdots ⋰ ← \\rddots $\\dots$ ← \\dots 或 \\ldots 例：与括号结合：(\\matrix (A\u0026amp;\\cdots \u0026amp;B@\\vdots \u0026amp;\\ddots \u0026amp;\\vdots @C\u0026amp;\\cdots \u0026amp;D) ) → $\\begin{pmatrix}A\u0026amp;\\cdots\u0026amp;B\\\\\\vdots\u0026amp;\\ddots\u0026amp;\\vdots\\\\C\u0026amp;\\cdots\u0026amp;D\\end{pmatrix}$\n预置公式 \\binomial: 二项式展开 \\identitymatrix: 单位矩阵 \\integral: 某积分式 \\limit: e的极限定义式 \\quadratic: 一元二次方程根 在工具栏里没有显示出来的命令还有很多，比如空格命令：\\nbsp \\thicksp \\thinsp \\vthicksp \\zwnj \\zwsp\n其他技巧 快捷命令列表 对于Word中符号的快捷命令，有很多都是与TeX相似的，因此可以参照TeX的符号列表查找符号的输入。此外，还可以参考前文提到的很全面的官方参考文档，以及在百度我搜到的唯一一份介绍Word公式快捷输入的文档，这里面有一部分命令的列表。\n工具栏内所展示的快捷命令其实不完全，Word中所有内置的快捷命令可以通过“公式选项”→“数学符号自动更正”菜单进行查看，不过这里面的列表可读性太差，因此不推荐使用。 使用MathML来进行TeX与Word公式的转换 MathML是一种用于描述公式的XML语言，十分强大，公式的描述能力要强于Word与TeX，但缺点就在于过于繁杂。MathML格式的公式可以直接拷贝进Word公式编辑中，因此如果需要在TeX与Word公式之间进行转换的话，可以先将TeX公式渲染为MathML，然后将MathML导入Word。这里推荐一个网站：Wiris Editor\n此外在Word2016以后，已经直接支持内置公式与TeX公式的转换了。详见官网。\n公式自动编号 编写论文时经常会遇到公式自动编号的问题，这是很多人转投TeX的另一个原因。但其实在Word里实现公式自动编号也很简单，可以用一个无框表格把公式包起来，第一个单元格放公式，第二个单元格放编号。编号可以用自定义的编号样式来完成，设定好编号以后输入新公式时编号使用同样的样式即可完成自动编号了。\n其他资料 Unicode Nearly Plain-Text Encoding of MathematicsVersion 3 Word数学符号输入手册 常用数学符号的 LaTeX 表示方法：可以参考里面的符号命令，与Word是基本一致的。 MathML与LaTeX生成器 本文介绍了一下Word中公式输入的快捷键，Office中有很多没有well-documented的功能，大家可以多去挖掘挖掘，能够有效提高效率~\n","date":"2017-08-22T00:00:00Z","permalink":"https://zyxin.xyz/blog/2017-08/WordMath/","title":"Word - 快速输入数学公式"},{"content":"BUD 方块更新感应器（Block Update Detector, BUD）是Minecraft中绝大部分自动设备的部件，它能够检测方块的更新并产生一次脉冲。因此掌握方块更新是制造自动设备的必备技能~\n不过让我郁闷的是，1.11中引入了一个萌萌的方块叫做侦测器，能起到类似BUD的效果。不过由于侦测器的检测范围比BUD小，以及BUD有感应器与执行器可以用同一个方块的优点，灵活性高，因此部分场合还是需要BUD上场，然而对于作物塔中作物生长的检测来说，侦测器其实已经完全足够了。（原本Tricky的方法被官方支持应该是件好事，然而我还是无法避免地感到郁闷。。）\nBUD的基本原理是将红石电路置于一种本应不稳定的状态（即通过不同的方式推导线路状态能得到不同的结果），此时电路中的一些处于“叠加态”的结构会停止对电路的变化产生反应（其中本应产生反应的方块即为感应器，一般为活塞），而当感应器周围方块有更新时，电路会重新运行而使得结构被改变且重新复原（之后又会停止反应），这个过程可以产生红石信号。\nBUD的一种替代是高频时钟电路，通过不断地暴力尝试而产生类似BUD的效果。替代的前提条件是没有方块更新时，电路信号不会产生额外的破坏。有些情况下，方块更新地过于频繁，使得更新方块本身也成为了BUD开关，或者BUD电路的执行器和感应器产生冲突，这时就只能使用高频信号了（e.g. 刷石机）。\nBUD的实现方式很多，一般会根据密排和材料的需要选择对应的BUD。BUD通常需要粘性活塞或者活塞加下落物使得电路复位。下面介绍几种我常用的BUD形式（由于活塞激活的方式较多，因此BUD结构的灵活性很大，每种方案都可以有很多放置方法，只展示其中最便于描述的一种）：\n粘性活塞 + 红石火把 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 {% minecraft 侧视图 %} |----基本式|- | |rd-$ |rd-$ | |- |rd-$ |AB |AB |rt-$w! |- |AB |rr-$w1 | |rd-$! |- | |AB |AB |AB |- | | |sp-n | |- |----扩增式|- | |rd-$ |rd-$ | |- |rd-$ |AB |AB |rt-$w! |- |AB |rr-$w1 | |rd-$! |- | |AB |AB |AB |- | | |sp-n | |- | | | |sp-w |- {% endminecraft %} 在活塞四周产生的方块更新会被感应到（在扩增式中两个活塞都能起感应作用）。如果活塞用普通活塞，而用沙子作为活塞上方的方块的话，这个电路就会变成高频时钟电路。\n这个装置的BUD原理是，中间一层右端激活的红石会使得下方的方块充能，活塞被激活（活塞激活的范围可以参考wiki活塞页面和红石页面）活塞激活后会推动上方方块，方块被右端红石充能，使得中间层左侧的电路被充能，这会导致红石火把熄灭，导致中间一层右端激活的红石不再被充能而熄灭。电路产生了矛盾进入不稳定状态，产生了BUD效果。\n(粘性)活塞 + 容器 1 2 3 4 5 6 7 8 9 10 {% minecraft 侧视图 %} |----后部|- | | |rd-$! |rd-$! |- |rd-$! |rr-$e1!|AB |AB |- |AB |AB | | |- |----前部|- | | | | |- |AB |rc-$w! |AB |fu-$s |- |AB |AB |sp-n |pi-u |- {% endminecraft %} 这个BUD方案的好处在于结构精简。左边的活塞是粘性活塞（可以换成普通活塞+下落物），两个活塞都是感受器。容器可以是任何可以产生信号的容器，熔炉、箱子、漏斗都可以，需要在容器中放至少一个物品使得其可以产生信号。该BUD的原理是容器产生的信号通过比较器与中继器的放大，连接到活塞上方方块的背后。本来在这种情况下活塞是被激活了的，会推动上方方块，但是如果上方方块被推动就会导致信号截断，不能传导到背后，这就形成了BUD开关，原理与上个方案相似。\n中继器在这个结构中起到的作用是延长信号（因为比较器产生的信号可能很弱），但通过调节它的刻度也能够调节BUD复位的速度。\n相比利用侦测器制造的自动甘蔗机，BUD方案可以在甘蔗生长出第二格时立即首歌，并且可以通过BUD的延长来精简体积。\n活塞 + 红石块 由于粘性活塞较难获得（单机玩根本就找不到史莱姆好吗），因此再介绍一种替代方案。“粘性”在电路中的作用是让截断方块复位，因此可以通两个活塞对置来实现复位。下面就是一种普通活塞与红石块结合产生BUD的方案：\n1 2 3 4 5 6 7 {% minecraft 侧视图 %} |rd-$ |AB |pi-s | |- |AB |rr-$e1 | | |- | |AB |br |rd-$! |- | | |AB |AB |- | | |pi-n | |- {% endminecraft %} 同样，在这个电路中活塞是感应器。\n粘性活塞 + 下落物 如果要使用下落物（沙子、沙砾）来做BUD的话，仍然需要粘性活塞来复位。相比于其他BUD方案，使用下落物的特点在于BUD反应很快，但是复位较慢（下落速度较慢）。一种典型的结构如下\n1 2 3 4 5 {% minecraft 侧视图 %} |rd-$!|sand|rr-$w1!|ab|le-$w!|- |ab |gs |ab | | |- | |sp-n| | | |- {% endminecraft %} 沙子代表下落物（还可以是沙砾），萤石代表不充能的透明方块（还可以是玻璃、海晶灯等）。这个方案还有个特点是体积小，但是噪音会比较大233\nBUD的扩增（延长） 在前面的BUD方案中提到了BUD的扩增，这是一种非常实用的设计。这里的BUD扩增指的是感应器的增加与延长，而不仅仅是红石线路的延长。\n搭建好基础的BUD后，可以在感应器（一般是活塞）周围再放置一个活塞，并让活塞可以被BUD电路的执行器一段激活（例如第一个BUD例子和第二个BUD例子所示）。这种情况下，新加入的活塞受BUD电路的激活本应推动空气，但活塞的动作会导致基础BUD的感应器周围产生更新（出现了活塞头），导致BUD电路中断，这样就可以让新活塞也成为了BUD的一部分。\n再用示意图举一个双排扩增BUD的例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 {% minecraft 俯视图 %} |----Level1|- ||||||- ||pi-s|pi-s|pi-s||- |pi-n||||pi-u|- |pi-w|||pi-n||- |pi-w|||pi-w||- |pi-w|||pi-w||- |ellipsis-ns|||ellipsis-ns||- |----Level2|- ||||||- ||||||- ||ab|ab|ab|ab|- ||ab|||ab|- ||ab|||ab|- ||ab|||ab|- ||ellipsis-ns|||ellipsis-ns|- |----Level3|- ||||||- |||||ab|- ||rd-se!|rd-ew!|rd-ew!|br|- ||rd-ns!|||rd-ns!|- ||rd-ns!|||rd-ns!|- ||rd-ns!|||rd-ns!|- ||ellipsis-ns|||ellipsis-ns|- |----Level4|- |||||ab|- |||||rr-n1|- |----Level5|- |||||rd|- |||||ab|- |||||pi-d|- {% endminecraft %} 这个技巧是BUD优于侦测器的特点之一，因此在之后的文章中作物塔的自动收割还是通过BUD实现（其实是因为之前没玩过1.9以后的版本），不过改成侦测器的话应该也不会太难，并且也可以降低电路复杂度。\n红石布线 红石电路之所以困难，原因之一是布线非常麻烦，由于Minecraft是方块化的，因此布置红石有一定的限制，不像Altium之类的那样方便。这里也简单介绍一下红石布线的技巧。\n信号向上传递 参见Wiki纵向传输页面\n作物塔很高，如果使用半自动设备，并且希望在底部操作开关的话就会遇到红石信号向上传递的问题。此外在布置红石电路的时候也会遇到向上传递的需求。\n信号纵向传递主要有以下几种方式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 {% minecraft 侧视图 %} |----阶梯式|- |rd-$! | | |- |AB |rd-$! | |- | |AB |rd-$! |- | | |AB |- |----红石火把（向上）|- | |rt-$ | |- | |AB | |- | |rt-$! | |- | |AB | |- |----红石火把（向下）|- |AB |rt-$w! | |- | |rd-$! | |- |rt-$e |AB | |- |rd-$ | | |- |----半砖|- | |rd-$! | |- |rd-$! |ts-$ | |- |ts-$ |rd-$! | |- |rd-$! |ts-$ | |- |----萤石|- | |rd-$! | |- |rd-$! |gs | |- |gs |rd-$! | |- | |gs | |- {% endminecraft %} 原理是半砖和萤石可以交叉向上连接红石而不阻隔信号，红石火把能充能上方或下方的方块。红石火把传递的方案有一个限制就是纵向传递会使信号交替改变（红石火把相当于非门），因此如果要保持信号不变的话需要使红石火把的层数为奇数。\n这里面最常用的方法是半砖电路和红石火把，廉价并且占地小。\n密集布线 在集成化的过程中，密集布线经常会让人头疼。如何使红石电路占地最小并且隔离其他电路的影响是集成的关键。布线据我所知没有一个统一的方法，但是有如下一些要点：\n在斜交叉时不透明方块会阻断线路，透明方块不会 1 2 3 4 5 6 7 8 {% minecraft 侧视图 %} |----不连通|- |rd-$ |AB |- |AB |rd-$! |- |----连通|- |rd-$! |glass |- |AB |rd-$! |- {% endminecraft %} 注意避免红石在规划外的地方出现上下两层相连的情况 当两条不同的红石线路并排时使用继电器可以将两条线路隔离 在集成自动机构时，尽量使得红石机构位于一个平面内，这样有利于机构的密排，密排时适当错位避免以错误的红石连接。 作物塔后处理 物品分类 在我的作物塔中，所有作物都是水流汇集后通过一个漏斗收集的，如果仅仅放在一个箱子里会比较乱，不利于取用（如果你有MOD就当我没说）。因此在最后接一个分类系统是不错的选择。\n物品分类系统有很多的实现方式，在这里介绍非常朴素而古老的一种，利用漏斗的信号控制来使得漏斗中的物体保持一定的量，再利用漏斗只能叠加同类物品来进行分类。\n基本原理是漏斗中每1/3组物品会输出1个信号强度，以及如果漏斗五格都有物品，漏斗只会吸收它所含有的物品类型。因此可以通过占位物品实现分类，输出信号控制开关，避免占位物品也被吸收走。\n具体的结构如下：\n1 2 3 4 5 6 7 {% minecraft 侧视图 %} |----单层分类器截面|- |S |ho-$s | | | |- |C |ho-$d |AB |rc-$e! |AB |- |ch-$ |ho-$w | |ts-$ |rd-$! |- | |rt-$e! |AB |rd-$! |AB |- {% endminecraft %} 其中S漏斗是物品收集管道，C是分类装置。C漏斗需要在其中预先放置好需要分类的物品和占位物品。例如如果要分类仙人掌，用木棍作为占位物品，则可以放置成如下样式\n当S漏斗有物品通过时，物品会优先向下漏。如果是仙人掌，那么就会漏进C与原有的仙人掌叠加，如果不是，由于占位物品的存在则无法漏入（除非通过的物品是占位物品）。这就实现了分类功能。而红石电路能够保证C漏斗中物品数少于1/3组时不继续下漏，能够保护占位物品不被漏掉。\nC漏斗中，第一格放上需要分类的物品，一个即可，剩下四格放占位物品（什么都可以），但总量不要超过1/3组。占位物品越多，漏斗中残余的分类物品（这里是仙人掌）就越少。但如果少到没有了，那这个分类器也就失效了。\n物品自动搬运 当物品从作物塔中收集下来以后，如果作物塔离储存物资的地方比较远，可以通过物品搬运系统来进行自动转移。一般这种功能是通过运输矿车来实现的。具体的红石设计在Wiki里面讲的已经很清楚了，这里就不再赘述~\n物品下漏限制 这个功能是个小trick。当漏斗管道接上熔炉进行燃烧的时候，如果漏斗管道中的物品生产较慢，则会导致熔炉中的燃料极大浪费。这个时候可以通过限制物品下漏来使得进入熔炉中的物品不会太少。\n下面这个装置可以实现当物品数量达到23以后才会继续下漏：（该方案仅支持可烧制的物品，如果混入不可烧制的物品则会无效）\n1 2 3 4 5 6 7 8 9 10 11 12 13 {% minecraft 俯视图 %} |----|- |rd-se!|rd-ew!|rr-w1!|rd-ew!|rd-ew!|rd-sw!|- |rr-s1!|rr-w1|rd-ew|||rd-ns!|- |ab|ab|ab|ab|ab|rd-ns!|- |ho-d|rc-e|rd-sew|rr-e1|ab|rr-n1!|- |||rd-ne|rr-e1|ab|rt-w!|- |----|- |||||||- |||rt-s||||- |rd-ew!|rd-ew!|ab|rd-ew|rd-sw|ab|- |S||||rt||- {% endminecraft %} 选取数字23是因为这是它在比较器产生的信号阶梯中物品数量较少时最接近8的倍数，因此能够较好地节省煤炭。（当漏斗中有2组又32个物品时刚好可以产生8格信号，但是这会使得红石线路体积增大，并且增长物品处理周期，因此还是选用了23个物品产生2格信号的方案。）当然，如果使用别的燃料的话可以针对性地延长从比较器到中继器中间的红石，就可以挑选最省燃料的下落限制值了。（各种燃料一次能烧多少个物品见Wiki）\n以上就是在作物塔中使用到的基本红石原理，如果看不太懂没关系，作物塔搭出来就能慢慢理解了233~接下来就会介绍作物塔的详细构造了。\n","date":"2017-08-21T00:00:00Z","permalink":"https://zyxin.xyz/blog/2017-08/MCTowerRedstone/","title":"Minecraft - 集成作物塔 - 红石基础"},{"content":"由于最近暑研比较闲，在油管上又开始刷Minecraft红石视频，于是捡起Minecraft又开始玩了。想想Minecraft也陪伴了我很久，于是决定把之前在MC里面捣鼓的东西都写下来，希望珍贵的回忆不要就这么淡去。。\n玩Minecraft也有快五年了，最早应该是在高二听说了这个游戏，那个时候版本好象还是1.3，下载一看这么辣鸡的画质就立马弃掉了o(￣ヘ￣o＃)~后来是在学OI的时候在学长机器里发现了1.5的工业神秘整合包！打开他的存档发现了一堆电路和核弹，顿时仿佛打开了新世界的大门，玩得不亦乐乎，不过那时还是玩的创造模式。后面进了大学才有精力开始认真玩，进了烟花服，纯净生存，一周目快结束玩到三周目中后期，快两年的时间也算是老玩家了可惜后面关服了。这期间也试过很多著名的Mod，如工业IC(IndustrialCraft)、通用电力UE(Universal Electricity)、神秘TC(Thaumcraft)、和风Bamboo、暮色TF(The Twilight Forest)，还有枪战、女仆等很多小Mod。MC的Mod多如牛毛，BC(BuildCraft)、以太(Aether)、Avalon、超多地形等等都没有去试，光是一个神秘就能玩几个月。\n在烟花服务器玩的是1.7.10~1.8.3，其中1.7.10这个版本应该是Mod最全的版本了，除了和风其他Mod都能打上。玩了两个周目非常开心，一个人玩的MC和大家一起玩的MC完全不是一个游戏。后面也加了次世代的MC服务器，但是感觉里面大家的创造还是没有烟花服的多，可惜前几天联系包子才知道烟花服已经解散了。本来腐竹是非常友好的，可能是被某些个熊孩子气的不行了吧。。但这就导致很多超漂亮的摄影和存档我都没有保存下来。。。还好包子那里下载了存档，因此我还能回头看看我在花费最多精力的三周目里的成果。于是我决定把在MC里面做的一些小玩意都记录下来，避免以后再懊恼和可惜（以及怕以后不会造了233）！\n博客里的Minecraft系列一方面会回忆之前的一些东西，也会把新的东西记录下来（前提是我还一直在玩233）。\n贴一些之前电脑里仅存的珍贵截图怀念一下：\n三周目里和sai一起搬运的大教堂，死了好几次。地下还有个超大型农民交易所\n当初我的得意作品之一：圣诞树。说实话树是最难造的，要不规则的同时还要好看真的是很矛盾。我觉得我可能造不出第二颗这么匀称好看的树了。（这两张是从存档里截的，当初在刚建成时专门拍的圣诞树照片已经随着群的解散而逝去了。\nrenzhen还是谁在山顶造的百格高巨树，树干直径就有四五十格。（所以我才说树是最难造的）\n最后，如果你也想入坑MC的话，推荐以下几个资源：\nHMCL : 应该是最流行的第三方启动器了，很好用。 Minecraftforum/MCBBS : 各路大佬都会在这里发帖，MOD、技术、技巧等等，可以多围观一下。 MCWiki [en/zh] : 完全相当于技术手册了，对原版MC的内容阐释的很全，并且有详细的教程。（本体是英文版的） MCMod : 收集Mod比较全的一个网站。（这有个国外版，但感觉根本不全。。） NameMC/SkinMe ：找皮肤的网站~（NameMC有很多其他功能） ","date":"2017-08-18T00:00:00Z","image":"https://zyxin.xyz/blog/2017-08/MCRecollect/mc_moonlight.png","permalink":"https://zyxin.xyz/blog/2017-08/MCRecollect/","title":"Minecraft - Recollections"},{"content":"在烟花服里面，我在雪地的基地里造了一个全自动多作物塔，基本上能自动刷的作物我都塞进了一个塔里hhh，非常实用。为了美观以及统一，这个塔的尺寸按照一般的小麦塔设计成了9x9，周围再加一层红石布线、一层走道是13x13，如果再算上围墙则一共占地是15x15。层数不限，每一层的作物有很多选择，可以随意按需累加~\n这个作物塔在纯净生存里非常实用，并且空间紧凑。但如果你加了别的Mod可能会有更优的方案。有了自动作物塔，不仅吃喝不愁，还能和村民进行大波交易（滑稽）~\n作物塔中每类作物塔层的收集口主要有两类，一类是在正中间，另一类是在9x9的一角，因此两类作物层最好分类累加，中间通过一层水流转移接口的位置。水流层就不专门写了，非常简单，如果转移有困难可以考虑造两层水。另外，半自动与全自动的层也最好分开，半自动层位于底层可以便于红石布线，并且方便操作开关。由于所有作物都从同一个口流下，因此在收集端可以接一个物品分类系统，这样就能愉快地刷作物了。（不过需要注意的是区块加载器无法让作物生长，想要刷作物只能在附近挂机，见该贴）\n在服务器我的作物塔垒了十几层，高度已经突破200，上去看看风景也是不错的~作物塔本来是裸露的，后面觉得太丑于是给它加了个外墙，由于羊毛比较廉价，就随便弄了一个圣诞棍外形，但这么高的作物塔其实弄个大型像素图也是可以的~\n当初在服务器里我的塔长这样：\n接下来几篇文章就会写不同作物层的搭法~\n","date":"2017-08-18T00:00:00Z","permalink":"https://zyxin.xyz/blog/2017-08/MCTower/","title":"Minecraft - 集成作物塔"},{"content":"纠结了很久，最后还是把这个博客搭起来了。实际上在决定搭博客之前有很多很多想写的东西，都存在Trello里面了。但是人懒，过了几年也没把它写出来，导致很多内容都过时了，没有写的必要了。痛心疾首，大把的分zhuāng享bī内容没能分享出来，痛定思痛便还是决定搭了这个博客。\n这个博客应该很少会放生活内容了，我个人认为公开的博客不适合放私人生活，在这个信息飞速流通的时代这是有危险的。因此博客的主要内容会是一些干货，以及科研杂记什么的。如果心xiăng情zhuāng好bī的话可能会放日记什么的吧2333。\n路漫漫而其修远兮，吾将上下而求索。欢迎留言讨论，也欢迎在各种地方勾搭~\n最后放一张上周去Olympic National Park的照片作为旅途的开端吧！ ","date":"2017-08-17T00:00:00Z","image":"https://zyxin.xyz/blog/2017-08/Initialization/hurricane_ridge.jpg","permalink":"https://zyxin.xyz/blog/2017-08/Initialization/","title":"开篇语"}]