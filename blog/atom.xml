<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jacob Zhong</title>
  
  <subtitle>Blog</subtitle>
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="http://zyxin.xyz/blog/"/>
  <updated>2019-11-12T03:02:41.997Z</updated>
  <id>http://zyxin.xyz/blog/</id>
  
  <author>
    <name>Jacob Zhong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>进程、线程与协程 (C# vs Python)</title>
    <link href="http://zyxin.xyz/blog/2019-11/ParallelismInPythonAndCsharp/"/>
    <id>http://zyxin.xyz/blog/2019-11/ParallelismInPythonAndCsharp/</id>
    <published>2019-11-07T05:57:31.000Z</published>
    <updated>2019-11-12T03:02:41.997Z</updated>
    
    <content type="html"><![CDATA[<p>近来由于项目需要，接触了一下一直没去了解过的Python异步语法，发现和之前我熟悉的C#有很多不同。在深入Python的异步逻辑之后，由于Python在语法上保留了很多语言机制的细节（比如成员函数的<code>self</code>参数），我反而对C#的异步有了更深的了解。这里就来重新梳理一下各种并行方法的区别，以及他们在C#和Python上实现的区别。（这里只讨论单机的并行机制。）</p><p>总的来说，并行机制主要有进程(Process)、线程(Thread)和协程(Coroutine)，其并行实现的开销依次递减，但是他们对每个任务的鲁棒性也是依次递减的。进程是操作系统资源分配的最小单元，线程则是能够被CPU并行处理的最小单元，而协程则是目前实现“并行”的最简单方法。一个进程中可以有多个线程，而一个线程中可以有多个协程。他们具体在特性上有以下区别</p><table><thead><tr class="header"><th></th><th>进程</th><th>线程</th><th>协程</th></tr></thead><tbody><tr class="odd"><td>独立内存堆</td><td>√</td><td>×</td><td>×</td></tr><tr class="even"><td>独立处理器（可硬件并行）</td><td>√</td><td>√</td><td>×</td></tr><tr class="odd"><td>独立上下文</td><td>√</td><td>√</td><td>×</td></tr><tr class="even"><td>独立栈、寄存器状态</td><td>√</td><td>√</td><td>√</td></tr></tbody></table><a id="more"></a><h1 id="进程">进程</h1><p>进程是系统层面实现并行的机制了，进程管理是现代操作系统的一大核心之一。进程之间互不影响，操作系统会保证一个程序崩溃了，其他程序以及系统内核不会崩溃。操作系统还会提供其他的进程管理功能，例如<a href="https://en.wikipedia.org/wiki/Scheduling_(computing)" target="_blank" rel="noopener">进程调度</a>、设置进程优先级等等。不同语言底层对进程接口的实现实际上都是对系统接口的封装。 ## 一些概念 与进程相关的概念通常都是操作系统课程的必修知识哈哈： - 进程间通信(Inter-process communiation, IPC)：故名思意。常用手段有管道、共享内存、信号量(Semaphore)、消息队列等。 - 管道(Pipe)：管道大概是进程间通信的最常用方式？分命名管道和匿名管道, 进程双方均可往其中读写数据。 - 远程过程调用(Remote procedure call): 远程过程调用通过特定的消息序列化手段，可以实现进程间通信，其使用形式是把一个“远程”的函数在本地进行执行。 - 进程锁：如果为了避免多个进程访问同一个资源的冲突的话，就会用到进程锁，其实现方法有<a href="https://blog.csdn.net/luansxx/article/details/7736618" target="_blank" rel="noopener">管道、信号量</a>、以及文件锁等。 - 文件锁：文件锁是实现进程互斥的一种常用手段，只需要建立空文件句柄并锁上就可了<sub>并且文件锁还能做到权限控制，非常方便</sub> ## C# C#中对进程控制的模块主要通过<a href="https://docs.microsoft.com/dotnet/api/system.diagnostics.process" target="_blank" rel="noopener"><code>System.Diagnostics.Process</code></a>实现，可以实现建立进程、管理进程等，还可以指定具体的内存映射参数，如虚拟内存的页大小。而对管道的支持则是在<code>Process</code>类中有一部分，以及在<a href="https://docs.microsoft.com/en-us/dotnet/api/system.io.pipes" target="_blank" rel="noopener"><code>System.IO.Pipe</code></a>里面有更全面的接口。我觉得这样的命名空间分类是挺合理的，<code>Process</code>类的API其实只能用来进行程序调用和系统诊断，而<code>Pipe</code>则由于它和<code>Stream</code>的概念比较符合，因此归在IO空间下是合适的。 ## Python Python中对进程的控制以及通信方法的实现都在<code>multiprocess</code>包里，它的一些具体使用方法可以参考<a href="/blog/2017-12/PythonCall/" title="另一篇之前的博文">另一篇之前的博文</a>。值得一提的是，Python中还针对Unix系统提供了<code>fcntl</code>, <code>posix</code>等库专门用来调用系统底层API，这些API有部分是和进程有关的。相关内容还是查阅对应的资料会比较清楚~</p><h1 id="线程">线程</h1><p>线程是进程中细化的并行机制，线程的实现也需要用到操作系统的接口，不过线程的创建的管理基本都是在进程内部完成的。由于线程之间不独立内存空间，因此在C++这种能够随意操作内存的语言中，一个线程崩了，这个进程也大概率就崩了。但是在C#和Python中，由于有比较完善的Exception机制，并且没有什么机会直接操作内存，一般线程崩了主进程还是能接着跑的。多线程想必应该是大家用的最多的并行方法了~ ## 一些概念 在线程里面又有一些新的概念 - 线程池(Thread pool)：线程池与内存池相似，都是为了避免频繁新建和销毁线程(or 内存)而造成额外的开销 - 线程锁：线程锁与进程锁相似，是为了避免线程间访问同样的资源而产生冲突（例如<a href="https://stackoverflow.com/questions/34510/what-is-a-race-condition" target="_blank" rel="noopener">race condition</a>）。线程间产生访问冲突非常常见，因此程序员掌握线程锁的使用是非常必要的。线程锁在C++中的<code>&lt;mutex&gt;</code>有非常全面的实现。这里面锁的类型具有代表性，分为条件锁、自旋锁等等，具体区别可以参考<a href="https://blog.csdn.net/bian_qing_quan11/article/details/73734157" target="_blank" rel="noopener">这篇博客</a>。C++的多线程非常令人头大...这里就不展开了。 - 事件(Event)：在多线程体系中，事件是一种常用于线程同步的机制，如果线程需要在运行过程中等待其他线程的运行，就可以使用事件机制。 ## C# C#中与线程相关的模块在<a href="https://docs.microsoft.com/dotnet/api/system.threading" target="_blank" rel="noopener"><code>System.Threading</code></a>空间下。<code>System.Threading.Thread</code>提供了线程实现的类，使用delegate即可创建线程对象。这个空间底下也提供了<code>SpinLock</code>、<code>Semaphore</code>、<code>Mutex</code>等线程锁，以及<code>AutoResetEvent</code>实现了事件机制。<code>System.Threading.ThreadPool</code>则提供了线程池的实现。另外需要指出的是C#提供了<code>lock</code>关键字，只需对冲突的对象使用<code>lock</code>锁上，那么在其对应的上下文中就能够避免冲突。 ## Python Python中与线程相关的对象在<a href="https://docs.python.org/library/threading.html" target="_blank" rel="noopener"><code>threading</code></a>模块中，其中<code>Thread</code>类提供了线程实现，<code>Lock</code>, <code>Semaphore</code>提供了线程锁，<code>Event</code>实现了事件机制。Python中可以使用<code>with lock:</code>这样的块实现与C#<code>lock</code>相似的语法，但是这个地方的lock仍然需要自己声明，不如C#和Java中的<code>lock</code>用着方便。</p><p>总体而言C#和Python对多线程机制的支持都比较全面，然而CPython有一个臭名昭著的<a href="http://cenalulu.github.io/python/gil-in-python/" target="_blank" rel="noopener">全局锁GIL</a>，使得其多线程效率大幅下降。因此在很多Python库中，大家宁愿使用<code>multiprocess</code>多进程来进行并行（即便需要处理进程间通信的问题），也不愿使用<code>threading</code>来完成并行任务。这一点上不得不说Python辣鸡！</p><h1 id="协程">协程</h1><p>协程应该是21世纪才用的比较多的技术了，并且这个概念应该是在Go里面提的最多。在前文我提到协程是并行时打了引号，这是因为协程本质上还是同一个时刻只能干一件事，没法利用硬件并行，因此我们形容协程都是用“异步”(Asychronized)而不是“并行”(Parallel)。异步是与同步相对的，只要程序能一会干点这个，一会干点那个，不按顺序来，那就可以称作异步了。协程的广泛应用是由于近些年大型服务器的负载越来越大，并发需求越来越高<del>（同时剁手的人越来越多）</del>，多任务切换的开销越来越不可忽视，因此协程这个开销最小的方法就被广泛应用了。协程实际上不是一个比线程更小的概念，而是另一类概念（并行/串行 vs 异步/同步)。协程的特点是一个任务能够跑到一半就暂停，然后把状态存起来，等到需要的东西备齐了以后再把状态复原接着跑；至于暂停之前和之后是不是在同一个线程上跑、有没有跟别的任务一块跑并不重要。因此实际上协程是回调(Callback)机制的一个封装升级。 ## 一些概念 - 事件循环(Event loop)：事件循环是一种非常简单的实现异步的机制，简而言之就是维护一个队列，然后把队列里的任务挨个执行，而任务随时随地可以被添加进队列。 - 异步执行/等待(async/await)：这两个关键词在多个语言中都有出现。async用来修饰函数，说明这个函数可以异步执行；await用来等待异步函数的结束，如果没有结束就把当前任务搁着。 ## C# C#中没有协程的概念，C#在5.0版本中引入的<code>async</code>/<code>await</code>关键字提供了异步执行的接口。据我所知C#应该是最早一批引入这个概念的语言了，并且C#里面async和await的使用非常顺滑~。C#的async/await调度与Go一样，都是通过线程池实现，因此性能也非常不错。C#中与async/await有关的接口在<a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks%60" target="_blank" rel="noopener"><code>System.Threading.Tasks</code></a>下，里面的<code>Task</code>类型是对能够await的对象的封装。</p><p>C#中也有用到Event loop来实现异步的地方，一般是在UI相关的函数中，例如整个C#里面的<code>event</code>机制都是通过事件循环来实现的。使用事件循环来完成与UI相关的异步应该是非常标准的做法了，例如Qt里面也有<code>QEventLoop</code>来实现UI的异步回调。与Event loop相关的是Dispatcher机制，Dispatcher可以将指定任务加进事件循环中执行，例如在WPF中可以用Window的Dispatcher在其他线程中将任务加进UI主线程。</p><p>另外需要指出的是C#还可以通过<code>yield</code>关键词实现异步，<code>yield return</code>可能是C#最早的异步机制了，不过功能有限，只能与<code>IEnumerable</code>合作使用。C#中有一些协程的库（如Unity里的）就是使用<code>yield</code>机制来实现的。具体怎么使用<code>yield</code>还请去学习C#的语法~ ## Python Python对异步的支持就来的比较晚了，直到<a href="https://www.python.org/dev/peps/pep-0492/" target="_blank" rel="noopener">PEP 492</a>才正式加入了对<code>async</code>关键字的支持，放在了<code>asyncio</code>模块中。Python对这对关键词的实现又很辣鸡了，<a href="https://robertoprevato.github.io/Comparisons-of-async-await/" target="_blank" rel="noopener">采用的是Event loop机制来实现</a>（可能是因为多线程性能太差了吧= =）。最让人蛋疼是为了执行异步函数你还需要自己开event loop，如果你之前开过一个了，那你还需要把之前那个loop找回来，然后dispatch进去，这是何其难受！。。</p><p>Python中只要对象有<code>__await__</code>、<code>__aiter__</code>或者<code>__aenter__</code>就可以分别支持<code>await</code>、<code>async for</code>和<code>async with</code>的代码块。Python还设计了三个相关概念：Coroutine代表异步对象、Task代表异步执行计划、Future代表异步执行结果。。何必呢？？？像C#用一个Task代表全部不行吗？再配合event loop的接口，就产生了<code>create_task</code>、<code>run_coroutine_threadsafe</code>、<code>run_until_complete</code>、<code>run_in_executor</code>等我总是搞不清区别的函数。。。我爱C#！</p><hr><p>以上是我对C#和Python中异步机制的总结，我对各语言底层的了解并不深，如有错漏还请指点~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;近来由于项目需要，接触了一下一直没去了解过的Python异步语法，发现和之前我熟悉的C#有很多不同。在深入Python的异步逻辑之后，由于Python在语法上保留了很多语言机制的细节（比如成员函数的&lt;code&gt;self&lt;/code&gt;参数），我反而对C#的异步有了更深的了解。这里就来重新梳理一下各种并行方法的区别，以及他们在C#和Python上实现的区别。（这里只讨论单机的并行机制。）&lt;/p&gt;&lt;p&gt;总的来说，并行机制主要有进程(Process)、线程(Thread)和协程(Coroutine)，其并行实现的开销依次递减，但是他们对每个任务的鲁棒性也是依次递减的。进程是操作系统资源分配的最小单元，线程则是能够被CPU并行处理的最小单元，而协程则是目前实现“并行”的最简单方法。一个进程中可以有多个线程，而一个线程中可以有多个协程。他们具体在特性上有以下区别&lt;/p&gt;&lt;table&gt;&lt;thead&gt;&lt;tr class=&quot;header&quot;&gt;&lt;th&gt;&lt;/th&gt;&lt;th&gt;进程&lt;/th&gt;&lt;th&gt;线程&lt;/th&gt;&lt;th&gt;协程&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;独立内存堆&lt;/td&gt;&lt;td&gt;√&lt;/td&gt;&lt;td&gt;×&lt;/td&gt;&lt;td&gt;×&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;独立处理器（可硬件并行）&lt;/td&gt;&lt;td&gt;√&lt;/td&gt;&lt;td&gt;√&lt;/td&gt;&lt;td&gt;×&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;独立上下文&lt;/td&gt;&lt;td&gt;√&lt;/td&gt;&lt;td&gt;√&lt;/td&gt;&lt;td&gt;×&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;独立栈、寄存器状态&lt;/td&gt;&lt;td&gt;√&lt;/td&gt;&lt;td&gt;√&lt;/td&gt;&lt;td&gt;√&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
    
    </summary>
    
      <category term="Coding" scheme="http://zyxin.xyz/blog/categories/Coding/"/>
    
      <category term="Language" scheme="http://zyxin.xyz/blog/categories/Coding/Language/"/>
    
    
      <category term="Python" scheme="http://zyxin.xyz/blog/tags/Python/"/>
    
      <category term="C#" scheme="http://zyxin.xyz/blog/tags/C/"/>
    
      <category term="Parallelism" scheme="http://zyxin.xyz/blog/tags/Parallelism/"/>
    
  </entry>
  
  <entry>
    <title>在Cython中操作数组</title>
    <link href="http://zyxin.xyz/blog/2019-08/CythonArray/"/>
    <id>http://zyxin.xyz/blog/2019-08/CythonArray/</id>
    <published>2019-08-28T21:19:01.000Z</published>
    <updated>2019-11-12T03:02:41.977Z</updated>
    
    <content type="html"><![CDATA[<p>Cython提供了很多方法来搭建C/C++内存和Python对象间的桥梁，但是官方的教程只介绍了一些基础的方法。这篇文章就介绍一下我在各个场合学到和用到的Cython封装（多维）数组的技巧。一般而言这个桥梁会分为两部分，Python与Cython和Cython与C/C++。其中Python中的数组主要形式是<code>list</code>、<code>array.array</code>和<code>numpy.ndarray</code>；Cython中的数组形式有<code>[:,:,:]</code>（<a href="https://cython.readthedocs.io/en/latest/src/userguide/memoryviews.html?highlight=pointer#view-cython-arrays" target="_blank" rel="noopener">Memoryview</a>/<a href="https://www.python.org/dev/peps/pep-3118/" target="_blank" rel="noopener">Buffer</a>）和<code>cython.view.array</code>；C/C++的数组形式有<code>**</code>（指针）、<code>vector</code>和<code>Eigen::Vector/Matrix</code>。</p><blockquote><p>本篇介绍的主要内容也来自于Cython的文档：<a href="http://cython.readthedocs.io/en/latest/src/userguide/memoryviews.html" target="_blank" rel="noopener">Typed Memoryviews</a>。</p></blockquote><a id="more"></a><p>在这里也先介绍一下Cython中的这几个概念： - <strong>Memoryview</strong>：这是cython提供的一种语法糖，相当于提供了C中<code>int[][][]</code>形式数组的类型。由于Memoryview可以兼容Python的Buffer协议，因此我把他们放在了一起。Memoryview需要指定元素的类型，这个类型必须是内置数值类型或者<strong>C结构体</strong>。 - <strong><code>cython.view.array</code></strong>：这是Cython提供的一个多维数组类型，与<code>numpy.ndarray</code>非常相似了。 这两个东西也是可以相互转换的，例如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> cython.view cimport array <span class="keyword">as</span> cvarray</span><br><span class="line"></span><br><span class="line"><span class="comment"># Cython array to Memoryview</span></span><br><span class="line">cyarr = cvarray(shape=(<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>), itemsize=sizeof(int), format=<span class="string">"i"</span>)</span><br><span class="line">cdef int [:, :, :] cyarr_view = cyarr</span><br><span class="line"></span><br><span class="line"><span class="comment"># Memoryview to Cython array</span></span><br><span class="line">cdef cvarray back = cyarr_view</span><br></pre></td></tr></table></figure><p></p><h1 id="python与cython数组相互转换">Python与Cython数组相互转换</h1><p>Python与Cython之间的转换基本上都由Cython的Memoryview提供了接口，实际上直接赋值就可以。例如官方给出的这段例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> cpython cimport array <span class="keyword">as</span> cparray</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># Memoryview on a NumPy array</span></span><br><span class="line">narr = np.arange(<span class="number">27</span>, dtype=np.dtype(<span class="string">"i"</span>)).reshape((<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>))</span><br><span class="line">cdef int [:, :, :] narr_view = narr</span><br><span class="line"></span><br><span class="line"><span class="comment"># Memoryview on a CPython array</span></span><br><span class="line">parr = cparray.array(<span class="string">'i'</span>, range(<span class="number">3</span>))</span><br><span class="line">cdef int [:] parr_view = parr</span><br></pre></td></tr></table></figure><p></p><p>顺带一提，<code>list</code>对象由于本身不代表一段连续内存，因此需要先转换为<code>array</code>或<code>ndarray</code>再赋值给Memoryview。反过来由于Numpy支持Buffer协议，因此Memoryview和Cython的<code>cython.view.array</code>都可以直接转换为<code>numpy.ndarray</code>，然后转换为<code>array</code>和<code>list</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> cpython cimport array <span class="keyword">as</span> cparray</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">parr = cparray.array(<span class="string">'i'</span>, range(<span class="number">3</span>))</span><br><span class="line">cdef int [:] parr_view = parr</span><br><span class="line">narr = np.array(parr_view) <span class="comment"># explicit version: np.array(parr_view, copy=False)</span></span><br></pre></td></tr></table></figure><p></p><blockquote><p>以上这些代码中的等式都没有发生内存拷贝。</p></blockquote><h1 id="cython数组与cc数组相互转换">Cython数组与C/C++数组相互转换</h1><p>Cython的Memoryview同样承担了大量与C/C++数组进行转换的功能，不过Memoryview只支持一种转换方法，就是与raw指针的相互转换：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> libc.stdlib cimport malloc</span><br><span class="line">cdef double* data = &lt;double*&gt;malloc(sizeof(double) * <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Convert pointer to Memoryview</span></span><br><span class="line">cdef double[:] view = &lt;double[:<span class="number">2</span>,:<span class="number">2</span>]&gt;data</span><br><span class="line"></span><br><span class="line"><span class="comment"># Convert Memoryview to pointer</span></span><br><span class="line">data = &amp;view[<span class="number">0</span>,<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p></p><blockquote><p>以上代码的等式中也没有发生内存拷贝。</p></blockquote><p>这里需要指出的是，由于指针本身只是一段内存的代表，因此在转换时制定类型和长度（如<code>&lt;double[4]&gt;</code>），并且需要保证指针指向的数组是C型连续的（多维数组中最后一维的内存是连续的）。如果要将<code>vector</code>和<code>Eigen::Matrix</code>转换为Memoryview，那么也同样需要获取其内存指针（<code>vector::data</code>和<code>Eigen::Matrix::data</code>）。另外，通过<strong>指针转换出来的Memoryview没有引用计数</strong>，因此如果你的指针是某个Cython类的成员，那么不要使用指针转换，而使用Buffer协议的方式进行传递。</p><h1 id="其他直接转换的方法">其他直接转换的方法</h1><p>除了上面提到的方法之外还有一些直接转换的方法，但是这些方法往往不会做类型和尺寸检查，以及很重要的内存连续性检查（Memoryview会区分C型内存和Fortran型内存），因此使用时需要谨慎。 - <code>cdef vector[int] data; cdef list view = data</code>：Cython提供了list和vector直接转换的接口 - <code>cdef np.ndarray[double] data; cdef double* view = &lt;double*&gt; data.data</code> - <code>cdef np.ndarray[double, ndim=2] data; cdef double* view = &amp;data[0,0]</code> - <code>cdef array.array data; cdef double* view = data.data.as_doubles[0]</code>：利用了<a href="https://cython.readthedocs.io/en/latest/src/tutorial/array.html#zero-overhead-unsafe-access-to-raw-c-pointer" target="_blank" rel="noopener">Cython中的API</a></p><h1 id="非内置类型的转换">非内置类型的转换</h1><p>在实际应用过程中还会碰到由复杂元素构成的数组（例如PCL里面的PointXYZ、SLAM里会用到的Quaternion），这时就有将复杂类型（通常是自定义struct）在Python和C/C++之间转换的需求。这时可以选择利用Cython提供的MemoryView，也可以利用Python的Buffer协议直接将C++对象传递给Python。</p><p>使用Buffer协议的方法请直接参考<a href="https://cython.readthedocs.io/en/latest/src/userguide/buffer.html" target="_blank" rel="noopener">Cython文档</a>，使用Memoryview的例子如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> libc.stdlib cimport malloc</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">cdef struct buf: </span><br><span class="line">    int size </span><br><span class="line">    int count</span><br><span class="line">cdef buf[:] data = &lt;buf[:<span class="number">2</span>]&gt;malloc(sizeof(buf)*<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">print(np.array(data).dtype)</span><br><span class="line"><span class="comment"># [('size', '&lt;i4'), ('count', '&lt;i4')]</span></span><br></pre></td></tr></table></figure><p></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Cython提供了很多方法来搭建C/C++内存和Python对象间的桥梁，但是官方的教程只介绍了一些基础的方法。这篇文章就介绍一下我在各个场合学到和用到的Cython封装（多维）数组的技巧。一般而言这个桥梁会分为两部分，Python与Cython和Cython与C/C++。其中Python中的数组主要形式是&lt;code&gt;list&lt;/code&gt;、&lt;code&gt;array.array&lt;/code&gt;和&lt;code&gt;numpy.ndarray&lt;/code&gt;；Cython中的数组形式有&lt;code&gt;[:,:,:]&lt;/code&gt;（&lt;a href=&quot;https://cython.readthedocs.io/en/latest/src/userguide/memoryviews.html?highlight=pointer#view-cython-arrays&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Memoryview&lt;/a&gt;/&lt;a href=&quot;https://www.python.org/dev/peps/pep-3118/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Buffer&lt;/a&gt;）和&lt;code&gt;cython.view.array&lt;/code&gt;；C/C++的数组形式有&lt;code&gt;**&lt;/code&gt;（指针）、&lt;code&gt;vector&lt;/code&gt;和&lt;code&gt;Eigen::Vector/Matrix&lt;/code&gt;。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;本篇介绍的主要内容也来自于Cython的文档：&lt;a href=&quot;http://cython.readthedocs.io/en/latest/src/userguide/memoryviews.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Typed Memoryviews&lt;/a&gt;。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Coding" scheme="http://zyxin.xyz/blog/categories/Coding/"/>
    
      <category term="Language" scheme="http://zyxin.xyz/blog/categories/Coding/Language/"/>
    
    
      <category term="Cython" scheme="http://zyxin.xyz/blog/tags/Cython/"/>
    
      <category term="Python" scheme="http://zyxin.xyz/blog/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Cython中的特殊函数</title>
    <link href="http://zyxin.xyz/blog/2019-08/CythonFunctions/"/>
    <id>http://zyxin.xyz/blog/2019-08/CythonFunctions/</id>
    <published>2019-08-28T18:23:37.000Z</published>
    <updated>2019-11-12T03:02:41.977Z</updated>
    
    <content type="html"><![CDATA[<p>这次来介绍一下Cython中的特殊函数定义，Cython相比Python本身的特殊函数之外还增加了一些新的函数，用来满足对C特性的支持，其中有些内容还经常令人混淆。关于Python中特殊变量和特殊函数名的内容，<a href="https://docs.python.org/3/reference/datamodel.html" target="_blank" rel="noopener">请参考Python官方文档</a>。</p><h1 id="def-cdef和cpdef"><code>def</code>, <code>cdef</code>和<code>cpdef</code></h1><p>首先最开始需要分清的便是Cython中的三种函数类型。<code>def</code>定义的对象（包括变量、函数、类型）都是普通的Python对象，是Python可以直接调用的，因此其参数都只能是Python类型或对象；<code>cdef</code>定义的对象则是C/C++层面的，可以直接用C/C++对象作为参数，因此不能被普通Python代码调用，这样减少了很多overhead因此可以提高运行效率。另外尽管<code>cdef</code>的函数不是Python对象，无法当作变量使用，但还是可以获取函数指针的。而<code>cpdef</code>则是同时兼具两方面特性，其本质是用<code>cdef</code>定义函数后再用<code>def</code>定义一个函数封装，使得在Cython中调用时可以调用高效的<code>cdef</code>版本，而在Python中调用的是与Python兼容的<code>def</code>版本。</p><a id="more"></a><h1 id="init__和__cinit__"><code>__init__</code>和<code>__cinit__</code></h1><p>在理清了上面几个关键字后另一个经常令人疑惑的点便是<code>__init__</code>和<code>__cinit__</code>的区别。<code>__cinit__</code>和<code>__dealloc__</code>都是Cython特有的特殊函数。<a href="https://cython.readthedocs.io/en/latest/src/userguide/special_methods.html#initialisation-methods-cinit-and-init" target="_blank" rel="noopener">官方文档在其用法上解释</a>的并不清楚，只是说<code>__cinit__</code>可以用来进行C/C++级别的初始化。实际上，使用<code>__cinit__</code>的重要原因是源于其特性：<code>__cinit__</code>会像C++一样自动执行基类的<code>__cinit__</code>，因此它保证会在构造时被执行一次（且只被执行一次）。由于Python中的<code>__init__</code>函数默认不会调用基类的<code>__init__</code>，因此如果想保证类型中的<code>cdef</code>成员被初始化，避免可能的堆栈问题（如指针没有初始化），那么就可以选择使用<code>__cinit__</code>。如果理解了这一点就可以知道，什么时候需要使用<code>__cinit__</code>了。</p><p>但是使用<code>__cinit__</code>的时候有很多限制需要了解： 1. <code>__cinit__</code>有时会带来额外的开销，<a href="https://kaushikghose.wordpress.com/2015/03/08/cython-__cinit__/" target="_blank" rel="noopener">这篇博客中有一些分析</a>。 2. <code>__cinit__</code>的参数声明和<code>__init__</code>必须一致，因为会同时被调用。因此通常<code>__cinit__</code>的参数中会留下<code>*kargs</code>和<code>**kvargs</code>。<a href="https://stackoverflow.com/a/33091422" target="_blank" rel="noopener">Stackoverflow上也有人问过这个情况</a>。 3. <code>__cinit__</code>中如果要用<code>malloc</code>分配内存，记得在<code>__dealloc__</code>中销毁。<code>__dealloc__</code>相当于C++版本的<code>__del__</code> 4. <code>__cinit__</code>和<code>__init__</code>一样也只能使用<code>def</code>声明，不能用<code>__cdef__</code>和<code>__cpdef__</code>。具体原因我并不清楚。</p><h1 id="运算符重载">运算符重载</h1><p>其他大多数的特殊函数定义和用法几乎和Python相同，但是需要特别指出的是运算符重载的部分。以加法为例，在Python中加法<code>a + b</code>的实现方式是： 1. 如果<code>a</code>中定义了<code>__add__</code>，那么调用<code>a.__add__(b)</code> 2. 如果<code>a</code>中没有定义，而<code>b</code>中定义了<code>__radd__</code>，那么调用<code>b.__radd(a)</code></p><p>而在Python的C扩展类里（包含Cython和pybind11的实现），其实现方式是寻找接受<code>a</code>和<code>b</code>类型的<code>__add__</code>重载，也就是说本质上在C扩展类中定义的<code>__add__</code>都是<code>__add__</code>的重载，这也是与C++的<code>operator</code>重载理念一致，只不过这个<code>__add__</code>仍然需要定义在类里。在<a href="https://cython.readthedocs.io/en/latest/src/userguide/special_methods.html#arithmetic-operators" target="_blank" rel="noopener">Cython文档中给出的运算符列表</a>里，参数里带<code>self</code>的函数都是按照Python中的方法实现的，<code>self</code>不能指定类型；而以<code>x, y</code>这种形式为参数的则是按照C扩展类执行方式的函数，<code>x</code>和<code>y</code>都可以指定类型。</p><p>另外Cython还定义了一个特殊的运算符函数<code>__richcmp__</code>，这个是Python中没有的，不过其功能只是把比较符号（&gt;,&lt;,=）的实现合并了，与Python的<code>__eq__</code>、<code>__lt__</code>等函数没有本质区别。<a href="https://cython.readthedocs.io/en/latest/src/userguide/special_methods.html#rich-comparison-operators" target="_blank" rel="noopener">这在官方文档中也有说明</a></p><h1 id="getbuffer__"><code>__getbuffer__</code></h1><p><a href="https://cython.readthedocs.io/en/latest/src/userguide/special_methods.html#buffer-interface-pep-3118-no-python-equivalents-see-note-1" target="_blank" rel="noopener">Cython中有两个版本的Buffer协议</a>，一种是提案PEP-3118定义的，另一种是Python官方定义之前Cython自己的定义方式。其中前者在<a href="/blog/2019-08/CythonInterop/" title="之前介绍Cython封装的文章">之前介绍Cython封装的文章</a>中已有介绍，就不多赘述。其相关的特殊函数是<code>__getbuffer__</code>和<code>__releasebuffer__</code>，这两个函数也都是Cython特有的。而后者比较难用，已经被标记为depricated废弃了，也不介绍了。</p><h1 id="属性property">属性（property）</h1><p>Cython中还提供了一套非常方便的属性定义方法。原本在Python中定义属性非常但疼，例如下面的代码定义了名为<code>length</code>的属性，使得你可以通过<code>square.length</code>的方法访问它</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span>:</span></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">length</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._length</span><br><span class="line"><span class="meta">    @length.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">length</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self._length = value</span><br><span class="line"><span class="meta">    @length.deleter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">length</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._length = <span class="number">0</span></span><br></pre></td></tr></table></figure><p></p><p>而在Cython中定义属性就更简单了，它除了支持上面的方法外还有另一种更加直观的定义方式（虽然这个方式也已经被标记为depricated了）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cdef <span class="class"><span class="keyword">class</span> <span class="title">Square</span>:</span></span><br><span class="line">    property length:</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> self._length</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">            self._length = value</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span></span><br><span class="line">            self._length = <span class="number">0</span></span><br></pre></td></tr></table></figure><p></p><hr><p>Cython的类型还有各种其他的奇奇怪怪的小特性，在Cython的这两篇文档里有详细介绍：<a href="https://cython.readthedocs.io/en/latest/src/userguide/extension_types.html" target="_blank" rel="noopener">Extension Types</a>, <a href="https://cython.readthedocs.io/en/latest/src/userguide/special_methods.html#buffer-interface-pep-3118-no-python-equivalents-see-note-1" target="_blank" rel="noopener">Special Methods of Extension Types</a>，仅供参考～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这次来介绍一下Cython中的特殊函数定义，Cython相比Python本身的特殊函数之外还增加了一些新的函数，用来满足对C特性的支持，其中有些内容还经常令人混淆。关于Python中特殊变量和特殊函数名的内容，&lt;a href=&quot;https://docs.python.org/3/reference/datamodel.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;请参考Python官方文档&lt;/a&gt;。&lt;/p&gt;&lt;h1 id=&quot;def-cdef和cpdef&quot;&gt;&lt;code&gt;def&lt;/code&gt;, &lt;code&gt;cdef&lt;/code&gt;和&lt;code&gt;cpdef&lt;/code&gt;&lt;/h1&gt;&lt;p&gt;首先最开始需要分清的便是Cython中的三种函数类型。&lt;code&gt;def&lt;/code&gt;定义的对象（包括变量、函数、类型）都是普通的Python对象，是Python可以直接调用的，因此其参数都只能是Python类型或对象；&lt;code&gt;cdef&lt;/code&gt;定义的对象则是C/C++层面的，可以直接用C/C++对象作为参数，因此不能被普通Python代码调用，这样减少了很多overhead因此可以提高运行效率。另外尽管&lt;code&gt;cdef&lt;/code&gt;的函数不是Python对象，无法当作变量使用，但还是可以获取函数指针的。而&lt;code&gt;cpdef&lt;/code&gt;则是同时兼具两方面特性，其本质是用&lt;code&gt;cdef&lt;/code&gt;定义函数后再用&lt;code&gt;def&lt;/code&gt;定义一个函数封装，使得在Cython中调用时可以调用高效的&lt;code&gt;cdef&lt;/code&gt;版本，而在Python中调用的是与Python兼容的&lt;code&gt;def&lt;/code&gt;版本。&lt;/p&gt;
    
    </summary>
    
      <category term="Coding" scheme="http://zyxin.xyz/blog/categories/Coding/"/>
    
      <category term="Language" scheme="http://zyxin.xyz/blog/categories/Coding/Language/"/>
    
    
      <category term="Cython" scheme="http://zyxin.xyz/blog/tags/Cython/"/>
    
      <category term="Python" scheme="http://zyxin.xyz/blog/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Cython与C/C++的交互</title>
    <link href="http://zyxin.xyz/blog/2019-08/CythonInterop/"/>
    <id>http://zyxin.xyz/blog/2019-08/CythonInterop/</id>
    <published>2019-08-28T03:47:47.000Z</published>
    <updated>2019-11-12T03:02:41.977Z</updated>
    
    <content type="html"><![CDATA[<p>用Cython也用了很有一段时间了，这次就介绍一下它的最重要功能——使用Cython来封装C/C++代码。最基本的封装方法可以参见Cython文档中的相关页面：<a href="https://cython.readthedocs.io/en/latest/src/userguide/external_C_code.html" target="_blank" rel="noopener">Interfacing with External C Code</a>和<a href="https://cython.readthedocs.io/en/latest/src/userguide/wrapping_CPlusPlus.html" target="_blank" rel="noopener">Using C++ in Cython</a>，本文介绍主要是比较重要和常用的Cython/C++交互特性，而自定义Python拓展类（而不是封装现有C++）的一些操作可以<a href="https://cython.readthedocs.io/en/latest/src/tutorial/cdef_classes.html" target="_blank" rel="noopener">参考官方教程</a>。</p><p>封装C++代码时，最重要的关键词就是<code>extern</code>，在定义函数时使用这个关键字就说明该声明是外部的，而使用<code>cdef extern from</code>语句就能指定声明对应的头文件。例如如果要封装函数<code>func</code>，对应的Cython语句是</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cdef extern <span class="keyword">from</span> <span class="string">"func.c"</span>:</span><br><span class="line">    void func(int arg)</span><br></pre></td></tr></table></figure><p></p><a id="more"></a><h1 id="文件结构">文件结构</h1><p>首先讲一下Cython的文件结构。如果你之有一个小模块需要封装的话你可以把所有代码写到同一个<code>pyx</code>里进行编译，否则的话你就可以利用Cython的目录结构来管理多个层次的代码。Cython的文件一共有三种：<code>pyx</code>，<a href="https://cython.readthedocs.io/en/latest/src/userguide/language_basics.html#the-include-statement-and-include-files" target="_blank" rel="noopener"><code>pxi</code></a>（<a href="https://stackoverflow.com/a/45440199" target="_blank" rel="noopener">注意与<code>pyi</code>区分</a>）和<code>pxd</code>（<a href="https://stackabuse.com/differences-between-pyc-pyd-and-pyo-python-files/" target="_blank" rel="noopener">注意与<code>pyd</code>区分</a>）。</p><p><code>.pyx</code>是Cython的源文件，类似于<code>.cpp</code>文件在C++中的地位，而对应<code>.h</code>头文件地位的则是<code>pyi</code>。在Cython中添加<code>import 'header.pyi'</code>的语句就会将<code>header.pyi</code>文件中的内容原封不动地直接插入当前位置，这与C++的<code>#include</code>语句的作用是相同的。而<code>pxd</code>则是另一套符号化的逻辑，<code>.pxd</code>文件中只能声明函数、声明类型、不能有函数和类型的定义内容（除了<code>inline</code>函数外），而在<code>cimport</code>了<code>pxd</code>的定义之后当前代码便引入了对应的函数或者类型签名。这个工作方式则更符合C++中头文件的实际用途。定义了<code>pxd</code>后就可以在多个Cython文件之间共享同一个类型了。</p><p>不过既然涉及了<code>include</code>语法，就必然要指定类似于C++的引用路径了。<code>pxi</code>和<code>pxd</code>文件的引用路径可以<a href="https://cython.readthedocs.io/en/latest/src/userguide/sharing_declarations.html#search-paths-for-definition-files" target="_blank" rel="noopener">在cythonize过程中手动指定</a>，而<code>pxd</code>由于是符号化的还可以通过新建<code>__init__.pxd</code>的方式来实现类似于Python的引用方法。只要在Cython搜索目录下的文件夹中包含<code>__init__.pxd</code>文件，Cython就会认为这是一个Cython库，之后就可以用<code>cimport</code>语句通过与Python中<code>import</code>相类似的语法将对应模块文件（<code>.pxd</code>文件）引用进来。当然，<code>pxd</code>文件<a href="https://cython.readthedocs.io/en/latest/src/userguide/source_files_and_compilation.html#compiling-with-the-cythonize-command" target="_blank" rel="noopener">也可以通过命令参数直接导入</a>。关于如何组织这些文件以及头文件之间的关系，读者可以参考<a href="https://github.com/cmpute/pcl.py" target="_blank" rel="noopener">我写的PCL封装库</a>和<a href="https://cython.readthedocs.io/en/latest/src/userguide/sharing_declarations.html" target="_blank" rel="noopener">Cython的相关文档</a>。</p><blockquote><p>函数在pxd中的定义不能显式指定默认参数，而是必须用<code>*</code>代替，例如<code>cdef void func(a=0)</code>在<code>pxd</code>中声明的话需要改为<code>cdef void func(a=*)</code>。</p></blockquote><h1 id="类型封装">类型封装</h1><p>Cython对C++的类型提供了基本可用的封装语法。为什么说基本可用，是因为Cython目前对模板的支持还非常有限，因此实际上可以说Cython只支持到C++98的程度。不过尽管如此，Cython已经能够完成大多数代码的封装需求了。Cython对<code>class</code>的支持通过<code>cdef cppclass &lt;class-name&gt;</code>来实现，这里<code>cppclass</code>关键词是为了和Cython的<code>class</code>关键词进行区分。Cython中<code>class</code>关键词代表的是和Python一致的<code>PyObject</code>对象，代表的是Python类型，而<code>cppclass</code>则指代C++原生类型，由于Cython文件中无法直接编写C++代码，因此<code>cdef cppclass</code>语句通常在<code>cdef extern from</code>的语法块中，用来封装现有的C++类型。另外一点需要注意的地方是Cython<a href="https://cython.readthedocs.io/en/latest/src/userguide/language_basics.html#c-variable-and-type-definitions" target="_blank" rel="noopener">提供封装<code>enum</code>和<code>struct</code>的语法</a>，但是针对的是C中的<code>enum</code>和<code>struct</code>，而非C++中的<code>enum class</code>和<code>struct</code>（C++中<code>struct</code>和<code>class</code>几乎没有区别）。如果要封装C++版本的<code>enum</code>和<code>struct</code>可以直接使用<code>cppclass</code>关键词。以下是封装C++类型的一个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cdef extern <span class="keyword">from</span> <span class="string">"test.h"</span>:</span><br><span class="line">    cdef cppclass Test:</span><br><span class="line">        void print()</span><br></pre></td></tr></table></figure><p></p><h2 id="别名与-namespace-关键字">别名与 namespace 关键字</h2><p>由于Cython最后生成的是全局的C代码，因此在引用C++类时需要明确声明类型含命名空间的全称，这里就需要用到别名的机制。Cython允许从<code>.h</code>文件中导入声明的时候给类型和方法改名字，具体用法如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cdef extern <span class="keyword">from</span> <span class="string">"&lt;header-name&gt;"</span>:</span><br><span class="line">    cdef void &lt;new-function-name&gt; <span class="string">"&lt;origin-function-name&gt;"</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    cdef cppclass &lt;new-<span class="class"><span class="keyword">class</span>-<span class="title">name</span>&gt; "&lt;<span class="title">origin</span>-<span class="title">class</span>-<span class="title">name</span>&gt;":</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p></p><p>简而言之就是在方法或者类型名称后添加引号，引号里写上原本C++中的名字。这个机制有很多tricky的用法，它可以用来声明带命名空间的方法和类型、可以用来<a href="https://stackoverflow.com/a/25955546" target="_blank" rel="noopener">重命名C++中的运算符</a>、可以用来直接声明实例化的模板类型、甚至可以用来把C++常量声明成类型用于模板参数（这种操作可以<a href="https://github.com/wouterboomsma/eigency/blob/master/eigency/core.pxd" target="_blank" rel="noopener">参考eigency库中的代码</a>）。</p><p>其中针对第一种用法，为了简化带有命名空间对象的声明，Cython加入了<code>namespace</code>关键字。在<code>cdef</code>语句中添加<code>namespace</code>从句可以使得Cython编译器默认给其包含的语句块中所有的类型加上对应的命名空间，例如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cdef extern <span class="keyword">from</span> <span class="string">"test.h"</span> namespace <span class="string">"ns"</span>:</span><br><span class="line">    cdef cppclass Test:</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p></p><p>与以下代码是等价的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cdef extern <span class="keyword">from</span> <span class="string">"test.h"</span>:</span><br><span class="line">    cdef cppclass Test <span class="string">"ns::Test"</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p></p><h2 id="模板支持">模板支持</h2><p>这个特性在<a href="/blog/2018-12/CythonTypes/" title="之前介绍Cython类型的文章中">之前介绍Cython类型的文章中</a>也有提到过，这里补充一下它的一些特性。Cython对C++模板的支持通过<code>[]</code>符号实现，以下是Cython中对<code>vector</code>的封装代码可供参考</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cdef extern <span class="keyword">from</span> <span class="string">"&lt;vector&gt;"</span> namespace <span class="string">"std"</span> nogil:</span><br><span class="line">    cdef cppclass vector[T,ALLOCATOR=*]:</span><br><span class="line">        ctypedef T value_type</span><br><span class="line">        ctypedef ALLOCATOR allocator_type</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p></p><p>其中<code>vector[T,ALLOCATOR=*]</code>对应的就是C++中的<code>vector&lt;T, ALLOCATOR&gt;</code>符号。模板参数在Cython中同样可以有复数个，也可以有默认值，<a href="https://gist.github.com/bjodah/3cc42d9c5f70a321af29" target="_blank" rel="noopener">似乎现在也支持常数作为模板参数</a>，不过我没有尝试过，而据说老版本是不支持常数模板参数的。</p><p>之前有提到Cython中对模板的支持是阉割过的，主要特征有以下几点： - Cython不支持模板参数的类型声明访问。例如上面的<code>vector</code>类型声明中不能使用<code>ctypedef allocator_type.size_type size_type</code>这样的语法，而这样的类型推断在C++中是有很多的。 - Cython不支持模板构造函数中包含新的模板参数 不过Cython一直在改进对模板的支持，因此以后也很有可能会得到改进。</p><h1 id="buffer协议">Buffer协议</h1><p>Cython还针对性地支持了<a href="https://docs.python.org/3/c-api/buffer.html" target="_blank" rel="noopener">Python的Buffer协议</a>，用来传递一块结构化的内存，这个协议的标准被记录在了<a href="https://www.python.org/dev/peps/pep-3118/" target="_blank" rel="noopener">提案PEP-3118</a>中。这个协议通过<a href="https://cython.readthedocs.io/en/latest/src/userguide/buffer.html" target="_blank" rel="noopener"><code>__getbuffer__</code>和<code>__releasebuffer__</code></a>两个Cython自定义的特殊函数实现，通过这个方式Cython代码就可以将C++内存转化为Python识别的内存。因为Numpy支持将支持Buffer协议的对象转换为ndarray，因此这个Buffer协议的通常用法是将一个C++对象变成Numpy的矩阵。具体的使用案例也可以<a href="https://github.com/cmpute/pcl.py/blob/master/pcl/PointCloud.pyx#L565" target="_blank" rel="noopener">参照我的pcl封装库中的对应代码</a>。</p><hr><p>本文介绍了Cython中操作C/C++对象的方法，不过仅仅介绍了一些进阶用法。如果是新手的话还是先参照之前提到两篇文档学习基本的函数、类型封装方法吧～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用Cython也用了很有一段时间了，这次就介绍一下它的最重要功能——使用Cython来封装C/C++代码。最基本的封装方法可以参见Cython文档中的相关页面：&lt;a href=&quot;https://cython.readthedocs.io/en/latest/src/userguide/external_C_code.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Interfacing with External C Code&lt;/a&gt;和&lt;a href=&quot;https://cython.readthedocs.io/en/latest/src/userguide/wrapping_CPlusPlus.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Using C++ in Cython&lt;/a&gt;，本文介绍主要是比较重要和常用的Cython/C++交互特性，而自定义Python拓展类（而不是封装现有C++）的一些操作可以&lt;a href=&quot;https://cython.readthedocs.io/en/latest/src/tutorial/cdef_classes.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;参考官方教程&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;封装C++代码时，最重要的关键词就是&lt;code&gt;extern&lt;/code&gt;，在定义函数时使用这个关键字就说明该声明是外部的，而使用&lt;code&gt;cdef extern from&lt;/code&gt;语句就能指定声明对应的头文件。例如如果要封装函数&lt;code&gt;func&lt;/code&gt;，对应的Cython语句是&lt;/p&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;cdef extern &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;func.c&quot;&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    void func(int arg)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Coding" scheme="http://zyxin.xyz/blog/categories/Coding/"/>
    
      <category term="Language" scheme="http://zyxin.xyz/blog/categories/Coding/Language/"/>
    
    
      <category term="Cython" scheme="http://zyxin.xyz/blog/tags/Cython/"/>
    
      <category term="Python" scheme="http://zyxin.xyz/blog/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>如何选择Python与C++之间的胶水</title>
    <link href="http://zyxin.xyz/blog/2019-08/GluePythonCpp/"/>
    <id>http://zyxin.xyz/blog/2019-08/GluePythonCpp/</id>
    <published>2019-08-11T21:05:40.000Z</published>
    <updated>2019-11-12T03:02:41.977Z</updated>
    
    <content type="html"><![CDATA[<p>Python作为一门胶水语言，它与C/C++之间的兼容性（Interoperability）我认为是它相比其他动态语言脱颖而出的最大原因。Python原生支持的是与C语言的接口，Python的发行版自带有<code>Python.h</code>头文件，里面提供了在C中调用Python和反过来在Python中调用C的接口定义。但是C++就不一样了，虽然C++ ⇔ C ⇔ Python的通道是可行的，但是想要完整兼容C++的特性的话需要很多额外的重复代码（boilerplate）。因此相应针对Python/C++绑定的库也就应运而生了，我所了解的库主要有四个：<a href="https://www.boost.org/doc/libs/1_70_0/libs/python/doc/html/index.html" target="_blank" rel="noopener">Boost.Python</a>，<a href="https://cython.org/" target="_blank" rel="noopener">Cython</a>，<a href="https://pybind11.readthedocs.io/en/stable/" target="_blank" rel="noopener">pybind11</a>，<a href="http://www.swig.org/" target="_blank" rel="noopener">SWIG</a>。虽然网上也有不少比较三者的页面，但是我觉得都不够详细，这篇博客就介绍一下我基于使用这几个库的经验比较。</p><p>上面说到的这些库我基本都有接触过，其中用过的有pybind11和Cython，分别用在了我正在写的<a href="https://github.com/cmpute/cgal.py" target="_blank" rel="noopener">CGAL</a>和<a href="https://github.com/cmpute/pcl.py" target="_blank" rel="noopener">PCL</a>的绑定上。另外二者则是在其他库的代码中有读过（如Caffe和CGAL的官方绑定）。总的来说，Boost.Python和pybind11主要用于给现有C++代码提供Python绑定，并且不用学习新的语法;SWIG提供一个给C++代码编写多种语言绑定的框架，它本质上是一种代码生成器，基于SWIG自定义的语法;Cython则是基于Python的C/C++代码封装器，其本质也是代码生成器，但是Cython的语法是Python的超集，也就是说Python的代码可以零成本移植到Cython中。</p><a id="more"></a><h1 id="boost.python-vs-pybind11">Boost.Python vs pybind11</h1><p>Boost.Python是一个Boost框架中封装C++代码的工具，通过宏定义和元编程来简化Python的API调用，消灭bolierplate。Boost.Python还提供对Numpy底层API的封装，因此适用性很强，能满足Python绑定的绝大多数需求。而pybind11则是受Boost.Python启发的一套类似的API，其目标是提供Header-only的易用的Python接口。由于pybind11脱胎于Boost，因此它们的接口非常相似，例如最简单的封装一个函数，Boost.Python代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/python.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i + j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOST_PYTHON_MODULE(example)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> boost::python;</span><br><span class="line">    def(<span class="string">"add"</span>, add);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>而对应的pybind11代码则是</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pybind11/pybind11.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i + j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PYBIND11_MODULE(example, m) &#123;</span><br><span class="line">    m.def(<span class="string">"add"</span>, &amp;add);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>因此熟练掌握这两者之一的开发者能很快上手另一个库的使用。他们的编译方式也是相似的，只需添加一个工程，写好对应的封装代码，然后利用他们的CMake模块进行编译，生成的动态链接库只要文件名正确就可以直接从Python进行import了。他们二者的区别主要有以下几个方面： 1. pybind11是Header-only的，因此只需把它的头文件添加到include目录就算安装好了。而Boost.Python则是需要先编译安装才能使用，需要处理其依赖。 1. pybind11的社区更加活跃，Boost.Python则受限于Boost的更新周期，回应反馈可能会比较慢。 1. pybind11的易用性更好，文档齐全且友善，由于没有依赖问题，编译方便上手也快。 1. Boost.Python兼容旧特性的C++，也兼容Boost自定义的类型（如smartptr），因此如果需要封装的代码是基于Boost的，那可能Boost.Python会比pybind11合适。pybind11针对的环境则是C++1x，并且只支持标准C++库。 1. Boost.Python对Numpy的支持比较完备，而pybind11对Numpy的支持主要基于Python的buffer协议。 因此基本上如果封装不基于Boost的库的话可以先考虑pybind11，而如果是封装基于Boost的库（如PCL）那还是直接上Boost.Python吧～</p><h1 id="boost.pythonpybind11-vs-cython">Boost.Python/pybind11 vs Cython</h1><p>这两者的选用其实差别非常大，因为他们的代码逻辑都是不同的。而具体选择哪个库就纯粹是根据需求出发了。他们的区别如下（以下pybind11同时也代表了Boost.Python） 1. pybind11基于C++，更适合C++工程师。Cython则是基于Python，写习惯的Python的人上手更快，并且能同时方便地兼容Python和C++。 1. Cython相比pybind11的环境配置更加简单，用户只需通过pip安装Cython就可以利用Cython的功能了，也无需配置路径。 1. Cython封装C++类会比Boost.Python更加繁杂，你需要先定义C++类，再封装成Python类。相当于Cython还多一步翻译头文件的工作。 1. Cython支持模板（虽然是阉割版本）！这是Cython独家的一个killer特性，不过是与第3点相关联的。如果你已经翻译好了现有的模板代码，那么用户就可以用Python的语法来自行展开模板了！pybind11需要在编译的时候实例化模板，因此一般只封装常用的实例，或者穷举所有实例化可能（这会导致生成的封装库尺寸爆炸） 1. pybind11封装重载函数比Cython要方便太多！Cython封装重载函数的话一般需要定义大量的可选参数和类型判断。 1. Cython封装继承类就更加麻烦了，不仅要处理方法重载，还要复制继承关系，十分繁复。 1. Cython无法利用上C++的宏定义，这对支持条件编译非常不利，很多时候还需要自己利用<a href="https://cython.readthedocs.io/en/latest/src/userguide/language_basics.html#conditional-statements" target="_blank" rel="noopener">Cython的条件语句</a>翻译一套条件编译的逻辑。</p><p>以前很多人使用Cython的原因是Cython可以很方便地加速Python代码，但是<code>numba.jit</code>的出现则让这个功能实际上成了鸡肋，因此Cython最近的使用率也是越来越低了。如果没有很强的对保留模板灵活性的需求，或者不是封装目标不是基于C语言的，那还是选择pybind11来的方便。如果封装接口只是一小部分需求的话也还是用Cython会更加一致，我在自己的PCL绑定项目中使用Cython的原因是有大量基于Python的扩展代码，因此使用Cython还是能更方便。</p><h1 id="swig">SWIG</h1><p>SWIG是个很神奇的东西，他能够将C++代码封装成Python/C#/Java/Ruby等多种语言，但是也正因为这个灵活性，它对C++的高级特性的支持就比较辣鸡了。在<a href="https://github.com/sciencectn/cgal-bindings" target="_blank" rel="noopener">CGAL官方的绑定库</a>中可以看到有不少代码需要针对Python和Java打补丁，因此如果没有多语言的需求的话SWIG应该是下下策了。这应该也是SWIG一直没啥发展的原因吧～</p><hr><p>本文介绍了Boost.Python/pybin11/Cython/SWIG之间的特性与区别，而具体用法则是一笔带过。如果大家对其中的某工具感兴趣的话可以直接去官网看教程～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python作为一门胶水语言，它与C/C++之间的兼容性（Interoperability）我认为是它相比其他动态语言脱颖而出的最大原因。Python原生支持的是与C语言的接口，Python的发行版自带有&lt;code&gt;Python.h&lt;/code&gt;头文件，里面提供了在C中调用Python和反过来在Python中调用C的接口定义。但是C++就不一样了，虽然C++ ⇔ C ⇔ Python的通道是可行的，但是想要完整兼容C++的特性的话需要很多额外的重复代码（boilerplate）。因此相应针对Python/C++绑定的库也就应运而生了，我所了解的库主要有四个：&lt;a href=&quot;https://www.boost.org/doc/libs/1_70_0/libs/python/doc/html/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Boost.Python&lt;/a&gt;，&lt;a href=&quot;https://cython.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Cython&lt;/a&gt;，&lt;a href=&quot;https://pybind11.readthedocs.io/en/stable/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;pybind11&lt;/a&gt;，&lt;a href=&quot;http://www.swig.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SWIG&lt;/a&gt;。虽然网上也有不少比较三者的页面，但是我觉得都不够详细，这篇博客就介绍一下我基于使用这几个库的经验比较。&lt;/p&gt;&lt;p&gt;上面说到的这些库我基本都有接触过，其中用过的有pybind11和Cython，分别用在了我正在写的&lt;a href=&quot;https://github.com/cmpute/cgal.py&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CGAL&lt;/a&gt;和&lt;a href=&quot;https://github.com/cmpute/pcl.py&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;PCL&lt;/a&gt;的绑定上。另外二者则是在其他库的代码中有读过（如Caffe和CGAL的官方绑定）。总的来说，Boost.Python和pybind11主要用于给现有C++代码提供Python绑定，并且不用学习新的语法;SWIG提供一个给C++代码编写多种语言绑定的框架，它本质上是一种代码生成器，基于SWIG自定义的语法;Cython则是基于Python的C/C++代码封装器，其本质也是代码生成器，但是Cython的语法是Python的超集，也就是说Python的代码可以零成本移植到Cython中。&lt;/p&gt;
    
    </summary>
    
      <category term="Coding" scheme="http://zyxin.xyz/blog/categories/Coding/"/>
    
      <category term="Language" scheme="http://zyxin.xyz/blog/categories/Coding/Language/"/>
    
    
      <category term="Python" scheme="http://zyxin.xyz/blog/tags/Python/"/>
    
      <category term="C++" scheme="http://zyxin.xyz/blog/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>ROS参数设置方法总结</title>
    <link href="http://zyxin.xyz/blog/2019-08/ROSParameter/"/>
    <id>http://zyxin.xyz/blog/2019-08/ROSParameter/</id>
    <published>2019-08-02T15:54:25.000Z</published>
    <updated>2019-11-12T03:02:41.997Z</updated>
    
    <content type="html"><![CDATA[<p>最近在研究ROS节点（ROS Node）的参数设置方式，由于系统比较复杂，并且会变得更加复杂，因此需要一个统一的参数设置方式。这里就比较一下四种参数获取方案的区别～</p><h1 id="命令行文件输入">命令行/文件输入</h1><p>由于ROS节点本身也只是普通的可执行程序，因此它可以正常地从启动参数中读取参数，另外也可以从配置文件中读取参数。这两种方法都是常规程序读取参数的方法。从命令行中读取参数有C++的<code>Boost.Program_options</code>库和Python的<code>argparse</code>的库，用来解析命令行参数输入，支持可选参数、重复参数、参数分组等等。而从文件输入的话，常见的设置格式有<code>json</code>，<code>yaml</code>，<code>toml</code>甚至<code>ini</code>等等。从这些文件中读取比较灵活，但是无法利用ROS框架，并且需要自行统一格式。</p><h1 id="参数服务器">参数服务器</h1><p>ROS中很有名的支持参数设置的结构是参数服务器，参数服务器是一个包含在master结点里的集中式字典结构，在ROS的Wiki上有介绍：<a href="http://wiki.ros.org/Parameter%20Server/cn" target="_blank" rel="noopener">中文</a>|<a href="http://wiki.ros.org/Parameter%20Server" target="_blank" rel="noopener">英文</a>。参数服务器也可以从文件中读取参数，文件格式是<code>yaml</code>，读取的方式是在<code>.launch</code>文件中添加<code>&lt;rosparam&gt;</code>标签，并指定键值或者文件路径。</p><a id="more"></a><h2 id="rosparam">rosparam</h2><p><code>rosparam</code>是操作参数服务器的一套工具，你可以从程序中调用<code>rosparam</code>的API，或者使用命令行工具对指定参数进行动态更改。命令行的用法参见<a href="http://wiki.ros.org/rosparam#rosparam_command-line_tool" target="_blank" rel="noopener">ROS Wiki</a></p><h2 id="rosrun">rosrun</h2><p><code>rosrun</code>和<code>roslaunch</code>都是运行ROS模块的工具，其中<code>rosrun</code>只能运行单个节点，而<code>roslaunch</code>则支持更加复杂的启动体系。用<code>rosrun</code>进行参数服务器的设置的方式是在启动参数中添加<code>key:=value</code>。</p><h2 id="roslaunch">roslaunch</h2><p>用<code>roslaunch</code>进行参数服务器的设置的方式是在文件中添加<code>&lt;param&gt;</code>标签。</p><param><code>和</code><rosparam><code>实质上功能相似，前者设置的是单个参数，而后者针对的是一套参数。另外</code>roslaunch<code>还支持从命令行读取参数，格式也是</code>key:=value<code>，读取进来后存入的是</code><arg><code>标签，而如果要使用这类参数的话需要使用</code>roslaunch<code>的</code>$(arg key)<code>语法。具体的</code>roslaunch`语法<a href="http://wiki.ros.org/roslaunch/XML" target="_blank" rel="noopener">参见ROS Wiki</a>。<p></p><h1 id="dynamic_reconfigure">dynamic_reconfigure</h1><p>ROS中还提供了另一种机制叫<a href="http://wiki.ros.org/dynamic_reconfigure" target="_blank" rel="noopener"><code>dynamic_reconfigure</code></a>也可以用来动态设置参数。它与参数服务器的区别在于它的参数更新是基于回调机制，而参数服务器实际上是轮询机制。ROS程序会主动询问参数服务器以获取参数，而<code>dynamic_reconfigure</code>则是动态地告知ROS程序参数更新事件。<code>dynamic_reconfigure</code>的使用方法是定义<code>.cfg</code>文件，并在其中通过Python程序定义可动态设置的参数。<code>cfg</code>文件在CMakeLists.txt中需要注册，注册语法及顺序参见<a href="http://wiki.ros.org/catkin/CMakeLists.txt#Example" target="_blank" rel="noopener">CMakeLists.txt的Wiki</a>和<a href="http://wiki.ros.org/dynamic_reconfigure/Tutorials/HowToWriteYourFirstCfgFile" target="_blank" rel="noopener"><code>.cfg</code>文件的Wiki</a>。个人感觉实际上<code>dynamic_reconfigure</code>实现的效果和自己定义ROS服务来更新参数是相似的。</p><blockquote><p>最后总结下来的话ROS参数服务器还是最常用的，但是参数服务器的名称同样也有命名空间的限制，也分私有参数和公有参数等等。。这两个的区别我其实现在还没有搞清楚= =</p></blockquote></arg></rosparam>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在研究ROS节点（ROS Node）的参数设置方式，由于系统比较复杂，并且会变得更加复杂，因此需要一个统一的参数设置方式。这里就比较一下四种参数获取方案的区别～&lt;/p&gt;&lt;h1 id=&quot;命令行文件输入&quot;&gt;命令行/文件输入&lt;/h1&gt;&lt;p&gt;由于ROS节点本身也只是普通的可执行程序，因此它可以正常地从启动参数中读取参数，另外也可以从配置文件中读取参数。这两种方法都是常规程序读取参数的方法。从命令行中读取参数有C++的&lt;code&gt;Boost.Program_options&lt;/code&gt;库和Python的&lt;code&gt;argparse&lt;/code&gt;的库，用来解析命令行参数输入，支持可选参数、重复参数、参数分组等等。而从文件输入的话，常见的设置格式有&lt;code&gt;json&lt;/code&gt;，&lt;code&gt;yaml&lt;/code&gt;，&lt;code&gt;toml&lt;/code&gt;甚至&lt;code&gt;ini&lt;/code&gt;等等。从这些文件中读取比较灵活，但是无法利用ROS框架，并且需要自行统一格式。&lt;/p&gt;&lt;h1 id=&quot;参数服务器&quot;&gt;参数服务器&lt;/h1&gt;&lt;p&gt;ROS中很有名的支持参数设置的结构是参数服务器，参数服务器是一个包含在master结点里的集中式字典结构，在ROS的Wiki上有介绍：&lt;a href=&quot;http://wiki.ros.org/Parameter%20Server/cn&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;中文&lt;/a&gt;|&lt;a href=&quot;http://wiki.ros.org/Parameter%20Server&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;英文&lt;/a&gt;。参数服务器也可以从文件中读取参数，文件格式是&lt;code&gt;yaml&lt;/code&gt;，读取的方式是在&lt;code&gt;.launch&lt;/code&gt;文件中添加&lt;code&gt;&amp;lt;rosparam&amp;gt;&lt;/code&gt;标签，并指定键值或者文件路径。&lt;/p&gt;
    
    </summary>
    
      <category term="System" scheme="http://zyxin.xyz/blog/categories/System/"/>
    
      <category term="ROS" scheme="http://zyxin.xyz/blog/categories/System/ROS/"/>
    
    
      <category term="Ubuntu" scheme="http://zyxin.xyz/blog/tags/Ubuntu/"/>
    
      <category term="ROS" scheme="http://zyxin.xyz/blog/tags/ROS/"/>
    
      <category term="Robotics" scheme="http://zyxin.xyz/blog/tags/Robotics/"/>
    
      <category term="Autonomy" scheme="http://zyxin.xyz/blog/tags/Autonomy/"/>
    
  </entry>
  
  <entry>
    <title>折腾 KDE Neon 的配置</title>
    <link href="http://zyxin.xyz/blog/2019-07/ConfigureKdeNeon/"/>
    <id>http://zyxin.xyz/blog/2019-07/ConfigureKdeNeon/</id>
    <published>2019-08-01T03:13:47.000Z</published>
    <updated>2019-11-12T03:02:41.977Z</updated>
    
    <content type="html"><![CDATA[<p>最近我已经将KDE Neon作为主力系统之一了，Plasma桌面真的是太好用了！于是给家里的主机也装上了Neon，这篇文章就记录一下安装配置和美化的过程啦～</p><img src="/blog/2019-07/ConfigureKdeNeon/neon.png" title="Plasma桌面折腾结果～"><h1 id="系统安装及boot设置">系统安装及Boot设置</h1><h2 id="双系统安装">双系统安装</h2><p>安装Neon还是非常简单的，直接从官网下载系统镜像，烧进U盘正常安装即可。不过由于我选择的是与Windows双系统安装，因此需要手动分区。这里要纠正一下之前<a href="/blog/2018-09/LinuxDualSystem/" title="安装双系统博文中的分区方式">安装双系统博文中的分区方式</a>。现在的Linux系统实际上只需要给根目录<code>/</code>分区就可以了，<code>/home</code>分区以前建议单独分区的原因是为了便于系统的更改，这样在修改系统分区之后（如重装系统）还能保留<code>/home</code>底下的文件，但其实现在很多系统已经能做到重装并保留<code>/home</code>分区了，这时对于我这小硬盘的笔记本来说反而导致空间利用不灵活。而交换分区<code>/swap</code>也是没有必要的，交换分区的存在类似于Windows下的虚拟内存，用硬盘的一部分来虚拟内存，避免内存不足的情况。新Linux可以利用交换文件完成类似功能，因此不必专门给<code>/swap</code>分区。（不过我猜专门给它分个区可能能提高性能？）。最后最关键的是不要给<code>/boot</code>分区了,<code>/boot</code>分区是为了保证boot文件区不被占满，以致无法正常启动。利用EFI方式启动的系统只需要有<code>efi</code>分区即可，而且多个系统可以利用同一个EFI分区。因此只需告诉安装器使用EFI分区作为启动分区，关于EFI的详细信息请看后文~</p><blockquote><p>分区的时候还看到了之前的系统里有标记为<code>msr</code>的分区，是Windows的预留分区，好像具体没啥用。这里贴<a href="http://bbs.wuyou.net/forum.php?mod=viewthread&amp;tid=374959" target="_blank" rel="noopener">一篇考据文章</a>。</p></blockquote><a id="more"></a><h2 id="refind设置">rEFind设置</h2><p>安装完系统后我还准备安装rEFind来替代默认的bootloader——GRUB(GRUB实在是太丑了...)。由于Windows10禁掉了启动其他系统的入口，因此之前只能用GRUB。rEFind是一个更加强大的启动器，并且可自定义的部分也多～rEFind是基于UEFI的启动器，相比GRUB能支持更多的功能，甚至可以在启动阶段就加载一些驱动，这就使得rEFind可以有高清的界面哈哈哈～关于UEFI与传统BIOS的区别可以参考<a href="https://wiki.manjaro.org/index.php?title=Some_basics_of_MBR_v/s_GPT_and_BIOS_v/s_UEFI" target="_blank" rel="noopener">Manjaro论坛的这篇帖子</a>和<a href="https://www.zhihu.com/question/36313402/answer/66947818" target="_blank" rel="noopener">知乎的这篇帖子</a>。UEFI和BIOS都是主板ROM程序启动后调用的bootloader类型，当bootloader通过UEFI或者BIOS过程加载之后就会启动系统内核。而UEFI相比BIOS可以支持更大的bootloader和并行启动，是现在大部分系统采用的启动方式～</p><p>rEFind在Ubuntu下安装非常方便～直接用<code>apt</code>安装即可。安装完重启就会发现默认进入的已经是rEFind界面了～不过默认的界面主题非常丑，也有很多多余的启动项，因此还需要稍微设置一下～设置教程网上有很多了，主题在官网和搜索引擎也都可以搜到，这里就不赘述。我的设置文件<a href="https://github.com/cmpute/dotfiles/blob/master/refind/user.conf" target="_blank" rel="noopener">可以在Github找到</a>～我保留了GRUB的chainload入口，避免rEFind崩了进不去系统，然后另外添加了一个直接启动Linux内核的入口。最后界面效果如下，还是很赏心悦目的～</p><img src="/blog/2019-07/ConfigureKdeNeon/refind.jpg" title="rEFInd界面照片"><p>安装完成以后就接着<a href="/blog/2018-09/LinuxDualSystem/" title="参考之前的文章">参考之前的文章</a>继续设置就可以了。其中最必要的两个操作是把系统时间调成<code>local-rtc</code>避免与Windows冲突，以及把Plasma环境中鼠标单击的行为从打开改为选择。。。</p><h2 id="输入法安装">输入法安装</h2><p>Neon安装完后默认是没有输入法的，不过反正中文输入法都是要安装<a href="https://wiki.archlinux.org/index.php/fcitx" target="_blank" rel="noopener">fcitx</a>的，还避免了使用ibus的冲突～fcitx的安装<a href="https://blog.ctang.me/the-first-story-on-medium-8a132a1b62fe" target="_blank" rel="noopener">参考这篇文章</a>即可，其中<code>fcitx-qt-impanel</code>这个包可以让fcitx的状态显示在任务栏里～最近好像fcitx在开发新版本(<a href="https://a-wing.top/linux/2018/08/14/fcitx5.html" target="_blank" rel="noopener">fcitx5</a>)，不过目前还只有Arch linux有包可以直接用，因此也就没折腾了。</p><p>安装完成之后还需要让fcitx框架跟随系统在后台启动，在Ubuntu底下修改的文件是<code>.xprofile</code>，而KDE桌面环境不会加载<code>.xprofile</code>，而是加载<code>.xsessionrc</code>，修改方式参见<a href="https://wiki.archlinux.org/index.php/fcitx#Set_environment_variables_for_IM_modules" target="_blank" rel="noopener">Arch Wiki</a>，最后好像还需要加<code>fcitx &amp;</code>来确保启动= =</p><blockquote><ul><li>折腾这些玩意的过程中发现<a href="https://wiki.archlinux.org/index.php" target="_blank" rel="noopener">Arch Wiki</a>真是个好东西啊～KDE桌面的大部分问题都可以搜到解答～</li><li><code>.xinitrc</code>, <code>.xprofile</code>，<code>.xsession</code>这些设置文件我真的是被搞蒙了。。<a href="https://www.reddit.com/r/linux/comments/1p6orz/bashrc_bash_profile_inputrc_profile_xprofile/" target="_blank" rel="noopener">这里有一篇帖子</a>和<a href="https://unix.stackexchange.com/questions/281858/difference-between-xinitrc-xsession-and-xsessionrc/281923#281923" target="_blank" rel="noopener">一篇回答</a>梳理了他们的关系，可供参考～</li></ul></blockquote><h2 id="rclone配置">rclone配置</h2><p>另一个必装的好东西是rclone，之前在<a href="/blog/2019-04/LinuxRemoteSetup/" title="远程桌面设置的文章">远程桌面设置的文章</a>中有提到。由于KDE内置的GoogleDrive和OneDrive连接不太好使，还是用rclone来访问网盘吧= =。在设置好rclone之后可以通过自定义服务的方式让rclone在系统启动时自动挂载网盘到指定路径，然后在Dolphin（KDE的文件管理器）里面将这两个位置添加到左侧目录就可以啦～这样就可以直接从文件管理器访问了～具体的配置文件可以参考我的Github<todo>。</todo></p><blockquote><ul><li>如果自定义服务添加到的位置是系统服务位置，那么可能会碰到权限问题，<a href="https://forum.rclone.org/t/rclone-gdrive-not-mounting-permissions-or-fuse-issue/8067/2" target="_blank" rel="noopener">这里有解决方法</a></li><li>关于systemd的服务设置可以<a href="https://wiki.archlinux.org/index.php/Systemd/User" target="_blank" rel="noopener">参考Arch Wiki</a></li></ul></blockquote><h1 id="主题设置美化">主题设置美化</h1><h2 id="plasma主题设置">Plasma主题设置</h2><p>KDE Plasma最大的优点就是流畅以及好看！不折腾一下主题真的是对不起这么好的环境了～我大概主要进行了以下修改 - 风格选择<code>Breeze Dark</code>， 透明度设置为70%左右 - 图标使用<code>Papirus Dark</code> - 使用透明桌面主题<a href="https://store.kde.org/p/1170816/" target="_blank" rel="noopener"><code>Breeze Transparent Dark</code></a> - Firefox浏览器去掉titlebar，主题设为Dark - 添加全局菜单添加到底部 &gt; 注意默认的Firefox去掉titlebar的话<a href="https://www.reddit.com/r/kde/comments/bn2klu/firefox_csd_bug_with_kde_global_menu_plasmoid/" target="_blank" rel="noopener">对全局菜单的Plasmoid支持有问题</a> - fcitx主题选择Dark - 在桌面特效中选择喜欢的窗口动画，调节窗口透明度～</p><p>剩下的换壁纸、配色主题什么的都来一遍就可以了～最后的桌面效果见标题图，还是很顺眼的～</p><h2 id="其他小工具">其他小工具</h2><h3 id="窗口附着缩放">窗口附着缩放</h3><p>这个KWin脚本名叫Sticky Window Snapping，真的是神器！可以让附着在一块的窗口同时进行尺寸调整！这个功能相当于Windows分屏功能的升级版，这酸爽谁用谁知道啊！～下载地址<a href="https://store.kde.org/p/1112552" target="_blank" rel="noopener">见KDE商城</a>，使用效果在官网有动图可以参考～还<a href="https://store.kde.org/p/1112554/" target="_blank" rel="noopener">有个类似的脚本</a>可以做到让窗口严格按照网格排列，不过相比之下就显然鸡肋很多了。 &gt; 这些功能的Windows替代品可以<a href="https://zhuanlan.zhihu.com/p/33722847" target="_blank" rel="noopener">参见少数派的文章</a>，不过貌似没有免费的软件可以做到Tilting</p><h3 id="redshift红移">Redshift（红移）</h3><p>红移是Linux底下提供“护眼模式”的软件，有点类似f.lux，这个对我们这个天天盯电脑的还是很有用啦～安装直接<code>apt install redshift plasma-applet-redshift-control</code>即可，第二个软件是Redshift的Plasma插件，可以在任务栏通过它来调节红移，非常方便～安装完后应该就可以通过Plasma挂件来设置红移了，如果不能自动识别地理位置的话<a href="https://wiki.archlinux.org/index.php/Redshift#Automatic_location_based_on_GPS" target="_blank" rel="noopener">参考Arch Wiki中描述的geoclue工具</a></p><blockquote><p>其他还有一些KDE下非常好用的软件，也一并列在这里了～以后用多了再专门开个文章～ - Kdenlive / Audacity：免费的视频/音频剪辑软件，基本够用了～ - Meld：文件比较器 - Remmina / KRDC：远程桌面的客户端，后者是KDE自家的，感觉比Remmina还是差点 - VLC：视频播放器，可以部分替代PotPlayer - Peek / Kazam：录屏软件 - Flameshot：截屏软件 - Gimp：图片编辑软件，堪比Photoshop - Krfb / Xrdp：远程桌面的服务器 - DeaDBeeF：音乐播放器，对cue和utf的支持非常好，可以部分替代fb2k - KDE Partition Manager：KDE版GParted，功能差不多而且界面美观～ - fzf / ripgrep：模糊搜索工具 - Golden Dict：强大的词典框架 - KGet / aria2：下载器 - youtube-dl：视频下载器（Python） - <a href="http://wps-community.org/" target="_blank" rel="noopener">WPS</a> / OnlyOffice：办公套装</p></blockquote><p></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近我已经将KDE Neon作为主力系统之一了，Plasma桌面真的是太好用了！于是给家里的主机也装上了Neon，这篇文章就记录一下安装配置和美化的过程啦～&lt;/p&gt;&lt;img src=&quot;/blog/2019-07/ConfigureKdeNeon/neon.png&quot; title=&quot;Plasma桌面折腾结果～&quot;&gt;&lt;h1 id=&quot;系统安装及boot设置&quot;&gt;系统安装及Boot设置&lt;/h1&gt;&lt;h2 id=&quot;双系统安装&quot;&gt;双系统安装&lt;/h2&gt;&lt;p&gt;安装Neon还是非常简单的，直接从官网下载系统镜像，烧进U盘正常安装即可。不过由于我选择的是与Windows双系统安装，因此需要手动分区。这里要纠正一下之前&lt;a href=&quot;/blog/2018-09/LinuxDualSystem/&quot; title=&quot;安装双系统博文中的分区方式&quot;&gt;安装双系统博文中的分区方式&lt;/a&gt;。现在的Linux系统实际上只需要给根目录&lt;code&gt;/&lt;/code&gt;分区就可以了，&lt;code&gt;/home&lt;/code&gt;分区以前建议单独分区的原因是为了便于系统的更改，这样在修改系统分区之后（如重装系统）还能保留&lt;code&gt;/home&lt;/code&gt;底下的文件，但其实现在很多系统已经能做到重装并保留&lt;code&gt;/home&lt;/code&gt;分区了，这时对于我这小硬盘的笔记本来说反而导致空间利用不灵活。而交换分区&lt;code&gt;/swap&lt;/code&gt;也是没有必要的，交换分区的存在类似于Windows下的虚拟内存，用硬盘的一部分来虚拟内存，避免内存不足的情况。新Linux可以利用交换文件完成类似功能，因此不必专门给&lt;code&gt;/swap&lt;/code&gt;分区。（不过我猜专门给它分个区可能能提高性能？）。最后最关键的是不要给&lt;code&gt;/boot&lt;/code&gt;分区了,&lt;code&gt;/boot&lt;/code&gt;分区是为了保证boot文件区不被占满，以致无法正常启动。利用EFI方式启动的系统只需要有&lt;code&gt;efi&lt;/code&gt;分区即可，而且多个系统可以利用同一个EFI分区。因此只需告诉安装器使用EFI分区作为启动分区，关于EFI的详细信息请看后文~&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;分区的时候还看到了之前的系统里有标记为&lt;code&gt;msr&lt;/code&gt;的分区，是Windows的预留分区，好像具体没啥用。这里贴&lt;a href=&quot;http://bbs.wuyou.net/forum.php?mod=viewthread&amp;amp;tid=374959&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;一篇考据文章&lt;/a&gt;。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="System" scheme="http://zyxin.xyz/blog/categories/System/"/>
    
      <category term="Linux" scheme="http://zyxin.xyz/blog/categories/System/Linux/"/>
    
    
      <category term="Linux" scheme="http://zyxin.xyz/blog/tags/Linux/"/>
    
      <category term="Ubuntu" scheme="http://zyxin.xyz/blog/tags/Ubuntu/"/>
    
      <category term="KDE" scheme="http://zyxin.xyz/blog/tags/KDE/"/>
    
  </entry>
  
  <entry>
    <title>终端（Terminal）美化与扩展</title>
    <link href="http://zyxin.xyz/blog/2019-07/BeautifyTerminal/"/>
    <id>http://zyxin.xyz/blog/2019-07/BeautifyTerminal/</id>
    <published>2019-07-13T15:36:15.000Z</published>
    <updated>2019-11-12T03:02:41.977Z</updated>
    
    <content type="html"><![CDATA[<p>最近由于工作需要，和终端命令行打交道的时间越来越多了，最近便查了一下美化命令行的方法，记录在此以供查阅～另外还推荐一个网站<a href="https://terminalsare.sexy/" target="_blank" rel="noopener">terminalsare.sexy</a>，提供了很多与terminal美化相关的软件。</p><h1 id="命令提示符prompt美化">命令提示符（Prompt）美化</h1><p>相信不少朋友也见过如下图所示美化过的命令提示符 <img src="https://raw.github.com/b-ryan/powerline-shell/master/bash-powerline-screenshot.png" alt="powerline-shell">这个效果的实现方式是通过安装名为<strong>Powerline</strong>的扩展程序。Powerline是一套可拓展的状态栏提示工具，可以给各种Terminal Emulator和Vim等工具增加状态栏的提示，并且十分好用～</p><p>Powerline有很多版本，有直接通过shell配置脚本实现的，也有通过独立程序进行显示的（如下列所示）。我选择的是原版powerline，安装方便，适用软件多，并且可以自行扩展。 - <a href="https://github.com/powerline/powerline" target="_blank" rel="noopener"><strong>powerline</strong></a>: 这应该是最初的也是最全的powerline，基于Python - <a href="https://github.com/b-ryan/powerline-shell" target="_blank" rel="noopener"><strong>powerline-shell</strong></a>: 这是针对美化shell的版本，同样基于Python，配置比上面的简单 - <a href="https://github.com/justjanne/powerline-go" target="_blank" rel="noopener"><strong>powerline-go</strong></a>: 用go语言写的版本，运行更快 - <a href="https://github.com/riobard/bash-powerline" target="_blank" rel="noopener"><strong>bash-powerline</strong></a>: 用bash编写的用于bash的powerline</p><a id="more"></a><p>原版powerline的安装非常简单，用<code>pip</code>安装即可：<code>(sudo) pip install powerline-status</code>。安装完以后<a href="https://powerline.readthedocs.io/en/latest/usage.html#plugins" target="_blank" rel="noopener">根据官网的教程</a>更改对应的配置文件即可～我只对bash进行了美化，因为bash是最常用的shell。使用bash的话建议<a href="https://powerline.readthedocs.io/en/latest/usage/shell-prompts.html#bash-prompt" target="_blank" rel="noopener">按照教程里的指示</a>，在命令行配置文件中开启daemon来提高加载速度。另外一个小技巧是，由于Python2的启动速度比Python3快，因此推荐用Python2来安装powerline。</p><p>安装好powerline后下一步是自定义，这部分内容在powerline的文档里也有描述，不过它的文档写的不太好。。参考powerline安装目录下的配置文件（如果用系统pip安装的话位置是在<code>/usr/local/lib/python2.7/dist-packages/powerline/config_files</code>下），在用户配置目录下<code>~/.config/powerline</code>新建对应的配置文件，然后修改相应的条目即可自定义配置了～比较实用的一项修改是<a href="https://github.com/powerline/powerline/issues/186#issuecomment-247810572" target="_blank" rel="noopener">将shell的默认theme改为<code>default_leftonly</code></a>，不增加这个改动的话不会有git状态的显示。。（并不知道是什么原理）</p><p>如果使用原生Ubuntu或者VSCode内置terminal的话还可能会遇到提示符乱码的原因，这是由于powerline使用了非常规的符号，因此需要安装额外的字体。一般会选择安装<a href="http://nerdfonts.com/" target="_blank" rel="noopener">NerdFont</a>，这是一系列打上符号补丁的字体，其中我个人比较喜欢的字体是<code>DejaVu Mono Nerd</code>～这些字体还可以在<a href="https://app.programmingfonts.org/" target="_blank" rel="noopener">programmingfonts</a>在线预览，挑选喜欢的后将Terminal默认字体更改即可。（注：ubuntu下的查看字体列表命令是<code>fc-list</code>）</p><h1 id="tmux安装及美化">tmux安装及美化</h1><p>tmux是非常著名的Terminal Multiplexer，也就是终端多开程序。很多命令行模拟器其实已经支持多标签页了，如gnome terminal和Konsole，多开的功能其实也已经得到满足了。（顺带一题，ubuntu下新开terminal窗口的默认快捷键是<kbd>Ctrl</kbd>+<kbd>Alt</kbd>+T，新开标签页的默认快捷键是<kbd>Ctrl</kbd>+<kbd>Shift</kbd>+T。）。但还需要tmux是因为需要tmux的session管理功能，这个对远程访问的时候非常有用。有时希望在服务器远端跑一个训练，开上以后就不想管了，那这时如果使用ssh的话就得一直把远程的session开着，或者运行命令后移到后台，但这时停止程序就蛋疼了。另外如果想远程开几个terminal的话也很麻烦，要开好几个ssh的窗口。有了tmux就简单了，你可以用tmux多开然后一次性detach多个session，之后再attach回来进行管理，tmux支持多个程序显示在同一个terminal里，也就不用开很多个ssh了！总之用上tmux后感觉还是很爽的，只不过tmux有一定的学习成本。</p><p>tmux安装也很简单，ubuntu下的话直接使用<code>apt</code>安装即可。另外还可以安装<a href="https://github.com/tmuxinator/tmuxinator" target="_blank" rel="noopener">tmuxinator</a>来简化tmux的一些流程。上面用到的powershell也是支持tmux的，可以美化tmux的状态栏。具体安装方法<a href="https://powerline.readthedocs.io/en/latest/usage/other.html#tmux-statusline" target="_blank" rel="noopener">参见powerline文档</a>。另外tmux的操作方法可以去搜cheatsheet～这也有<a href="https://hackernoon.com/a-gentle-introduction-to-tmux-8d784c404340" target="_blank" rel="noopener">一篇博文介绍了tmux的基本操作</a>，可以参考～</p><h1 id="历史记录搜索">历史记录搜索</h1><p>著名的fish有个颇受称赞的功能是历史命令自动补全（见下图），在zsh里面也有对应的插件可以实现这个功能（<a href="https://github.com/zsh-users/zsh-autosuggestions" target="_blank" rel="noopener">zsh-autosuggestions</a>）。但是bash由于比较辣鸡，无法支持这样的功能，因此只能另寻它法了。。 <img src="https://spin.atomicobject.com/wp-content/uploads/20170512131543/fish-history.gif" alt="fish autosuggestion"></p><p>比较有名的方法是使用一个模糊搜索的软件<a href="https://github.com/junegunn/fzf" target="_blank" rel="noopener"><strong>fzf</strong></a>。这个软件提供文件、程序和命令历史的搜索，有点类似于windows下的Listary。如果配置在shell中的话可以在按下快捷键后出现一个搜索框，搜索历史命令。这个虽然没有fish的自动补全好用，但是也非常方便了～安装fzf推荐通过<a href="https://github.com/junegunn/fzf#using-git" target="_blank" rel="noopener">文档中的方法使用git安装</a>。安装过程中会提示你是否绑定终端快捷键，选择yes后在终端按下<kbd>Ctrl</kbd>+<kbd>R</kbd>就可以弹出搜索框了，非常方便～如果直接运行fzf命令的话就会进入完整的搜索界面，可以搜索文件，具体的使用方法还是参考官方文档了～</p><h1 id="powershell美化">Powershell美化</h1><p>由于Powershell不是传统的sh体系，因此目前powerline还没有官方支持powershell。这里先mark几个博客，设置好了再更新上来～ &gt; - https://github.com/JanDeDobbeleer/oh-my-posh &gt; - https://blog.walterlv.com/post/beautify-powershell-like-zsh.html#%E5%AE%89%E8%A3%85-oh-my-posh &gt; - https://gist.github.com/jchandra74/5b0c94385175c7a8d1cb39bc5157365e &gt; - https://dev.to/myleftshoe/comment/8b58 &gt; - https://www.reddit.com/r/archlinux/comments/45lkyj/is_new_always_better_urxvt_vs_xterm_tmux_vs/</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近由于工作需要，和终端命令行打交道的时间越来越多了，最近便查了一下美化命令行的方法，记录在此以供查阅～另外还推荐一个网站&lt;a href=&quot;https://terminalsare.sexy/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;terminalsare.sexy&lt;/a&gt;，提供了很多与terminal美化相关的软件。&lt;/p&gt;&lt;h1 id=&quot;命令提示符prompt美化&quot;&gt;命令提示符（Prompt）美化&lt;/h1&gt;&lt;p&gt;相信不少朋友也见过如下图所示美化过的命令提示符 &lt;img src=&quot;https://raw.github.com/b-ryan/powerline-shell/master/bash-powerline-screenshot.png&quot; alt=&quot;powerline-shell&quot;&gt;这个效果的实现方式是通过安装名为&lt;strong&gt;Powerline&lt;/strong&gt;的扩展程序。Powerline是一套可拓展的状态栏提示工具，可以给各种Terminal Emulator和Vim等工具增加状态栏的提示，并且十分好用～&lt;/p&gt;&lt;p&gt;Powerline有很多版本，有直接通过shell配置脚本实现的，也有通过独立程序进行显示的（如下列所示）。我选择的是原版powerline，安装方便，适用软件多，并且可以自行扩展。 - &lt;a href=&quot;https://github.com/powerline/powerline&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;strong&gt;powerline&lt;/strong&gt;&lt;/a&gt;: 这应该是最初的也是最全的powerline，基于Python - &lt;a href=&quot;https://github.com/b-ryan/powerline-shell&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;strong&gt;powerline-shell&lt;/strong&gt;&lt;/a&gt;: 这是针对美化shell的版本，同样基于Python，配置比上面的简单 - &lt;a href=&quot;https://github.com/justjanne/powerline-go&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;strong&gt;powerline-go&lt;/strong&gt;&lt;/a&gt;: 用go语言写的版本，运行更快 - &lt;a href=&quot;https://github.com/riobard/bash-powerline&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;strong&gt;bash-powerline&lt;/strong&gt;&lt;/a&gt;: 用bash编写的用于bash的powerline&lt;/p&gt;
    
    </summary>
    
      <category term="Trick" scheme="http://zyxin.xyz/blog/categories/Trick/"/>
    
    
      <category term="Linux" scheme="http://zyxin.xyz/blog/tags/Linux/"/>
    
      <category term="Shell" scheme="http://zyxin.xyz/blog/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>矩阵代数 — Matrix Algebra</title>
    <link href="http://zyxin.xyz/blog/2019-06/MatrixAlgebra/"/>
    <id>http://zyxin.xyz/blog/2019-06/MatrixAlgebra/</id>
    <published>2019-06-06T22:00:12.000Z</published>
    <updated>2019-11-12T03:02:41.997Z</updated>
    
    <content type="html"><![CDATA[<p>在学习线性系统以及SLAM的过程中碰到了很多矩阵的求导与积分运算，但是几乎没有系统地学习过这些知识。矩阵可以构成环，因此也有很多运算性质和推广。最近大佬发给我一本《Matrix Cookbook》，非常系统地列举了进阶矩阵运算的法则，这里贴在博客上以供参考～</p><h1 id="目录">目录</h1><ol type="1"><li>基础内容</li><li>求导</li><li>逆</li><li>复矩阵</li><li>求解与分解</li><li>统计与概率</li><li>多元概率分布</li><li>高斯</li><li>特殊矩阵</li><li>函数与运算符</li></ol><h1 id="来源">来源</h1><p>这本书可以<a href="http://www2.imm.dtu.dk/pubdb/views/publication_details.php?id=3274" target="_blank" rel="noopener">Technical University of Denmark资料网站下到</a>。如果链接失效了，<a href="uploads/misc/matrixcookbook.pdf">可以直接从此处下载</a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在学习线性系统以及SLAM的过程中碰到了很多矩阵的求导与积分运算，但是几乎没有系统地学习过这些知识。矩阵可以构成环，因此也有很多运算性质和推广。最近大佬发给我一本《Matrix Cookbook》，非常系统地列举了进阶矩阵运算的法则，这里贴在博客上以供参考～&lt;/p&gt;&lt;h1 
      
    
    </summary>
    
      <category term="Notes" scheme="http://zyxin.xyz/blog/categories/Notes/"/>
    
      <category term="Math" scheme="http://zyxin.xyz/blog/categories/Notes/Math/"/>
    
    
      <category term="Math" scheme="http://zyxin.xyz/blog/tags/Math/"/>
    
      <category term="Matrix" scheme="http://zyxin.xyz/blog/tags/Matrix/"/>
    
  </entry>
  
  <entry>
    <title>转投Linux发行版</title>
    <link href="http://zyxin.xyz/blog/2019-04/LinuxDistroSelection/"/>
    <id>http://zyxin.xyz/blog/2019-04/LinuxDistroSelection/</id>
    <published>2019-04-26T19:22:02.000Z</published>
    <updated>2019-11-12T03:02:41.977Z</updated>
    
    <content type="html"><![CDATA[<p>由于最近工作一直在使用ROS，因此也一直在用Ubuntu。之前为了稳定性使用的是Ubuntu 16.04 LTS，而这个版本默认的桌面环境是Unity，实在是不好使，它也颇为人诟病。后来尝试了Ubuntu 18.04 LTS安装ROS Melodic，发现ROS也挺稳定的，因此18.04也用了一段时间，但是最后还是觉得不太爽，于是最终还是决定好好体验一下各种Linux选一个自己顺手的。</p><blockquote><p>这篇博客里不会贴系统的截图，因为这些在网上都可以找到，而且桌面的好看与否很大程度上取决于个人的喜好和配置结果。最好的比较方法还是自己装一个系统尝试一下</p></blockquote><p>至于如何尝试linux，我在Windows中使用的是Hyper-V。可以非常方便地安装各种镜像，动态分配资源，最方便的是vhdx硬盘格式可以直接mount到宿主机里。Hyper-V使用一些性能较差的Linux桌面环境时会比较卡，这个时候可以<a href="https://docs.microsoft.com/en-us/windows-server/remote/remote-desktop-services/rds-remotefx-vgpu" target="_blank" rel="noopener">开启RemoteFX GPU（参考官方说明）</a>。注意在Win10 1809之后，Hyper-V管理器界面不提供RemoteFX的开关了，需要用Powershell命令手动开启。<a id="more"></a></p><h1 id="linux-distro">Linux Distro</h1><p>所谓的Linux发行版，对应的是一个专有的英文单词distro。个人理解，Linux Distro就是一套Linux Kernel加上外围一些必要的软件包。之前我一直不理解发行版的意思，直到学会了Python使用上Anaconda之后，才知道发行版指的就是核心程序+预装的全家桶，这个全家桶通常包含包管理器（Package manager，简称PM。如Ubuntu的apt、Anaconda的conda）、内置软件（如Linux桌面环境、Anaconda预装的Scipy）以及一套系统逻辑。</p><p>Linux发行版中很重要的一点便是系统的PM，这个管理器还决定了系统的更新逻辑。而不同发行版之间最大的区别，在我看来就是PM（以及软件仓库repository），因此PM的特性与相性最终会决定我是否选择这套发行版。</p><p>常见的桌面Linux发行版有如下这些，我可以大概描述一下他们的特点（以PM为线索）： - <strong>apt</strong>: Debian、Ubuntu系 - 依赖树严格，能保证软件之间正确的依赖关系 - Debian和Ubuntu的软件库数量庞大，但是确实由于保守的包更新政策，它们的包比较老 - apt的命令行使用非常直观 - 在国内，默认的仓库源下载很慢，但是国内有很多开源镜像可以使用 - <strong>pacman</strong>: Arch - 滚动更新是Arch最大的特点 - pacman没有严格的依赖树，而是类似于快照的概念，更新软件时整个软件池都会进行变动（个人理解） - pacman命令行参数是字母表，不便于记忆 - Arch的官方软件仓库中软件较少，但是Arch有庞大的AUR体系，因此能够尝试到很多小软件和新版本，不过也要承担小白鼠的风险 - <strong>yum/dnf</strong>: Fedora、CentOS、Redhat等 - 使用方法和apt相似 - 软件仓库中的数量没有Debian和Arch多 - 包管理方便，中规中据，而且下载速度不慢 - <strong>zypper</strong>: OpenSUSE - 由于OpenSUSE是真的比较小众，因此我也没有去尝试，就不妄自评论了 - <strong>emerge</strong>: Gentoo - 同上，没尝试过 严格来说，上面的这些都是包分发器，而安装软件的是包安装器（dpkg,rpm等），不过前者才是我们最经常打交道的。关于这些PM以及其软件管理哲学的分析，可以<a href="https://www.zhihu.com/question/40297380" target="_blank" rel="noopener">参见这个知乎问题</a>。而关于这些包管理器的一篇介绍可以<a href="https://linux.cn/article-9931-1.html" target="_blank" rel="noopener">参见这篇博文</a>。</p><blockquote><p>Arch Linux的wiki上也有一篇<a href="https://wiki.archlinux.org/index.php/Arch_compared_to_other_distributions" target="_blank" rel="noopener">关于发行版之间的对比</a>，这里我要吹一下Arch的wiki真的良心，还有中文版！ <a href="https://distrowatch.com/" target="_blank" rel="noopener">DistroWatch</a>是一个收集了大量Linux distro的网站，可以在上面看一下流行度排名和一些评测 Linux各发行版的演化历史可以参见<a href="https://commons.wikimedia.org/wiki/File:Linux_Distribution_Timeline.svg" target="_blank" rel="noopener">Wiki的历史图</a>或者<a href="https://distrowatch.com/dwres.php?resource=family-tree" target="_blank" rel="noopener">DistroWatch的图表</a></p></blockquote><h1 id="桌面环境">桌面环境</h1><p>桌面环境是最终选择哪一个发行版的决定者。选择Ubuntu、Arch等只能给你决定好大方向，而最后在众多系统中作出选择的标准之一便是桌面环境。常见的桌面环境有Gnome、KDE Plasma、XFCE、LXQt等。现在众多的发行版的主要区别其实也就是PM和桌面环境的区别： - Ubuntu 16.04: Ubuntu + Unity - Ubuntu 18.04: Ubuntu + Gnome - KUbuntu: Ubuntu + KDE - XUbuntu: Ubuntu + XFCE - MX Linux: Debian + XFCE - Linux Mint: Ubuntu + Cinammon/Gnome - Manjaro: Arch + KDE - Deepin: Debian + Deepin - ...</p><p>而这些桌面环境的特点，个人感觉如下： - Gnome(w/ gdm): 基于GTK开发，默认界面比较好看，但是灵活程度不够。虽然有Gnome Tweak，但是插件很少 - KDE Plasma(w/ sddm): 基于QT开发，非常灵活，而且Plasma5默认就非常好看！占用资源也比Gnome小。 - Unity(w/ lightdm): 别说了，换吧 - Xfce: 听人说很不错，但是我认为比较丑 - LXQt(w/ sddm): 适合低配环境，也不太好看</p><h1 id="个人选择">个人选择</h1><p><strong>Arch？</strong>: 在我了解Linux distro的过程中，在各种论坛、知乎问题上都有人安利Arch linux。Arch虽好，而且可以体验更新的快感，但是我本身没有太多的时间去折腾系统，或者追寻潮流，因此还是更倾向于Debian体系。同时由于我有使用ROS的需求，因此Ubuntu还是我的第一选择。</p><p><strong>商业主导 or 社区主导</strong>: 有人说Ubuntu由于是Canonical家的产品，会有商业倾向，服从公司利益。这个情况确实存在，但是就体验上来说和Arch、Fedora等等社区主导的系统并没有太多区别，因此这个并不会是决定我选择的因素。</p><p><strong>Gnome or KDE</strong>: 相比于GTK，我更喜欢Qt这套框架。另外KDE也有别人上传的很多插件和桌面（在KDE store上)，非常棒，因此我最后选择的是KDE～</p><p>综上所述，我最后决定使用KDE Neon作为平常使用的发行版，双系统安装Ubuntu 18.04作为开发系统。之后会写一篇博客来介绍KDE的折腾记录～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于最近工作一直在使用ROS，因此也一直在用Ubuntu。之前为了稳定性使用的是Ubuntu 16.04 LTS，而这个版本默认的桌面环境是Unity，实在是不好使，它也颇为人诟病。后来尝试了Ubuntu 18.04 LTS安装ROS Melodic，发现ROS也挺稳定的，因此18.04也用了一段时间，但是最后还是觉得不太爽，于是最终还是决定好好体验一下各种Linux选一个自己顺手的。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;这篇博客里不会贴系统的截图，因为这些在网上都可以找到，而且桌面的好看与否很大程度上取决于个人的喜好和配置结果。最好的比较方法还是自己装一个系统尝试一下&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;至于如何尝试linux，我在Windows中使用的是Hyper-V。可以非常方便地安装各种镜像，动态分配资源，最方便的是vhdx硬盘格式可以直接mount到宿主机里。Hyper-V使用一些性能较差的Linux桌面环境时会比较卡，这个时候可以&lt;a href=&quot;https://docs.microsoft.com/en-us/windows-server/remote/remote-desktop-services/rds-remotefx-vgpu&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;开启RemoteFX GPU（参考官方说明）&lt;/a&gt;。注意在Win10 1809之后，Hyper-V管理器界面不提供RemoteFX的开关了，需要用Powershell命令手动开启。
    
    </summary>
    
      <category term="System" scheme="http://zyxin.xyz/blog/categories/System/"/>
    
      <category term="Linux" scheme="http://zyxin.xyz/blog/categories/System/Linux/"/>
    
    
      <category term="Linux" scheme="http://zyxin.xyz/blog/tags/Linux/"/>
    
      <category term="Ubuntu" scheme="http://zyxin.xyz/blog/tags/Ubuntu/"/>
    
      <category term="KDE" scheme="http://zyxin.xyz/blog/tags/KDE/"/>
    
  </entry>
  
</feed>
