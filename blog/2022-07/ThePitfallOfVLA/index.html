<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0"><link rel="apple-touch-icon" sizes="180x180" href="/blog/uploads/assets/icon200.png"><link rel="icon" type="image/png" sizes="32x32" href="/blog/uploads/assets/icon32.png"><link rel="icon" type="image/png" sizes="16x16" href="/blog/uploads/assets/icon16.png"><link rel="mask-icon" href="/blog/images/logo.svg" color="#222"><link rel="stylesheet" href="/blog/css/main.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.css"><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script><script class="next-config" data-name="main" type="application/json">{"hostname":"zyxin.xyz","root":"/blog/","images":"/blog/images","scheme":"Muse","darkmode":false,"version":"8.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":true},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":"disqus","storage":true,"lazyload":false,"nav":{"disqus":{"text":"Disqus Comments"},"livere":{"text":"LiveRe Comments"}},"store":true,"activeClass":"disqus"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/blog/js/config.js"></script><meta name="description" content="前言 ❮ 这篇文章转载自 Jorengarenar 的博客。类似于前一篇文章，这一篇博文是我在搜索为什么 Rust 不支持动态栈分配的时候看到的。有很多人希望 Rust 支持变长数组，并且有一个相关的 RFC，但是也有人提到这很危险，并且不会带来太大的收益，这篇文章总结了变长数组的问题，可供参考。"><meta property="og:type" content="article"><meta property="og:title" content="（C 语言）变长数组的陷阱"><meta property="og:url" content="http://zyxin.xyz/blog/2022-07/ThePitfallOfVLA/index.html"><meta property="og:site_name" content="Jacob Zhong"><meta property="og:description" content="前言 ❮ 这篇文章转载自 Jorengarenar 的博客。类似于前一篇文章，这一篇博文是我在搜索为什么 Rust 不支持动态栈分配的时候看到的。有很多人希望 Rust 支持变长数组，并且有一个相关的 RFC，但是也有人提到这很危险，并且不会带来太大的收益，这篇文章总结了变长数组的问题，可供参考。"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2022-07-24T18:15:17.000Z"><meta property="article:modified_time" content="2022-07-24T20:05:11.168Z"><meta property="article:author" content="Jacob Zhong"><meta property="article:tag" content="Memory"><meta name="twitter:card" content="summary"><link rel="canonical" href="http://zyxin.xyz/blog/2022-07/ThePitfallOfVLA/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://zyxin.xyz/blog/2022-07/ThePitfallOfVLA/","path":"2022-07/ThePitfallOfVLA/","title":"（C 语言）变长数组的陷阱"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>（C 语言）变长数组的陷阱 | Jacob Zhong</title><noscript><link rel="stylesheet" href="/blog/css/noscript.css"></noscript><link rel="alternate" href="/blog/atom.xml" title="Jacob Zhong" type="application/atom+xml">
</head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/blog/" class="brand" rel="start"><i class="logo-line"></i><h1 class="site-title">Jacob Zhong</h1><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">b.zyxin.xyz</p></div><div class="site-nav-right"><div class="toggle popup-trigger"></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-sitemap"><a href="/blog/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a></li></ul></nav></div><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%A3%E6%96%87"><span class="nav-number">2.</span> <span class="nav-text">正文</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%88%E5%88%86%E9%85%8D"><span class="nav-number">3.</span> <span class="nav-text">栈分配</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E7%B3%9F%E7%B3%95%E7%9A%84%E6%98%AF"><span class="nav-number">4.</span> <span class="nav-text">最糟糕的是</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%82%A3%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9%E8%BF%99%E4%B8%AA%E4%BE%8B%E5%AD%90%EF%BC%9F"><span class="nav-number">5.</span> <span class="nav-text">那如何修改这个例子？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%84%8F%E5%A4%96%E5%88%9B%E5%BB%BA"><span class="nav-number">6.</span> <span class="nav-text">意外创建</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AF%94%E5%AE%9A%E9%95%BF%E6%85%A2"><span class="nav-number">7.</span> <span class="nav-text">比定长慢</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%A0%E6%B3%95%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">8.</span> <span class="nav-text">无法初始化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%99%E7%BC%96%E8%AF%91%E5%99%A8%E4%BD%9C%E8%80%85%E5%B8%A6%E6%9D%A5%E9%BA%BB%E7%83%A6"><span class="nav-number">9.</span> <span class="nav-text">给编译器作者带来麻烦</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%99%8D%E4%BD%8E%E5%8F%AF%E7%A7%BB%E6%A4%8D%E6%80%A7"><span class="nav-number">10.</span> <span class="nav-text">降低可移植性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BC%88%E6%8C%91%E9%AA%A8%E5%A4%B4%EF%BC%89%E6%89%93%E7%A0%B4%E8%B0%83%E7%94%A8%E4%B9%A0%E6%83%AF"><span class="nav-number">11.</span> <span class="nav-text">（挑骨头）打破调用习惯</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%93%E8%AE%BA"><span class="nav-number">12.</span> <span class="nav-text">结论</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Jacob Zhong" src="/blog/uploads/assets/avatar.png"><p class="site-author-name" itemprop="name">Jacob Zhong</p><div class="site-description" itemprop="description">Blog of Jacob Zhong</div></div><div class="site-state-wrap site-overview-item animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/blog/archives/"><span class="site-state-item-count">62</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/blog/categories/"><span class="site-state-item-count">16</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/blog/tags/"><span class="site-state-item-count">50</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author site-overview-item animated"><span class="links-of-author-item"><a href="https://github.com/cmpute" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;cmpute" rel="noopener" target="_blank"><i class="github fa-fw"></i>GitHub</a> </span><span class="links-of-author-item"><a href="https://www.linkedin.com/in/jacobzhong/" title="LinkedIn → https:&#x2F;&#x2F;www.linkedin.com&#x2F;in&#x2F;jacobzhong&#x2F;" rel="noopener" target="_blank"><i class="linkedin-square fa-fw"></i>LinkedIn</a> </span><span class="links-of-author-item"><a href="mailto:cmpute@foxmail.com" title="E-Mail → mailto:cmpute@foxmail.com" rel="noopener" target="_blank"><i class="envelope fa-fw"></i>E-Mail</a> </span><span class="links-of-author-item"><a href="https://www.last.fm/user/cmpute" title="Last.fm → https:&#x2F;&#x2F;www.last.fm&#x2F;user&#x2F;cmpute" rel="noopener" target="_blank"><i class="lastfm-square fa-fw"></i>Last.fm</a></span></div><div class="links-of-blogroll site-overview-item animated"><div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i> Friend Links</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="https://hanyuz1996.github.io/" title="https:&#x2F;&#x2F;hanyuz1996.github.io&#x2F;" rel="noopener" target="_blank">Hanyuz</a></li><li class="links-of-blogroll-item"><a href="https://xingminw.github.io/" title="https:&#x2F;&#x2F;xingminw.github.io&#x2F;" rel="noopener" target="_blank">Xingminw</a></li></ul></div></div></div></div></aside><div class="sidebar-dimmer"></div></header><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://zyxin.xyz/blog/2022-07/ThePitfallOfVLA/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/blog/uploads/assets/avatar.png"><meta itemprop="name" content="Jacob Zhong"><meta itemprop="description" content="Blog of Jacob Zhong"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Jacob Zhong"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">（C 语言）变长数组的陷阱</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-07-24 14:15:17 / 修改时间：16:05:11" itemprop="dateCreated datePublished" datetime="2022-07-24T14:15:17-04:00">2022-07-24</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/blog/categories/Coding/" itemprop="url" rel="index"><span itemprop="name">Coding</span></a> </span>， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/blog/categories/Coding/Language/" itemprop="url" rel="index"><span itemprop="name">Language</span></a> </span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span id="busuanzi_value_page_pv"></span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Disqus：</span> <a title="disqus" href="/blog/2022-07/ThePitfallOfVLA/#disqus_thread" itemprop="discussionUrl"><span class="post-comments-count disqus-comment-count" data-disqus-identifier="2022-07/ThePitfallOfVLA/" itemprop="commentCount"></span></a></span></div></div></header><div class="post-body" itemprop="articleBody"><div class="note default"><h2 id="前言">前言<a class="header-anchor" href="#前言"> ❮</a></h2><p>这篇文章转载自 <a target="_blank" rel="noopener" href="https://blog.joren.ga/vla-pitfalls">Jorengarenar 的博客</a>。类似于前一篇文章，这一篇博文是我在搜索为什么 Rust 不支持动态栈分配的时候看到的。有很多人希望 Rust 支持变长数组，并且有一个<a target="_blank" rel="noopener" href="https://github.com/rust-lang/rust/issues/48055">相关的 RFC</a>，但是<a target="_blank" rel="noopener" href="https://users.rust-lang.org/t/a-question-about-how-memory-is-stored-and-vlas/33901/16?u=cmpute">也有人提到这很危险</a>，并且不会带来太大的收益，这篇文章总结了变长数组的问题，可供参考。</p></div><span id="more"></span><h2 id="正文">正文<a class="header-anchor" href="#正文"> ❮</a></h2><blockquote><p>相比于固定尺寸，它会生成更多的、并且更慢的代码（而且很脆弱）。—— <a target="_blank" rel="noopener" href="https://lkml.org/lkml/2018/3/7/621">Linus Torvalds</a></p></blockquote><p>VLA 是变长数组（variable-length array）的缩写，它指的是长度在运行时而不是编译时决定的数组（真・数组，而不是接口像数组的一块内存）。VLA 在 C99 标准中被引进，乍看上去它很方便并且高效，但是这只是各幻觉，实际上它只是一些顽固问题的源头。</p><p>这篇文章的批评主要针对自动变长数组（automatic VLA），而不是所有形式的 VLA，因此我在后文会用缩写 aVLA 来进行区分。</p><blockquote><p>支持某种形式的 VLA 的语言有：Ada, Algol 68, C, C#, COBOL, Fortran, J 和 Object Pascal。你可能注意到了，除了 C 和 C# 之外，其他的语言都不主流了。</p><p>你从开头的引言中可能也猜到了，一个相当依赖于 VLA 的项目不是别的，正是 Linux 内核。维护者们花费了很多精力来移除 VLA，并且在内核版本 4.20（2018 年）后实现了完全无 VLA。</p><p>在这篇文章刚开头的时候，我还要指出，在一些情形下，VLA 是一个好解决方案。这样的情形不多，但是确实存在。未来我会尽力好好介绍他们并且链接到这篇文章来。</p></blockquote><h2 id="栈分配">栈分配<a class="header-anchor" href="#栈分配"> ❮</a></h2><p>aVLA 通常分配在栈上，这就绝大部分问题的根源。我们来看一个非常简单并且看起来很适合 aVLA 的例子：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">double</span> arr[n];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%Lf"</span>, arr[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>你可以发现，这段代码从用户的输入读取数组长度。编译并且跑一下试试，看看在堆栈溢出造成区块错误（segfault）前，你可以输入多少值。在我的测试里这个上限是 50 万。这只是一个基础数据类型！想象以下对于一个结构体这个上限可能是多少！或者如果不仅仅是 <code>main()</code>？考虑下递归函数？这个上限会大幅降低。</p><p>并且，你没有任何（可移植、标准）的方法来处理堆栈溢出 —— 你的程序已经无可救药地崩了。因此你要么需要在声明数组之前进行严格的长度审查，要么指望用户不要输入太大的数据。（这样赌博的后果显而易见）</p><p>因此程序员<strong>必须</strong>保证 aVLA 的商都不能超过安全的上限。但是实际情况里，如果你知道这个安全上限，那没道理你不会去确认它。</p><h2 id="最糟糕的是">最糟糕的是<a class="header-anchor" href="#最糟糕的是"> ❮</a></h2><p>最糟糕的是 segfault 只是不当使用 aVLA 造成的后果中最好的一个。最坏情况是造成可以被利用的漏洞，攻击者可能会选择一个值，使得这个数组与其他内存分配重叠，从而控制那些值。这是个安全性灾难。</p><blockquote><p>如果你接受（进一步）损失程序性能，在 GCC 中你可以开启 <code>-fstack-clash-protection</code> 选项，它会在进行变长栈空间分配时，增加额外的指令来在每个内存页上进行探测。这可以确保所有的栈分配是有效的，或者在无效的时候抛出 segfault，来缓解栈冲突（stack-clash）问题，从而将可能的代码执行攻击变成服务拒绝（denial of service）</p></blockquote><h2 id="那如何修改这个例子？">那如何修改这个例子？<a class="header-anchor" href="#那如何修改这个例子？"> ❮</a></h2><p>如果我想让用户决定数组大小并且创建大的离谱的定长数组很浪费？很简单，用 <code>malloc()</code>！</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">double</span>* arr = <span class="built_in">malloc</span>(n * (<span class="keyword">sizeof</span> *arr));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%Lf"</span>, arr[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">free</span>(arr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在这个例子里我可以最大输入 13 亿而不让我的机子报错。这大概是之前的 2500 倍！但是我最后仍然会碰到 segfault 是吧？唔，区别在于我们可以检查 <code>malloc()</code> 的返回值，然后比如我们就可以告知用户：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">double</span>* arr = <span class="built_in">malloc</span>(n * (<span class="keyword">sizeof</span> *arr));</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="literal">NULL</span>) {</span><br><span class="line">    perror(<span class="string">"malloc()"</span>); <span class="comment">// output: "malloc(): Cannot allocate memory"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>我碰到过相左的观点：C 经常被用于系统和嵌入式的语言，这些情况下可能都没法使用 <code>malloc()</code>。</p><p>唉。。看来我又要重复一遍了，不过这确实很重要。</p><p>在这种设备上你同样也没有多少栈空间。因此相比于在栈上动态分配空间，你应该确定你到底需要多少内存然后只使用固定尺寸的内存。</p><p>当在栈空间很小的设备上使用 aVLA 的时候，你很容易弄出一些看起来能用的东西，但是当你的函数在栈已经很深的，有很多数据的时候被调用，你的栈就会炸。</p><p>如果你在每个地方都分配固定尺寸的栈空间，那么你知道这肯定没问题。如果你在栈上动态分配内存，你需要测试你所有的代码路径，并且在所有可能的分配尺寸情况下进行测试，这比前者更难更容易出错。不要在甚至没有好处的情况下让它更容易射到你的脚（一个歇后语：footgun）</p></blockquote><h2 id="意外创建">意外创建<a class="header-anchor" href="#意外创建"> ❮</a></h2><p>不像其他危险的 C 语言特性，aVLA 没有什么门槛。很多新手会在试错之后开始使用这个特性，却根本不了解它的问题。有些时候甚至很有经验的程序员都会大意，在不需要 aVLA 的时候创建它。以下就是一个完全没必要的静静地创建了一个 aVLA 的例子：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> A[n];</span><br></pre></td></tr></tbody></table></figure><p>好在只要是个比较现代的编译器都会发现并且把这个 aVLA 给优化掉，但是。。。万一它没发现呢？或者它处于某种原因（安全？）没有这么做呢？优化没打开呢？但这肯定都问题不大，是吧？呃。。。</p><h2 id="比定长慢">比定长慢<a class="header-anchor" href="#比定长慢"> ❮</a></h2><p>在编译器不优化的情况下，之前这个 <a target="_blank" rel="noopener" href="https://godbolt.org/z/c7nPvGGcP">aVLA 的例子</a>在数组初始化之前会生成 7 倍多的汇编指令，相比于它<a target="_blank" rel="noopener" href="https://godbolt.org/z/jx94vx84T">对应的定长情况</a>（参见 <code>jmp .L5</code> 之前的汇编部分）。但这是没有开编译器优化的情况，如果开了生成的汇编是一模一样的。</p><p>这里有一个 aVLA 不是意外插入的例子：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">(<span class="keyword">int</span>*, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 1 <span class="comment">// 1 for aVLA, 0 for aVLA-free</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> A[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i--;) {</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;A[i]);</span><br><span class="line">    }</span><br><span class="line">    bar(A, n);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> A[<span class="number">1000</span>];  <span class="comment">// Let's make it bigger than 10! (or there won't be what to examine)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i--;) {</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;A[i]);</span><br><span class="line">    }</span><br><span class="line">    bar(A, n);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    foo(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">(<span class="keyword">int</span>* B, <span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i--;) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d"</span>, i, B[i]);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>处于介绍的目的，在这个例子中 <code>-O1</code> 级别的优化是最好的（生成的汇编会更清楚，然后 <code>-O2</code> 并不会有太大的用处）。</p><p>当我们编译 aVLA 的版本，在 <code>for</code> 循环之前的指令如下：</p><figure class="highlight x86asm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">push</span>    <span class="built_in">rbp</span></span><br><span class="line"><span class="keyword">mov</span>     <span class="built_in">rbp</span>, <span class="built_in">rsp</span></span><br><span class="line"><span class="keyword">push</span>    <span class="built_in">r14</span></span><br><span class="line"><span class="keyword">push</span>    <span class="built_in">r13</span></span><br><span class="line"><span class="keyword">push</span>    <span class="built_in">r12</span></span><br><span class="line"><span class="keyword">push</span>    <span class="built_in">rbx</span></span><br><span class="line"><span class="keyword">mov</span>     <span class="built_in">r13d</span>, <span class="built_in">edi</span></span><br><span class="line"><span class="keyword">movsx</span>   <span class="built_in">r12</span>, <span class="built_in">edi</span>       <span class="comment">; here aVLA "starts"...</span></span><br><span class="line"><span class="keyword">sal</span>     <span class="built_in">r12</span>, <span class="number">2</span>         <span class="comment">;</span></span><br><span class="line"><span class="keyword">lea</span>     <span class="built_in">rax</span>, [<span class="built_in">r12</span>+<span class="number">15</span>]  <span class="comment">;</span></span><br><span class="line"><span class="keyword">and</span>     <span class="built_in">rax</span>, -<span class="number">16</span>       <span class="comment">;</span></span><br><span class="line"><span class="keyword">sub</span>     <span class="built_in">rsp</span>, <span class="built_in">rax</span>       <span class="comment">;</span></span><br><span class="line"><span class="keyword">mov</span>     <span class="built_in">r14</span>, <span class="built_in">rsp</span>       <span class="comment">; ... and there "ends"</span></span><br></pre></td></tr></tbody></table></figure><p>而无 aVLA 的版本则生成：</p><figure class="highlight x86asm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">push</span>    <span class="built_in">r12</span></span><br><span class="line"><span class="keyword">push</span>    <span class="built_in">rbp</span></span><br><span class="line"><span class="keyword">push</span>    <span class="built_in">rbx</span></span><br><span class="line"><span class="keyword">sub</span>     <span class="built_in">rsp</span>, <span class="number">4000</span>      <span class="comment">; this is caused by array definition</span></span><br><span class="line"><span class="keyword">mov</span>     <span class="built_in">r12d</span>, <span class="built_in">edi</span></span><br></pre></td></tr></tbody></table></figure><p>因此不仅定长数组生成更少的代码，它也简单多了。为什么 aVLA 在最开始的时候会产生更多的开销？它没有什么特别伟大的任务，但仍然不是简简单单的一个指针移动。</p><p>但是这些区别影响很大吗？<a target="_blank" rel="noopener" href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=02361bc77888">是的，很大</a>。</p><h2 id="无法初始化">无法初始化<a class="header-anchor" href="#无法初始化"> ❮</a></h2><p>在 aVLA 不经意间造成的问题中还有如下不被允许的例子：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> A[n] = { <span class="number">0</span> };</span><br></pre></td></tr></tbody></table></figure><p>即便开了优化，aVLA 仍然不支持初始化。因此尽管我们想要的是定长数组并且理论上编译器可以干这件事，但它就是行不通。</p><h2 id="给编译器作者带来麻烦">给编译器作者带来麻烦<a class="header-anchor" href="#给编译器作者带来麻烦"> ❮</a></h2><p>几个月前我存了 Reddit 上的一个<a target="_blank" rel="noopener" href="https://www.reddit.com/r/C_Programming/comments/jz2213/are_vlas_bad_even_if_theyre_not_allocated_on_the/gdc3hz6">评论</a>，它列举了从编译器开发者的角度在 VLA 上碰到的问题。我把它引在下面：</p><blockquote><ul><li>VLA 其实适用于一个类型，而不是一个实际数组。因此你可以给 VLA 类型加一个 <code>typedef</code>，它会冻结用到的表达式，即便这个表达式的一部分在 VLA 类型被使用的时候已经变了</li><li>VLA 可以在代码块和循环中使用，这意味着要在栈上分配和释放动态长度的数据，如果你不想让偏移量（offsets）被乱搞，你就需要用指针来间接地实现它。</li><li>你可以在有 VLA 被使用的情况下用 <code>goto</code> 跳进或者跳出代码块，有些事情会被限制，但是也有不被限制的，而编译器却需要跟踪所有的这些骚操作</li><li>VLA 可以被用在多维数组上</li><li>VLA 可以被指针指向（因此你不需要分配空间，但是仍然需要跟踪所有变量的大小）</li><li>有些编译器允许在结构体定义里面使用 VLA（我真的不知道这是怎么弄的，或者在什么地方 VLA 的尺寸被定下来了，然后所有的结构体会拥有同样的 VLA 尺寸）</li><li>一个函数可以同时有多个 VLA 被使用，并且它们可以在不同的地方，或者有条件地，或者在循环里被创建或者销毁。</li><li><code>sizeof</code> 需要被专门针对 VLA 实现（针对一个 VLA 实体，VLA 类型，混合 VLA 和定长尺寸的类型，VLA 数组，VLA 指针）</li><li>VLA 这个词还被用于描述（当维数由传入参数确定时）多维数组的参数</li><li>在 Windows 上用有些编译器的时候（至少 GCC 是这样），声明过大的局部数组（使得栈尺寸超过 4KB）意味着要调用一个特殊的分配器（<code>__chkstk()</code>），因为栈空间一次只能增长一个内存页）。当声明一个 VLA 的时候，编译器不知道它的长度，因此它需要在每个涉及的函数里都调用（<code>__chkstk()</code>），即便 VLA 的尺寸实际上很小。</li></ul></blockquote><p>并且相信我，如果你在 C 语言的一些论坛里溜一圈，你会发现更多不同的抱怨。</p><h2 id="降低可移植性">降低可移植性<a class="header-anchor" href="#降低可移植性"> ❮</a></h2><p>由于前面提到的这所有问题，有些编译器决定不完全支持 C99。最主要的例子是微软的 MSVC。C 语言标准委员会页注意到了这个问题，并且在 C11 修订版中将 VLA 的支持标为可选的。</p><blockquote><p>C2x 计划将推翻这个决定，但是 aVLA 仍然不是强制的</p></blockquote><p>这意味着使用 VLA 的代码有可能没法被一个 C11 编译器编译。因此你需要检查<code>__STDC_NO_VLA__</code>宏，并且在不支持的时候增加备用选项。</p><blockquote><p>另外，C++ 没有 VLA 并且没有证据表明它有将来会支持。这不是什么大事，但是仍然给 C 的 VLA 提供了一个反例</p></blockquote><h2 id="（挑骨头）打破调用习惯">（挑骨头）打破调用习惯<a class="header-anchor" href="#（挑骨头）打破调用习惯"> ❮</a></h2><p>这是鸡蛋里挑骨头了，但是它确实是另一个让人不喜欢 VLA 的原因。一个常用的函数调用习惯是先传指针，再传参数，对于数组它的意思是：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span>** arr, <span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>{ <span class="comment">/* arr[i][j] = ... */</span> }</span><br></pre></td></tr></tbody></table></figure><p>C99 标准中，提到数组的长度必须在参数列表里遇到的时候立马被分析确定，这意味着在用 VLA 的时候你没法用跟上面一样的语法</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> arr[n][m], <span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>{ <span class="comment">/* arr[i][j] = ... */</span> } <span class="comment">// 非法！</span></span><br></pre></td></tr></tbody></table></figure><p>你需要</p><ul><li>打破这个习惯<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="keyword">int</span> arr[n][m])</span> </span>{ <span class="comment">/* arr[i][j] = ... */</span> }</span><br></pre></td></tr></tbody></table></figure></li><li>或者使用过时的语法（即将被标准删除）<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span>[*][*], <span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(arr, n, n)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">int</span> n</span>;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="keyword">int</span> arr[n][m]</span><br><span class="line">{</span><br><span class="line">    <span class="comment">// arr[i][j] = ...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="结论">结论<a class="header-anchor" href="#结论"> ❮</a></h2><p>简而言之，别用 VLA，编译你代码的时候开启 <code>-Wvla</code> 开关。VLA 特性带来了很多危险却经常没有与之匹配的有用的回报。如果你发现在你的使用场景里里 VLA 是一个有效的解决方法，那就用它，但是记住我上面所提到的这些局限。</p><blockquote><p>可能还值得一提的是，VLA 还被认为是解决问题同样很多的，不标准的 <code>alloca()</code> 的一个途径。</p></blockquote></div><footer class="post-footer"><div class="reward-container"><div>Treat me some coffee XD</div><button>赞赏</button><div class="post-reward"><div><img src="/blog/uploads/assets/wechatpay.jpg" alt="Jacob Zhong 微信"> <span>微信</span></div><div><img src="/blog/uploads/assets/alipay.jpg" alt="Jacob Zhong 支付宝"> <span>支付宝</span></div></div></div><div class="post-copyright"><ul><li class="post-copyright-author"><strong>本文作者： </strong>Jacob Zhong</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="http://zyxin.xyz/blog/2022-07/ThePitfallOfVLA/" title="（C 语言）变长数组的陷阱">http://zyxin.xyz/blog/2022-07/ThePitfallOfVLA/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="post-tags"><a href="/blog/tags/Memory/" rel="tag"># Memory</a></div><div class="post-nav"><div class="post-nav-item"><a href="/blog/2022-07/ThePitfallOfLongDouble/" rel="prev" title="长浮点数（long double）的陷阱"><i class="fa fa-chevron-left"></i> 长浮点数（long double）的陷阱</a></div><div class="post-nav-item"></div></div></footer></article></div><div class="tabs tabs-comment"><ul class="nav-tabs"><li class="tab"><a href="#comment-disqus">Disqus Comments</a></li><li class="tab"><a href="#comment-livere">LiveRe Comments</a></li></ul><div class="tab-content"><div class="tab-pane disqus" id="comment-disqus"><div class="comments" id="disqus_thread"><noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript></div></div><div class="tab-pane livere" id="comment-livere"><div class="comments" id="lv-container" data-id="city" data-uid="MTAyMC81NDQ2Ni8zMDkzNw=="></div></div></div></div></div></main><footer class="footer"><div class="footer-inner"><div class="languages"><label class="lang-select-label"><i class="fa fa-language"></i> <span>简体中文</span> <i class="fa fa-angle-up" aria-hidden="true"></i></label> <select class="lang-select" data-canonical="" aria-label="选择语言"><option value="zh-CN" data-href="/blog/2022-07/ThePitfallOfVLA/" selected>简体中文</option><option value="en" data-href="/blog/en/2022-07/ThePitfallOfVLA/" selected>English</option></select></div><div class="copyright">&copy; 2017 – <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="fire"></i> </span><span class="author" itemprop="copyrightHolder">Jacob Zhong</span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div><div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动</div></div></footer><script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="https://cdn.jsdelivr.net/npm/@next-theme/pjax@0.5.0/pjax.min.js" integrity="sha256-3NkoLDrmHLTYj7csHIZSr0MHAFTXth7Ua/DDt4MRUAg=" crossorigin="anonymous"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js" integrity="sha256-EdPgYcPk/IIrw7FYeuJQexva49pVRZNmt3LculEr7zM=" crossorigin="anonymous"></script><script src="https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script><script src="/blog/js/comments.js"></script><script src="/blog/js/utils.js"></script><script src="/blog/js/motion.js"></script><script src="/blog/js/schemes/muse.js"></script><script src="/blog/js/next-boot.js"></script><script src="/blog/js/pjax.js"></script><script src="/blog/js/third-party/pace.js"></script><script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"ams","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script><script src="/blog/js/third-party/math/mathjax.js"></script><script class="next-config" data-name="disqus" type="application/json">{"enable":true,"shortname":"jacob-zhongs-blog","count":true,"i18n":{"disqus":"disqus"}}</script><script src="/blog/js/third-party/comments/disqus.js"></script><script src="/blog/js/third-party/comments/livere.js"></script></body></html>